<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nimcuda/cuda_runtime_api</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.0.8">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.0.8"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">nimcuda/cuda_runtime_api</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">ðŸŒ— Match OS</option>
        <option value="dark">ðŸŒ‘ Dark</option>
        <option value="light">ðŸŒ• Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a id="indexLink" href="theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" onkeyup="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#7" id="57">Types</a></summary>
    <ul class="simple simple-toc-section">
      <li><a class="reference" href="#cudaStreamCallback_t" title="cudaStreamCallback_t = proc (stream: cudaStream_t; status: cudaError_t;
                             userData: pointer) {.cdecl.}">cudaStreamCallback_t</a></li>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#10" id="60">Consts</a></summary>
    <ul class="simple simple-toc-section">
      <li><a class="reference" href="#CUDART_VERSION" title="CUDART_VERSION = 8000">CUDART_VERSION</a></li>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#12" id="62">Procs</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">cudaArrayGetInfo
  <li><a class="reference" href="#cudaArrayGetInfo%2Cptr.cudaChannelFormatDesc%2Cptr.cudaExtent%2Cptr.cuint%2CcudaArray_t" title="cudaArrayGetInfo(desc: ptr cudaChannelFormatDesc; extent: ptr cudaExtent;
                 flags: ptr cuint; array: cudaArray_t): cudaError_t">cudaArrayGetInfo(desc: ptr cudaChannelFormatDesc; extent: ptr cudaExtent;
                 flags: ptr cuint; array: cudaArray_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaBindSurfaceToArray
  <li><a class="reference" href="#cudaBindSurfaceToArray%2Cptr.surfaceReference%2CcudaArray_const_t%2Cptr.cudaChannelFormatDesc" title="cudaBindSurfaceToArray(surfref: ptr surfaceReference; array: cudaArray_const_t;
                       desc: ptr cudaChannelFormatDesc): cudaError_t">cudaBindSurfaceToArray(surfref: ptr surfaceReference; array: cudaArray_const_t;
                       desc: ptr cudaChannelFormatDesc): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaBindTexture
  <li><a class="reference" href="#cudaBindTexture%2Cptr.csize_t%2Cptr.textureReference%2Cpointer%2Cptr.cudaChannelFormatDesc%2Ccsize_t" title="cudaBindTexture(offset: ptr csize_t; texref: ptr textureReference;
                devPtr: pointer; desc: ptr cudaChannelFormatDesc; size: csize_t): cudaError_t">cudaBindTexture(offset: ptr csize_t; texref: ptr textureReference;
                devPtr: pointer; desc: ptr cudaChannelFormatDesc; size: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaBindTexture2D
  <li><a class="reference" href="#cudaBindTexture2D%2Cptr.csize_t%2Cptr.textureReference%2Cpointer%2Cptr.cudaChannelFormatDesc%2Ccsize_t%2Ccsize_t%2Ccsize_t" title="cudaBindTexture2D(offset: ptr csize_t; texref: ptr textureReference;
                  devPtr: pointer; desc: ptr cudaChannelFormatDesc;
                  width: csize_t; height: csize_t; pitch: csize_t): cudaError_t">cudaBindTexture2D(offset: ptr csize_t; texref: ptr textureReference;
                  devPtr: pointer; desc: ptr cudaChannelFormatDesc;
                  width: csize_t; height: csize_t; pitch: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaBindTextureToArray
  <li><a class="reference" href="#cudaBindTextureToArray%2Cptr.textureReference%2CcudaArray_const_t%2Cptr.cudaChannelFormatDesc" title="cudaBindTextureToArray(texref: ptr textureReference; array: cudaArray_const_t;
                       desc: ptr cudaChannelFormatDesc): cudaError_t">cudaBindTextureToArray(texref: ptr textureReference; array: cudaArray_const_t;
                       desc: ptr cudaChannelFormatDesc): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaBindTextureToMipmappedArray
  <li><a class="reference" href="#cudaBindTextureToMipmappedArray%2Cptr.textureReference%2CcudaMipmappedArray_const_t%2Cptr.cudaChannelFormatDesc" title="cudaBindTextureToMipmappedArray(texref: ptr textureReference;
                                mipmappedArray: cudaMipmappedArray_const_t;
                                desc: ptr cudaChannelFormatDesc): cudaError_t">cudaBindTextureToMipmappedArray(texref: ptr textureReference;
                                mipmappedArray: cudaMipmappedArray_const_t;
                                desc: ptr cudaChannelFormatDesc): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaChooseDevice
  <li><a class="reference" href="#cudaChooseDevice%2Cptr.cint%2Cptr.cudaDeviceProp" title="cudaChooseDevice(device: ptr cint; prop: ptr cudaDeviceProp): cudaError_t">cudaChooseDevice(device: ptr cint; prop: ptr cudaDeviceProp): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaConfigureCall
  <li><a class="reference" href="#cudaConfigureCall%2Cdim3%2Cdim3%2Ccsize_t%2CcudaStream_t" title="cudaConfigureCall(gridDim: dim3; blockDim: dim3; sharedMem: csize_t;
                  stream: cudaStream_t): cudaError_t">cudaConfigureCall(gridDim: dim3; blockDim: dim3; sharedMem: csize_t;
                  stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaCreateChannelDesc
  <li><a class="reference" href="#cudaCreateChannelDesc%2Ccint%2Ccint%2Ccint%2Ccint%2CcudaChannelFormatKind" title="cudaCreateChannelDesc(x: cint; y: cint; z: cint; w: cint;
                      f: cudaChannelFormatKind): cudaChannelFormatDesc">cudaCreateChannelDesc(x: cint; y: cint; z: cint; w: cint;
                      f: cudaChannelFormatKind): cudaChannelFormatDesc</a></li>

</ul>
<ul class="simple nested-toc-section">cudaCreateSurfaceObject
  <li><a class="reference" href="#cudaCreateSurfaceObject%2Cptr.cudaSurfaceObject_t%2Cptr.cudaResourceDesc" title="cudaCreateSurfaceObject(pSurfObject: ptr cudaSurfaceObject_t;
                        pResDesc: ptr cudaResourceDesc): cudaError_t">cudaCreateSurfaceObject(pSurfObject: ptr cudaSurfaceObject_t;
                        pResDesc: ptr cudaResourceDesc): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaCreateTextureObject
  <li><a class="reference" href="#cudaCreateTextureObject%2Cptr.cudaTextureObject_t%2Cptr.cudaResourceDesc%2Cptr.cudaTextureDesc%2Cptr.cudaResourceViewDesc" title="cudaCreateTextureObject(pTexObject: ptr cudaTextureObject_t;
                        pResDesc: ptr cudaResourceDesc;
                        pTexDesc: ptr cudaTextureDesc;
                        pResViewDesc: ptr cudaResourceViewDesc): cudaError_t">cudaCreateTextureObject(pTexObject: ptr cudaTextureObject_t;
                        pResDesc: ptr cudaResourceDesc;
                        pTexDesc: ptr cudaTextureDesc;
                        pResViewDesc: ptr cudaResourceViewDesc): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDestroySurfaceObject
  <li><a class="reference" href="#cudaDestroySurfaceObject%2CcudaSurfaceObject_t" title="cudaDestroySurfaceObject(surfObject: cudaSurfaceObject_t): cudaError_t">cudaDestroySurfaceObject(surfObject: cudaSurfaceObject_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDestroyTextureObject
  <li><a class="reference" href="#cudaDestroyTextureObject%2CcudaTextureObject_t" title="cudaDestroyTextureObject(texObject: cudaTextureObject_t): cudaError_t">cudaDestroyTextureObject(texObject: cudaTextureObject_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceCanAccessPeer
  <li><a class="reference" href="#cudaDeviceCanAccessPeer%2Cptr.cint%2Ccint%2Ccint" title="cudaDeviceCanAccessPeer(canAccessPeer: ptr cint; device: cint; peerDevice: cint): cudaError_t">cudaDeviceCanAccessPeer(canAccessPeer: ptr cint; device: cint; peerDevice: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceDisablePeerAccess
  <li><a class="reference" href="#cudaDeviceDisablePeerAccess%2Ccint" title="cudaDeviceDisablePeerAccess(peerDevice: cint): cudaError_t">cudaDeviceDisablePeerAccess(peerDevice: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceEnablePeerAccess
  <li><a class="reference" href="#cudaDeviceEnablePeerAccess%2Ccint%2Ccuint" title="cudaDeviceEnablePeerAccess(peerDevice: cint; flags: cuint): cudaError_t">cudaDeviceEnablePeerAccess(peerDevice: cint; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetAttribute
  <li><a class="reference" href="#cudaDeviceGetAttribute%2Cptr.cint%2CcudaDeviceAttr%2Ccint" title="cudaDeviceGetAttribute(value: ptr cint; attr: cudaDeviceAttr; device: cint): cudaError_t">cudaDeviceGetAttribute(value: ptr cint; attr: cudaDeviceAttr; device: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetByPCIBusId
  <li><a class="reference" href="#cudaDeviceGetByPCIBusId%2Cptr.cint%2Ccstring" title="cudaDeviceGetByPCIBusId(device: ptr cint; pciBusId: cstring): cudaError_t">cudaDeviceGetByPCIBusId(device: ptr cint; pciBusId: cstring): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetCacheConfig
  <li><a class="reference" href="#cudaDeviceGetCacheConfig%2Cptr.cudaFuncCache" title="cudaDeviceGetCacheConfig(pCacheConfig: ptr cudaFuncCache): cudaError_t">cudaDeviceGetCacheConfig(pCacheConfig: ptr cudaFuncCache): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetLimit
  <li><a class="reference" href="#cudaDeviceGetLimit%2Cptr.csize_t%2CcudaLimit" title="cudaDeviceGetLimit(pValue: ptr csize_t; limit: cudaLimit): cudaError_t">cudaDeviceGetLimit(pValue: ptr csize_t; limit: cudaLimit): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetP2PAttribute
  <li><a class="reference" href="#cudaDeviceGetP2PAttribute%2Cptr.cint%2CcudaDeviceP2PAttr%2Ccint%2Ccint" title="cudaDeviceGetP2PAttribute(value: ptr cint; attr: cudaDeviceP2PAttr;
                          srcDevice: cint; dstDevice: cint): cudaError_t">cudaDeviceGetP2PAttribute(value: ptr cint; attr: cudaDeviceP2PAttr;
                          srcDevice: cint; dstDevice: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetPCIBusId
  <li><a class="reference" href="#cudaDeviceGetPCIBusId%2Ccstring%2Ccint%2Ccint" title="cudaDeviceGetPCIBusId(pciBusId: cstring; len: cint; device: cint): cudaError_t">cudaDeviceGetPCIBusId(pciBusId: cstring; len: cint; device: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetSharedMemConfig
  <li><a class="reference" href="#cudaDeviceGetSharedMemConfig%2Cptr.cudaSharedMemConfig" title="cudaDeviceGetSharedMemConfig(pConfig: ptr cudaSharedMemConfig): cudaError_t">cudaDeviceGetSharedMemConfig(pConfig: ptr cudaSharedMemConfig): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceGetStreamPriorityRange
  <li><a class="reference" href="#cudaDeviceGetStreamPriorityRange%2Cptr.cint%2Cptr.cint" title="cudaDeviceGetStreamPriorityRange(leastPriority: ptr cint;
                                 greatestPriority: ptr cint): cudaError_t">cudaDeviceGetStreamPriorityRange(leastPriority: ptr cint;
                                 greatestPriority: ptr cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceReset
  <li><a class="reference" href="#cudaDeviceReset" title="cudaDeviceReset(): cudaError_t">cudaDeviceReset(): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceSetCacheConfig
  <li><a class="reference" href="#cudaDeviceSetCacheConfig%2CcudaFuncCache" title="cudaDeviceSetCacheConfig(cacheConfig: cudaFuncCache): cudaError_t">cudaDeviceSetCacheConfig(cacheConfig: cudaFuncCache): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceSetLimit
  <li><a class="reference" href="#cudaDeviceSetLimit%2CcudaLimit%2Ccsize_t" title="cudaDeviceSetLimit(limit: cudaLimit; value: csize_t): cudaError_t">cudaDeviceSetLimit(limit: cudaLimit; value: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceSetSharedMemConfig
  <li><a class="reference" href="#cudaDeviceSetSharedMemConfig%2CcudaSharedMemConfig" title="cudaDeviceSetSharedMemConfig(config: cudaSharedMemConfig): cudaError_t">cudaDeviceSetSharedMemConfig(config: cudaSharedMemConfig): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDeviceSynchronize
  <li><a class="reference" href="#cudaDeviceSynchronize" title="cudaDeviceSynchronize(): cudaError_t">cudaDeviceSynchronize(): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaDriverGetVersion
  <li><a class="reference" href="#cudaDriverGetVersion%2Cptr.cint" title="cudaDriverGetVersion(driverVersion: ptr cint): cudaError_t">cudaDriverGetVersion(driverVersion: ptr cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaEventCreate
  <li><a class="reference" href="#cudaEventCreate%2Cptr.cudaEvent_t" title="cudaEventCreate(event: ptr cudaEvent_t): cudaError_t">cudaEventCreate(event: ptr cudaEvent_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaEventCreateWithFlags
  <li><a class="reference" href="#cudaEventCreateWithFlags%2Cptr.cudaEvent_t%2Ccuint" title="cudaEventCreateWithFlags(event: ptr cudaEvent_t; flags: cuint): cudaError_t">cudaEventCreateWithFlags(event: ptr cudaEvent_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaEventDestroy
  <li><a class="reference" href="#cudaEventDestroy%2CcudaEvent_t" title="cudaEventDestroy(event: cudaEvent_t): cudaError_t">cudaEventDestroy(event: cudaEvent_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaEventElapsedTime
  <li><a class="reference" href="#cudaEventElapsedTime%2Cptr.cfloat%2CcudaEvent_t%2CcudaEvent_t" title="cudaEventElapsedTime(ms: ptr cfloat; start: cudaEvent_t; end: cudaEvent_t): cudaError_t">cudaEventElapsedTime(ms: ptr cfloat; start: cudaEvent_t; end: cudaEvent_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaEventQuery
  <li><a class="reference" href="#cudaEventQuery%2CcudaEvent_t" title="cudaEventQuery(event: cudaEvent_t): cudaError_t">cudaEventQuery(event: cudaEvent_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaEventRecord
  <li><a class="reference" href="#cudaEventRecord%2CcudaEvent_t%2CcudaStream_t" title="cudaEventRecord(event: cudaEvent_t; stream: cudaStream_t): cudaError_t">cudaEventRecord(event: cudaEvent_t; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaEventSynchronize
  <li><a class="reference" href="#cudaEventSynchronize%2CcudaEvent_t" title="cudaEventSynchronize(event: cudaEvent_t): cudaError_t">cudaEventSynchronize(event: cudaEvent_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaFree
  <li><a class="reference" href="#cudaFree%2Cpointer" title="cudaFree(devPtr: pointer): cudaError_t">cudaFree(devPtr: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaFreeArray
  <li><a class="reference" href="#cudaFreeArray%2CcudaArray_t" title="cudaFreeArray(array: cudaArray_t): cudaError_t">cudaFreeArray(array: cudaArray_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaFreeHost
  <li><a class="reference" href="#cudaFreeHost%2Cpointer" title="cudaFreeHost(ptr: pointer): cudaError_t">cudaFreeHost(ptr: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaFreeMipmappedArray
  <li><a class="reference" href="#cudaFreeMipmappedArray%2CcudaMipmappedArray_t" title="cudaFreeMipmappedArray(mipmappedArray: cudaMipmappedArray_t): cudaError_t">cudaFreeMipmappedArray(mipmappedArray: cudaMipmappedArray_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaFuncGetAttributes
  <li><a class="reference" href="#cudaFuncGetAttributes%2Cptr.cudaFuncAttributes%2Cpointer" title="cudaFuncGetAttributes(attr: ptr cudaFuncAttributes; func: pointer): cudaError_t">cudaFuncGetAttributes(attr: ptr cudaFuncAttributes; func: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaFuncSetCacheConfig
  <li><a class="reference" href="#cudaFuncSetCacheConfig%2Cpointer%2CcudaFuncCache" title="cudaFuncSetCacheConfig(func: pointer; cacheConfig: cudaFuncCache): cudaError_t">cudaFuncSetCacheConfig(func: pointer; cacheConfig: cudaFuncCache): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaFuncSetSharedMemConfig
  <li><a class="reference" href="#cudaFuncSetSharedMemConfig%2Cpointer%2CcudaSharedMemConfig" title="cudaFuncSetSharedMemConfig(func: pointer; config: cudaSharedMemConfig): cudaError_t">cudaFuncSetSharedMemConfig(func: pointer; config: cudaSharedMemConfig): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetChannelDesc
  <li><a class="reference" href="#cudaGetChannelDesc%2Cptr.cudaChannelFormatDesc%2CcudaArray_const_t" title="cudaGetChannelDesc(desc: ptr cudaChannelFormatDesc; array: cudaArray_const_t): cudaError_t">cudaGetChannelDesc(desc: ptr cudaChannelFormatDesc; array: cudaArray_const_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetDevice
  <li><a class="reference" href="#cudaGetDevice%2Cptr.cint" title="cudaGetDevice(device: ptr cint): cudaError_t">cudaGetDevice(device: ptr cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetDeviceCount
  <li><a class="reference" href="#cudaGetDeviceCount%2Cptr.cint" title="cudaGetDeviceCount(count: ptr cint): cudaError_t">cudaGetDeviceCount(count: ptr cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetDeviceFlags
  <li><a class="reference" href="#cudaGetDeviceFlags%2Cptr.cuint" title="cudaGetDeviceFlags(flags: ptr cuint): cudaError_t">cudaGetDeviceFlags(flags: ptr cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetDeviceProperties
  <li><a class="reference" href="#cudaGetDeviceProperties%2Cptr.cudaDeviceProp%2Ccint" title="cudaGetDeviceProperties(prop: ptr cudaDeviceProp; device: cint): cudaError_t">cudaGetDeviceProperties(prop: ptr cudaDeviceProp; device: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetErrorName
  <li><a class="reference" href="#cudaGetErrorName%2CcudaError" title="cudaGetErrorName(error: cudaError_t): cstring">cudaGetErrorName(error: cudaError_t): cstring</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetErrorString
  <li><a class="reference" href="#cudaGetErrorString%2CcudaError" title="cudaGetErrorString(error: cudaError_t): cstring">cudaGetErrorString(error: cudaError_t): cstring</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetExportTable
  <li><a class="reference" href="#cudaGetExportTable%2Cptr.pointer%2Cptr.cudaUUID_t" title="cudaGetExportTable(ppExportTable: ptr pointer; pExportTableId: ptr cudaUUID_t): cudaError_t">cudaGetExportTable(ppExportTable: ptr pointer; pExportTableId: ptr cudaUUID_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetLastError
  <li><a class="reference" href="#cudaGetLastError" title="cudaGetLastError(): cudaError_t">cudaGetLastError(): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetMipmappedArrayLevel
  <li><a class="reference" href="#cudaGetMipmappedArrayLevel%2Cptr.cudaArray_t%2CcudaMipmappedArray_const_t%2Ccuint" title="cudaGetMipmappedArrayLevel(levelArray: ptr cudaArray_t;
                           mipmappedArray: cudaMipmappedArray_const_t;
                           level: cuint): cudaError_t">cudaGetMipmappedArrayLevel(levelArray: ptr cudaArray_t;
                           mipmappedArray: cudaMipmappedArray_const_t;
                           level: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetSurfaceObjectResourceDesc
  <li><a class="reference" href="#cudaGetSurfaceObjectResourceDesc%2Cptr.cudaResourceDesc%2CcudaSurfaceObject_t" title="cudaGetSurfaceObjectResourceDesc(pResDesc: ptr cudaResourceDesc;
                                 surfObject: cudaSurfaceObject_t): cudaError_t">cudaGetSurfaceObjectResourceDesc(pResDesc: ptr cudaResourceDesc;
                                 surfObject: cudaSurfaceObject_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetSurfaceReference
  <li><a class="reference" href="#cudaGetSurfaceReference%2Cptr.ptr.surfaceReference%2Cpointer" title="cudaGetSurfaceReference(surfref: ptr ptr surfaceReference; symbol: pointer): cudaError_t">cudaGetSurfaceReference(surfref: ptr ptr surfaceReference; symbol: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetSymbolAddress
  <li><a class="reference" href="#cudaGetSymbolAddress%2Cptr.pointer%2Cpointer" title="cudaGetSymbolAddress(devPtr: ptr pointer; symbol: pointer): cudaError_t">cudaGetSymbolAddress(devPtr: ptr pointer; symbol: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetSymbolSize
  <li><a class="reference" href="#cudaGetSymbolSize%2Cptr.csize_t%2Cpointer" title="cudaGetSymbolSize(size: ptr csize_t; symbol: pointer): cudaError_t">cudaGetSymbolSize(size: ptr csize_t; symbol: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetTextureAlignmentOffset
  <li><a class="reference" href="#cudaGetTextureAlignmentOffset%2Cptr.csize_t%2Cptr.textureReference" title="cudaGetTextureAlignmentOffset(offset: ptr csize_t; texref: ptr textureReference): cudaError_t">cudaGetTextureAlignmentOffset(offset: ptr csize_t; texref: ptr textureReference): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetTextureObjectResourceDesc
  <li><a class="reference" href="#cudaGetTextureObjectResourceDesc%2Cptr.cudaResourceDesc%2CcudaTextureObject_t" title="cudaGetTextureObjectResourceDesc(pResDesc: ptr cudaResourceDesc;
                                 texObject: cudaTextureObject_t): cudaError_t">cudaGetTextureObjectResourceDesc(pResDesc: ptr cudaResourceDesc;
                                 texObject: cudaTextureObject_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetTextureObjectResourceViewDesc
  <li><a class="reference" href="#cudaGetTextureObjectResourceViewDesc%2Cptr.cudaResourceViewDesc%2CcudaTextureObject_t" title="cudaGetTextureObjectResourceViewDesc(pResViewDesc: ptr cudaResourceViewDesc;
                                     texObject: cudaTextureObject_t): cudaError_t">cudaGetTextureObjectResourceViewDesc(pResViewDesc: ptr cudaResourceViewDesc;
                                     texObject: cudaTextureObject_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetTextureObjectTextureDesc
  <li><a class="reference" href="#cudaGetTextureObjectTextureDesc%2Cptr.cudaTextureDesc%2CcudaTextureObject_t" title="cudaGetTextureObjectTextureDesc(pTexDesc: ptr cudaTextureDesc;
                                texObject: cudaTextureObject_t): cudaError_t">cudaGetTextureObjectTextureDesc(pTexDesc: ptr cudaTextureDesc;
                                texObject: cudaTextureObject_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGetTextureReference
  <li><a class="reference" href="#cudaGetTextureReference%2Cptr.ptr.textureReference%2Cpointer" title="cudaGetTextureReference(texref: ptr ptr textureReference; symbol: pointer): cudaError_t">cudaGetTextureReference(texref: ptr ptr textureReference; symbol: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGraphicsMapResources
  <li><a class="reference" href="#cudaGraphicsMapResources%2Ccint%2Cptr.cudaGraphicsResource_t%2CcudaStream_t" title="cudaGraphicsMapResources(count: cint; resources: ptr cudaGraphicsResource_t;
                         stream: cudaStream_t): cudaError_t">cudaGraphicsMapResources(count: cint; resources: ptr cudaGraphicsResource_t;
                         stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGraphicsResourceGetMappedMipmappedArray
  <li><a class="reference" href="#cudaGraphicsResourceGetMappedMipmappedArray%2Cptr.cudaMipmappedArray_t%2CcudaGraphicsResource_t" title="cudaGraphicsResourceGetMappedMipmappedArray(
    mipmappedArray: ptr cudaMipmappedArray_t; resource: cudaGraphicsResource_t): cudaError_t">cudaGraphicsResourceGetMappedMipmappedArray(
    mipmappedArray: ptr cudaMipmappedArray_t; resource: cudaGraphicsResource_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGraphicsResourceGetMappedPointer
  <li><a class="reference" href="#cudaGraphicsResourceGetMappedPointer%2Cptr.pointer%2Cptr.csize_t%2CcudaGraphicsResource_t" title="cudaGraphicsResourceGetMappedPointer(devPtr: ptr pointer; size: ptr csize_t;
                                     resource: cudaGraphicsResource_t): cudaError_t">cudaGraphicsResourceGetMappedPointer(devPtr: ptr pointer; size: ptr csize_t;
                                     resource: cudaGraphicsResource_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGraphicsResourceSetMapFlags
  <li><a class="reference" href="#cudaGraphicsResourceSetMapFlags%2CcudaGraphicsResource_t%2Ccuint" title="cudaGraphicsResourceSetMapFlags(resource: cudaGraphicsResource_t; flags: cuint): cudaError_t">cudaGraphicsResourceSetMapFlags(resource: cudaGraphicsResource_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGraphicsSubResourceGetMappedArray
  <li><a class="reference" href="#cudaGraphicsSubResourceGetMappedArray%2Cptr.cudaArray_t%2CcudaGraphicsResource_t%2Ccuint%2Ccuint" title="cudaGraphicsSubResourceGetMappedArray(array: ptr cudaArray_t;
                                      resource: cudaGraphicsResource_t;
                                      arrayIndex: cuint; mipLevel: cuint): cudaError_t">cudaGraphicsSubResourceGetMappedArray(array: ptr cudaArray_t;
                                      resource: cudaGraphicsResource_t;
                                      arrayIndex: cuint; mipLevel: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGraphicsUnmapResources
  <li><a class="reference" href="#cudaGraphicsUnmapResources%2Ccint%2Cptr.cudaGraphicsResource_t%2CcudaStream_t" title="cudaGraphicsUnmapResources(count: cint; resources: ptr cudaGraphicsResource_t;
                           stream: cudaStream_t): cudaError_t">cudaGraphicsUnmapResources(count: cint; resources: ptr cudaGraphicsResource_t;
                           stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaGraphicsUnregisterResource
  <li><a class="reference" href="#cudaGraphicsUnregisterResource%2CcudaGraphicsResource_t" title="cudaGraphicsUnregisterResource(resource: cudaGraphicsResource_t): cudaError_t">cudaGraphicsUnregisterResource(resource: cudaGraphicsResource_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaHostAlloc
  <li><a class="reference" href="#cudaHostAlloc%2Cptr.pointer%2Ccsize_t%2Ccuint" title="cudaHostAlloc(pHost: ptr pointer; size: csize_t; flags: cuint): cudaError_t">cudaHostAlloc(pHost: ptr pointer; size: csize_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaHostGetDevicePointer
  <li><a class="reference" href="#cudaHostGetDevicePointer%2Cptr.pointer%2Cpointer%2Ccuint" title="cudaHostGetDevicePointer(pDevice: ptr pointer; pHost: pointer; flags: cuint): cudaError_t">cudaHostGetDevicePointer(pDevice: ptr pointer; pHost: pointer; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaHostGetFlags
  <li><a class="reference" href="#cudaHostGetFlags%2Cptr.cuint%2Cpointer" title="cudaHostGetFlags(pFlags: ptr cuint; pHost: pointer): cudaError_t">cudaHostGetFlags(pFlags: ptr cuint; pHost: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaHostRegister
  <li><a class="reference" href="#cudaHostRegister%2Cpointer%2Ccsize_t%2Ccuint" title="cudaHostRegister(ptr: pointer; size: csize_t; flags: cuint): cudaError_t">cudaHostRegister(ptr: pointer; size: csize_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaHostUnregister
  <li><a class="reference" href="#cudaHostUnregister%2Cpointer" title="cudaHostUnregister(ptr: pointer): cudaError_t">cudaHostUnregister(ptr: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaIpcCloseMemHandle
  <li><a class="reference" href="#cudaIpcCloseMemHandle%2Cpointer" title="cudaIpcCloseMemHandle(devPtr: pointer): cudaError_t">cudaIpcCloseMemHandle(devPtr: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaIpcGetEventHandle
  <li><a class="reference" href="#cudaIpcGetEventHandle%2Cptr.cudaIpcEventHandle_t%2CcudaEvent_t" title="cudaIpcGetEventHandle(handle: ptr cudaIpcEventHandle_t; event: cudaEvent_t): cudaError_t">cudaIpcGetEventHandle(handle: ptr cudaIpcEventHandle_t; event: cudaEvent_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaIpcGetMemHandle
  <li><a class="reference" href="#cudaIpcGetMemHandle%2Cptr.cudaIpcMemHandle_t%2Cpointer" title="cudaIpcGetMemHandle(handle: ptr cudaIpcMemHandle_t; devPtr: pointer): cudaError_t">cudaIpcGetMemHandle(handle: ptr cudaIpcMemHandle_t; devPtr: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaIpcOpenEventHandle
  <li><a class="reference" href="#cudaIpcOpenEventHandle%2Cptr.cudaEvent_t%2CcudaIpcEventHandle_t" title="cudaIpcOpenEventHandle(event: ptr cudaEvent_t; handle: cudaIpcEventHandle_t): cudaError_t">cudaIpcOpenEventHandle(event: ptr cudaEvent_t; handle: cudaIpcEventHandle_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaIpcOpenMemHandle
  <li><a class="reference" href="#cudaIpcOpenMemHandle%2Cptr.pointer%2CcudaIpcMemHandle_t%2Ccuint" title="cudaIpcOpenMemHandle(devPtr: ptr pointer; handle: cudaIpcMemHandle_t;
                     flags: cuint): cudaError_t">cudaIpcOpenMemHandle(devPtr: ptr pointer; handle: cudaIpcMemHandle_t;
                     flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaLaunch
  <li><a class="reference" href="#cudaLaunch%2Cpointer" title="cudaLaunch(func: pointer): cudaError_t">cudaLaunch(func: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaLaunchKernel
  <li><a class="reference" href="#cudaLaunchKernel%2Cpointer%2Cdim3%2Cdim3%2Cptr.pointer%2Ccsize_t%2CcudaStream_t" title="cudaLaunchKernel(func: pointer; gridDim: dim3; blockDim: dim3;
                 args: ptr pointer; sharedMem: csize_t; stream: cudaStream_t): cudaError_t">cudaLaunchKernel(func: pointer; gridDim: dim3; blockDim: dim3;
                 args: ptr pointer; sharedMem: csize_t; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMalloc
  <li><a class="reference" href="#cudaMalloc%2Cptr.pointer%2Ccsize_t" title="cudaMalloc(devPtr: ptr pointer; size: csize_t): cudaError_t">cudaMalloc(devPtr: ptr pointer; size: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMalloc3D
  <li><a class="reference" href="#cudaMalloc3D%2Cptr.cudaPitchedPtr%2CcudaExtent" title="cudaMalloc3D(pitchedDevPtr: ptr cudaPitchedPtr; extent: cudaExtent): cudaError_t">cudaMalloc3D(pitchedDevPtr: ptr cudaPitchedPtr; extent: cudaExtent): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMalloc3DArray
  <li><a class="reference" href="#cudaMalloc3DArray%2Cptr.cudaArray_t%2Cptr.cudaChannelFormatDesc%2CcudaExtent%2Ccuint" title="cudaMalloc3DArray(array: ptr cudaArray_t; desc: ptr cudaChannelFormatDesc;
                  extent: cudaExtent; flags: cuint): cudaError_t">cudaMalloc3DArray(array: ptr cudaArray_t; desc: ptr cudaChannelFormatDesc;
                  extent: cudaExtent; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMallocArray
  <li><a class="reference" href="#cudaMallocArray%2Cptr.cudaArray_t%2Cptr.cudaChannelFormatDesc%2Ccsize_t%2Ccsize_t%2Ccuint" title="cudaMallocArray(array: ptr cudaArray_t; desc: ptr cudaChannelFormatDesc;
                width: csize_t; height: csize_t; flags: cuint): cudaError_t">cudaMallocArray(array: ptr cudaArray_t; desc: ptr cudaChannelFormatDesc;
                width: csize_t; height: csize_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMallocHost
  <li><a class="reference" href="#cudaMallocHost%2Cptr.pointer%2Ccsize_t" title="cudaMallocHost(ptr: ptr pointer; size: csize_t): cudaError_t">cudaMallocHost(ptr: ptr pointer; size: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMallocManaged
  <li><a class="reference" href="#cudaMallocManaged%2Cptr.pointer%2Ccsize_t%2Ccuint" title="cudaMallocManaged(devPtr: ptr pointer; size: csize_t; flags: cuint): cudaError_t">cudaMallocManaged(devPtr: ptr pointer; size: csize_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMallocMipmappedArray
  <li><a class="reference" href="#cudaMallocMipmappedArray%2Cptr.cudaMipmappedArray_t%2Cptr.cudaChannelFormatDesc%2CcudaExtent%2Ccuint%2Ccuint" title="cudaMallocMipmappedArray(mipmappedArray: ptr cudaMipmappedArray_t;
                         desc: ptr cudaChannelFormatDesc; extent: cudaExtent;
                         numLevels: cuint; flags: cuint): cudaError_t">cudaMallocMipmappedArray(mipmappedArray: ptr cudaMipmappedArray_t;
                         desc: ptr cudaChannelFormatDesc; extent: cudaExtent;
                         numLevels: cuint; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMallocPitch
  <li><a class="reference" href="#cudaMallocPitch%2Cptr.pointer%2Cptr.csize_t%2Ccsize_t%2Ccsize_t" title="cudaMallocPitch(devPtr: ptr pointer; pitch: ptr csize_t; width: csize_t;
                height: csize_t): cudaError_t">cudaMallocPitch(devPtr: ptr pointer; pitch: ptr csize_t; width: csize_t;
                height: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemAdvise
  <li><a class="reference" href="#cudaMemAdvise%2Cpointer%2Ccsize_t%2CcudaMemoryAdvise%2Ccint" title="cudaMemAdvise(devPtr: pointer; count: csize_t; advice: cudaMemoryAdvise;
              device: cint): cudaError_t">cudaMemAdvise(devPtr: pointer; count: csize_t; advice: cudaMemoryAdvise;
              device: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy
  <li><a class="reference" href="#cudaMemcpy%2Cpointer%2Cpointer%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpy(dst: pointer; src: pointer; count: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpy(dst: pointer; src: pointer; count: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy2D
  <li><a class="reference" href="#cudaMemcpy2D%2Cpointer%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpy2D(dst: pointer; dpitch: csize_t; src: pointer; spitch: csize_t;
             width: csize_t; height: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpy2D(dst: pointer; dpitch: csize_t; src: pointer; spitch: csize_t;
             width: csize_t; height: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy2DArrayToArray
  <li><a class="reference" href="#cudaMemcpy2DArrayToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpy2DArrayToArray(dst: cudaArray_t; wOffsetDst: csize_t;
                         hOffsetDst: csize_t; src: cudaArray_const_t;
                         wOffsetSrc: csize_t; hOffsetSrc: csize_t;
                         width: csize_t; height: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpy2DArrayToArray(dst: cudaArray_t; wOffsetDst: csize_t;
                         hOffsetDst: csize_t; src: cudaArray_const_t;
                         wOffsetSrc: csize_t; hOffsetSrc: csize_t;
                         width: csize_t; height: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy2DAsync
  <li><a class="reference" href="#cudaMemcpy2DAsync%2Cpointer%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpy2DAsync(dst: pointer; dpitch: csize_t; src: pointer; spitch: csize_t;
                  width: csize_t; height: csize_t; kind: cudaMemcpyKind;
                  stream: cudaStream_t): cudaError_t">cudaMemcpy2DAsync(dst: pointer; dpitch: csize_t; src: pointer; spitch: csize_t;
                  width: csize_t; height: csize_t; kind: cudaMemcpyKind;
                  stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy2DFromArray
  <li><a class="reference" href="#cudaMemcpy2DFromArray%2Cpointer%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpy2DFromArray(dst: pointer; dpitch: csize_t; src: cudaArray_const_t;
                      wOffset: csize_t; hOffset: csize_t; width: csize_t;
                      height: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpy2DFromArray(dst: pointer; dpitch: csize_t; src: cudaArray_const_t;
                      wOffset: csize_t; hOffset: csize_t; width: csize_t;
                      height: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy2DFromArrayAsync
  <li><a class="reference" href="#cudaMemcpy2DFromArrayAsync%2Cpointer%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpy2DFromArrayAsync(dst: pointer; dpitch: csize_t;
                           src: cudaArray_const_t; wOffset: csize_t;
                           hOffset: csize_t; width: csize_t; height: csize_t;
                           kind: cudaMemcpyKind; stream: cudaStream_t): cudaError_t">cudaMemcpy2DFromArrayAsync(dst: pointer; dpitch: csize_t;
                           src: cudaArray_const_t; wOffset: csize_t;
                           hOffset: csize_t; width: csize_t; height: csize_t;
                           kind: cudaMemcpyKind; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy2DToArray
  <li><a class="reference" href="#cudaMemcpy2DToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpy2DToArray(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                    src: pointer; spitch: csize_t; width: csize_t;
                    height: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpy2DToArray(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                    src: pointer; spitch: csize_t; width: csize_t;
                    height: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy2DToArrayAsync
  <li><a class="reference" href="#cudaMemcpy2DToArrayAsync%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpy2DToArrayAsync(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                         src: pointer; spitch: csize_t; width: csize_t;
                         height: csize_t; kind: cudaMemcpyKind;
                         stream: cudaStream_t): cudaError_t">cudaMemcpy2DToArrayAsync(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                         src: pointer; spitch: csize_t; width: csize_t;
                         height: csize_t; kind: cudaMemcpyKind;
                         stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy3D
  <li><a class="reference" href="#cudaMemcpy3D%2Cptr.cudaMemcpy3DParms" title="cudaMemcpy3D(p: ptr cudaMemcpy3DParms): cudaError_t">cudaMemcpy3D(p: ptr cudaMemcpy3DParms): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy3DAsync
  <li><a class="reference" href="#cudaMemcpy3DAsync%2Cptr.cudaMemcpy3DParms%2CcudaStream_t" title="cudaMemcpy3DAsync(p: ptr cudaMemcpy3DParms; stream: cudaStream_t): cudaError_t">cudaMemcpy3DAsync(p: ptr cudaMemcpy3DParms; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy3DPeer
  <li><a class="reference" href="#cudaMemcpy3DPeer%2Cptr.cudaMemcpy3DPeerParms" title="cudaMemcpy3DPeer(p: ptr cudaMemcpy3DPeerParms): cudaError_t">cudaMemcpy3DPeer(p: ptr cudaMemcpy3DPeerParms): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpy3DPeerAsync
  <li><a class="reference" href="#cudaMemcpy3DPeerAsync%2Cptr.cudaMemcpy3DPeerParms%2CcudaStream_t" title="cudaMemcpy3DPeerAsync(p: ptr cudaMemcpy3DPeerParms; stream: cudaStream_t): cudaError_t">cudaMemcpy3DPeerAsync(p: ptr cudaMemcpy3DPeerParms; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyArrayToArray
  <li><a class="reference" href="#cudaMemcpyArrayToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpyArrayToArray(dst: cudaArray_t; wOffsetDst: csize_t;
                       hOffsetDst: csize_t; src: cudaArray_const_t;
                       wOffsetSrc: csize_t; hOffsetSrc: csize_t; count: csize_t;
                       kind: cudaMemcpyKind): cudaError_t">cudaMemcpyArrayToArray(dst: cudaArray_t; wOffsetDst: csize_t;
                       hOffsetDst: csize_t; src: cudaArray_const_t;
                       wOffsetSrc: csize_t; hOffsetSrc: csize_t; count: csize_t;
                       kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyAsync
  <li><a class="reference" href="#cudaMemcpyAsync%2Cpointer%2Cpointer%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpyAsync(dst: pointer; src: pointer; count: csize_t;
                kind: cudaMemcpyKind; stream: cudaStream_t): cudaError_t">cudaMemcpyAsync(dst: pointer; src: pointer; count: csize_t;
                kind: cudaMemcpyKind; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyFromArray
  <li><a class="reference" href="#cudaMemcpyFromArray%2Cpointer%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpyFromArray(dst: pointer; src: cudaArray_const_t; wOffset: csize_t;
                    hOffset: csize_t; count: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpyFromArray(dst: pointer; src: cudaArray_const_t; wOffset: csize_t;
                    hOffset: csize_t; count: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyFromArrayAsync
  <li><a class="reference" href="#cudaMemcpyFromArrayAsync%2Cpointer%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpyFromArrayAsync(dst: pointer; src: cudaArray_const_t; wOffset: csize_t;
                         hOffset: csize_t; count: csize_t; kind: cudaMemcpyKind;
                         stream: cudaStream_t): cudaError_t">cudaMemcpyFromArrayAsync(dst: pointer; src: cudaArray_const_t; wOffset: csize_t;
                         hOffset: csize_t; count: csize_t; kind: cudaMemcpyKind;
                         stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyFromSymbol
  <li><a class="reference" href="#cudaMemcpyFromSymbol%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpyFromSymbol(dst: pointer; symbol: pointer; count: csize_t;
                     offset: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpyFromSymbol(dst: pointer; symbol: pointer; count: csize_t;
                     offset: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyFromSymbolAsync
  <li><a class="reference" href="#cudaMemcpyFromSymbolAsync%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpyFromSymbolAsync(dst: pointer; symbol: pointer; count: csize_t;
                          offset: csize_t; kind: cudaMemcpyKind;
                          stream: cudaStream_t): cudaError_t">cudaMemcpyFromSymbolAsync(dst: pointer; symbol: pointer; count: csize_t;
                          offset: csize_t; kind: cudaMemcpyKind;
                          stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyPeer
  <li><a class="reference" href="#cudaMemcpyPeer%2Cpointer%2Ccint%2Cpointer%2Ccint%2Ccsize_t" title="cudaMemcpyPeer(dst: pointer; dstDevice: cint; src: pointer; srcDevice: cint;
               count: csize_t): cudaError_t">cudaMemcpyPeer(dst: pointer; dstDevice: cint; src: pointer; srcDevice: cint;
               count: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyPeerAsync
  <li><a class="reference" href="#cudaMemcpyPeerAsync%2Cpointer%2Ccint%2Cpointer%2Ccint%2Ccsize_t%2CcudaStream_t" title="cudaMemcpyPeerAsync(dst: pointer; dstDevice: cint; src: pointer;
                    srcDevice: cint; count: csize_t; stream: cudaStream_t): cudaError_t">cudaMemcpyPeerAsync(dst: pointer; dstDevice: cint; src: pointer;
                    srcDevice: cint; count: csize_t; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyToArray
  <li><a class="reference" href="#cudaMemcpyToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpyToArray(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                  src: pointer; count: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpyToArray(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                  src: pointer; count: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyToArrayAsync
  <li><a class="reference" href="#cudaMemcpyToArrayAsync%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpyToArrayAsync(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                       src: pointer; count: csize_t; kind: cudaMemcpyKind;
                       stream: cudaStream_t): cudaError_t">cudaMemcpyToArrayAsync(dst: cudaArray_t; wOffset: csize_t; hOffset: csize_t;
                       src: pointer; count: csize_t; kind: cudaMemcpyKind;
                       stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyToSymbol
  <li><a class="reference" href="#cudaMemcpyToSymbol%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind" title="cudaMemcpyToSymbol(symbol: pointer; src: pointer; count: csize_t;
                   offset: csize_t; kind: cudaMemcpyKind): cudaError_t">cudaMemcpyToSymbol(symbol: pointer; src: pointer; count: csize_t;
                   offset: csize_t; kind: cudaMemcpyKind): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemcpyToSymbolAsync
  <li><a class="reference" href="#cudaMemcpyToSymbolAsync%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t" title="cudaMemcpyToSymbolAsync(symbol: pointer; src: pointer; count: csize_t;
                        offset: csize_t; kind: cudaMemcpyKind;
                        stream: cudaStream_t): cudaError_t">cudaMemcpyToSymbolAsync(symbol: pointer; src: pointer; count: csize_t;
                        offset: csize_t; kind: cudaMemcpyKind;
                        stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemGetInfo
  <li><a class="reference" href="#cudaMemGetInfo%2Cptr.csize_t%2Cptr.csize_t" title="cudaMemGetInfo(free: ptr csize_t; total: ptr csize_t): cudaError_t">cudaMemGetInfo(free: ptr csize_t; total: ptr csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemPrefetchAsync
  <li><a class="reference" href="#cudaMemPrefetchAsync%2Cpointer%2Ccsize_t%2Ccint%2CcudaStream_t" title="cudaMemPrefetchAsync(devPtr: pointer; count: csize_t; dstDevice: cint;
                     stream: cudaStream_t): cudaError_t">cudaMemPrefetchAsync(devPtr: pointer; count: csize_t; dstDevice: cint;
                     stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemRangeGetAttribute
  <li><a class="reference" href="#cudaMemRangeGetAttribute%2Cpointer%2Ccsize_t%2CcudaMemRangeAttribute%2Cpointer%2Ccsize_t" title="cudaMemRangeGetAttribute(data: pointer; dataSize: csize_t;
                         attribute: cudaMemRangeAttribute; devPtr: pointer;
                         count: csize_t): cudaError_t">cudaMemRangeGetAttribute(data: pointer; dataSize: csize_t;
                         attribute: cudaMemRangeAttribute; devPtr: pointer;
                         count: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemRangeGetAttributes
  <li><a class="reference" href="#cudaMemRangeGetAttributes%2Cptr.pointer%2Cptr.csize_t%2Cptr.cudaMemRangeAttribute%2Ccsize_t%2Cpointer%2Ccsize_t" title="cudaMemRangeGetAttributes(data: ptr pointer; dataSizes: ptr csize_t;
                          attributes: ptr cudaMemRangeAttribute;
                          numAttributes: csize_t; devPtr: pointer;
                          count: csize_t): cudaError_t">cudaMemRangeGetAttributes(data: ptr pointer; dataSizes: ptr csize_t;
                          attributes: ptr cudaMemRangeAttribute;
                          numAttributes: csize_t; devPtr: pointer;
                          count: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemset
  <li><a class="reference" href="#cudaMemset%2Cpointer%2Ccint%2Ccsize_t" title="cudaMemset(devPtr: pointer; value: cint; count: csize_t): cudaError_t">cudaMemset(devPtr: pointer; value: cint; count: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemset2D
  <li><a class="reference" href="#cudaMemset2D%2Cpointer%2Ccsize_t%2Ccint%2Ccsize_t%2Ccsize_t" title="cudaMemset2D(devPtr: pointer; pitch: csize_t; value: cint; width: csize_t;
             height: csize_t): cudaError_t">cudaMemset2D(devPtr: pointer; pitch: csize_t; value: cint; width: csize_t;
             height: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemset2DAsync
  <li><a class="reference" href="#cudaMemset2DAsync%2Cpointer%2Ccsize_t%2Ccint%2Ccsize_t%2Ccsize_t%2CcudaStream_t" title="cudaMemset2DAsync(devPtr: pointer; pitch: csize_t; value: cint; width: csize_t;
                  height: csize_t; stream: cudaStream_t): cudaError_t">cudaMemset2DAsync(devPtr: pointer; pitch: csize_t; value: cint; width: csize_t;
                  height: csize_t; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemset3D
  <li><a class="reference" href="#cudaMemset3D%2CcudaPitchedPtr%2Ccint%2CcudaExtent" title="cudaMemset3D(pitchedDevPtr: cudaPitchedPtr; value: cint; extent: cudaExtent): cudaError_t">cudaMemset3D(pitchedDevPtr: cudaPitchedPtr; value: cint; extent: cudaExtent): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemset3DAsync
  <li><a class="reference" href="#cudaMemset3DAsync%2CcudaPitchedPtr%2Ccint%2CcudaExtent%2CcudaStream_t" title="cudaMemset3DAsync(pitchedDevPtr: cudaPitchedPtr; value: cint;
                  extent: cudaExtent; stream: cudaStream_t): cudaError_t">cudaMemset3DAsync(pitchedDevPtr: cudaPitchedPtr; value: cint;
                  extent: cudaExtent; stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaMemsetAsync
  <li><a class="reference" href="#cudaMemsetAsync%2Cpointer%2Ccint%2Ccsize_t%2CcudaStream_t" title="cudaMemsetAsync(devPtr: pointer; value: cint; count: csize_t;
                stream: cudaStream_t): cudaError_t">cudaMemsetAsync(devPtr: pointer; value: cint; count: csize_t;
                stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaOccupancyMaxActiveBlocksPerMultiprocessor
  <li><a class="reference" href="#cudaOccupancyMaxActiveBlocksPerMultiprocessor%2Cptr.cint%2Cpointer%2Ccint%2Ccsize_t" title="cudaOccupancyMaxActiveBlocksPerMultiprocessor(numBlocks: ptr cint;
    func: pointer; blockSize: cint; dynamicSMemSize: csize_t): cudaError_t">cudaOccupancyMaxActiveBlocksPerMultiprocessor(numBlocks: ptr cint;
    func: pointer; blockSize: cint; dynamicSMemSize: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
  <li><a class="reference" href="#cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags%2Cptr.cint%2Cpointer%2Ccint%2Ccsize_t%2Ccuint" title="cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks: ptr cint;
    func: pointer; blockSize: cint; dynamicSMemSize: csize_t; flags: cuint): cudaError_t">cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks: ptr cint;
    func: pointer; blockSize: cint; dynamicSMemSize: csize_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaPeekAtLastError
  <li><a class="reference" href="#cudaPeekAtLastError" title="cudaPeekAtLastError(): cudaError_t">cudaPeekAtLastError(): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaPointerGetAttributes
  <li><a class="reference" href="#cudaPointerGetAttributes%2Cptr.cudaPointerAttributes%2Cpointer" title="cudaPointerGetAttributes(attributes: ptr cudaPointerAttributes; ptr: pointer): cudaError_t">cudaPointerGetAttributes(attributes: ptr cudaPointerAttributes; ptr: pointer): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaRuntimeGetVersion
  <li><a class="reference" href="#cudaRuntimeGetVersion%2Cptr.cint" title="cudaRuntimeGetVersion(runtimeVersion: ptr cint): cudaError_t">cudaRuntimeGetVersion(runtimeVersion: ptr cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaSetDevice
  <li><a class="reference" href="#cudaSetDevice%2Ccint" title="cudaSetDevice(device: cint): cudaError_t">cudaSetDevice(device: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaSetDeviceFlags
  <li><a class="reference" href="#cudaSetDeviceFlags%2Ccuint" title="cudaSetDeviceFlags(flags: cuint): cudaError_t">cudaSetDeviceFlags(flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaSetDoubleForDevice
  <li><a class="reference" href="#cudaSetDoubleForDevice%2Cptr.cdouble" title="cudaSetDoubleForDevice(d: ptr cdouble): cudaError_t">cudaSetDoubleForDevice(d: ptr cdouble): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaSetDoubleForHost
  <li><a class="reference" href="#cudaSetDoubleForHost%2Cptr.cdouble" title="cudaSetDoubleForHost(d: ptr cdouble): cudaError_t">cudaSetDoubleForHost(d: ptr cdouble): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaSetupArgument
  <li><a class="reference" href="#cudaSetupArgument%2Cpointer%2Ccsize_t%2Ccsize_t" title="cudaSetupArgument(arg: pointer; size: csize_t; offset: csize_t): cudaError_t">cudaSetupArgument(arg: pointer; size: csize_t; offset: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaSetValidDevices
  <li><a class="reference" href="#cudaSetValidDevices%2Cptr.cint%2Ccint" title="cudaSetValidDevices(device_arr: ptr cint; len: cint): cudaError_t">cudaSetValidDevices(device_arr: ptr cint; len: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamAddCallback
  <li><a class="reference" href="#cudaStreamAddCallback%2CcudaStream_t%2CcudaStreamCallback_t%2Cpointer%2Ccuint" title="cudaStreamAddCallback(stream: cudaStream_t; callback: cudaStreamCallback_t;
                      userData: pointer; flags: cuint): cudaError_t">cudaStreamAddCallback(stream: cudaStream_t; callback: cudaStreamCallback_t;
                      userData: pointer; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamAttachMemAsync
  <li><a class="reference" href="#cudaStreamAttachMemAsync%2CcudaStream_t%2Cpointer%2Ccsize_t%2Ccuint" title="cudaStreamAttachMemAsync(stream: cudaStream_t; devPtr: pointer; length: csize_t;
                         flags: cuint): cudaError_t">cudaStreamAttachMemAsync(stream: cudaStream_t; devPtr: pointer; length: csize_t;
                         flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamCreate
  <li><a class="reference" href="#cudaStreamCreate%2Cptr.cudaStream_t" title="cudaStreamCreate(pStream: ptr cudaStream_t): cudaError_t">cudaStreamCreate(pStream: ptr cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamCreateWithFlags
  <li><a class="reference" href="#cudaStreamCreateWithFlags%2Cptr.cudaStream_t%2Ccuint" title="cudaStreamCreateWithFlags(pStream: ptr cudaStream_t; flags: cuint): cudaError_t">cudaStreamCreateWithFlags(pStream: ptr cudaStream_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamCreateWithPriority
  <li><a class="reference" href="#cudaStreamCreateWithPriority%2Cptr.cudaStream_t%2Ccuint%2Ccint" title="cudaStreamCreateWithPriority(pStream: ptr cudaStream_t; flags: cuint;
                             priority: cint): cudaError_t">cudaStreamCreateWithPriority(pStream: ptr cudaStream_t; flags: cuint;
                             priority: cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamDestroy
  <li><a class="reference" href="#cudaStreamDestroy%2CcudaStream_t" title="cudaStreamDestroy(stream: cudaStream_t): cudaError_t">cudaStreamDestroy(stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamGetFlags
  <li><a class="reference" href="#cudaStreamGetFlags%2CcudaStream_t%2Cptr.cuint" title="cudaStreamGetFlags(hStream: cudaStream_t; flags: ptr cuint): cudaError_t">cudaStreamGetFlags(hStream: cudaStream_t; flags: ptr cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamGetPriority
  <li><a class="reference" href="#cudaStreamGetPriority%2CcudaStream_t%2Cptr.cint" title="cudaStreamGetPriority(hStream: cudaStream_t; priority: ptr cint): cudaError_t">cudaStreamGetPriority(hStream: cudaStream_t; priority: ptr cint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamQuery
  <li><a class="reference" href="#cudaStreamQuery%2CcudaStream_t" title="cudaStreamQuery(stream: cudaStream_t): cudaError_t">cudaStreamQuery(stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamSynchronize
  <li><a class="reference" href="#cudaStreamSynchronize%2CcudaStream_t" title="cudaStreamSynchronize(stream: cudaStream_t): cudaError_t">cudaStreamSynchronize(stream: cudaStream_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaStreamWaitEvent
  <li><a class="reference" href="#cudaStreamWaitEvent%2CcudaStream_t%2CcudaEvent_t%2Ccuint" title="cudaStreamWaitEvent(stream: cudaStream_t; event: cudaEvent_t; flags: cuint): cudaError_t">cudaStreamWaitEvent(stream: cudaStream_t; event: cudaEvent_t; flags: cuint): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaThreadExit
  <li><a class="reference" href="#cudaThreadExit" title="cudaThreadExit(): cudaError_t">cudaThreadExit(): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaThreadGetCacheConfig
  <li><a class="reference" href="#cudaThreadGetCacheConfig%2Cptr.cudaFuncCache" title="cudaThreadGetCacheConfig(pCacheConfig: ptr cudaFuncCache): cudaError_t">cudaThreadGetCacheConfig(pCacheConfig: ptr cudaFuncCache): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaThreadGetLimit
  <li><a class="reference" href="#cudaThreadGetLimit%2Cptr.csize_t%2CcudaLimit" title="cudaThreadGetLimit(pValue: ptr csize_t; limit: cudaLimit): cudaError_t">cudaThreadGetLimit(pValue: ptr csize_t; limit: cudaLimit): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaThreadSetCacheConfig
  <li><a class="reference" href="#cudaThreadSetCacheConfig%2CcudaFuncCache" title="cudaThreadSetCacheConfig(cacheConfig: cudaFuncCache): cudaError_t">cudaThreadSetCacheConfig(cacheConfig: cudaFuncCache): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaThreadSetLimit
  <li><a class="reference" href="#cudaThreadSetLimit%2CcudaLimit%2Ccsize_t" title="cudaThreadSetLimit(limit: cudaLimit; value: csize_t): cudaError_t">cudaThreadSetLimit(limit: cudaLimit; value: csize_t): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaThreadSynchronize
  <li><a class="reference" href="#cudaThreadSynchronize" title="cudaThreadSynchronize(): cudaError_t">cudaThreadSynchronize(): cudaError_t</a></li>

</ul>
<ul class="simple nested-toc-section">cudaUnbindTexture
  <li><a class="reference" href="#cudaUnbindTexture%2Cptr.textureReference" title="cudaUnbindTexture(texref: ptr textureReference): cudaError_t">cudaUnbindTexture(texref: ptr textureReference): cudaError_t</a></li>

</ul>

    </ul>
  </details>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc"><p>Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.</p>
<p>NOTICE TO LICENSEE:</p>
<p>This source code and/or documentation (&quot;Licensed Deliverables&quot;) are subject to NVIDIA intellectual property rights under U.S. and international Copyright laws.</p>
<p>These Licensed Deliverables contained herein is PROPRIETARY and CONFIDENTIAL to NVIDIA and is being provided under the terms and conditions of a form of NVIDIA software license agreement by and between NVIDIA and Licensee (&quot;License Agreement&quot;) or electronically accepted by Licensee.  Notwithstanding any terms or conditions to the contrary in the License Agreement, reproduction or disclosure of the Licensed Deliverables to any third party without the express written consent of NVIDIA is prohibited.</p>
<p>NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE LICENSE AGREEMENT, NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THESE LICENSED DELIVERABLES FOR ANY PURPOSE.  IT IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND. NVIDIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THESE LICENSED DELIVERABLES, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE. NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE LICENSE AGREEMENT, IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THESE LICENSED DELIVERABLES.</p>
<p>U.S. Government End Users.  These Licensed Deliverables are a &quot;commercial item&quot; as that term is defined at 48 C.F.R. 2.101 (OCT 1995), consisting of &quot;commercial computer software&quot; and &quot;commercial computer software documentation&quot; as such terms are used in 48 C.F.R. 12.212 (SEPT 1995) and is provided to the U.S. Government only as a commercial end item.  Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the Licensed Deliverables with only those rights set forth herein.</p>
<p>Any use of the Licensed Deliverables in individual and commercial software must include, in the user documentation and internal comments to the code, the above Disclaimer and U.S. Government End Users Notice. </p>
<p>latexonly page sync_async API synchronization behavior</p>
<p>section memcpy_sync_async_behavior Memcpy The API provides memcpy/memset functions in both synchronous and asynchronous forms, the latter having an e &quot;Async&quot; suffix. This is a misnomer as each function may exhibit synchronous or asynchronous behavior depending on the arguments passed to the function. In the reference documentation, each memcpy function is categorized as e synchronous or e asynchronous, corresponding to the definitions below.</p>
<p>subsection MemcpySynchronousBehavior Synchronous</p>
<p>&lt;ol&gt; &lt;li&gt; For transfers from pageable host memory to device memory, a stream sync is performed before the copy is initiated. The function will return once the pageable buffer has been copied to the staging memory for DMA transfer to device memory, but the DMA to final destination may not have completed.</p>
<p>&lt;li&gt; For transfers from pinned host memory to device memory, the function is synchronous with respect to the host.</p>
<p>&lt;li&gt; For transfers from device to either pageable or pinned host memory, the function returns only once the copy has completed.</p>
<p>&lt;li&gt; For transfers from device memory to device memory, no host-side synchronization is performed.</p>
<p>&lt;li&gt; For transfers from any host memory to any host memory, the function is fully synchronous with respect to the host. &lt;/ol&gt;</p>
<p>subsection MemcpyAsynchronousBehavior Asynchronous</p>
<p>&lt;ol&gt; &lt;li&gt; For transfers from device memory to pageable host memory, the function will return only once the copy has completed.</p>
<p>&lt;li&gt; For transfers from any host memory to any host memory, the function is fully synchronous with respect to the host.</p>
<p>&lt;li&gt; For all other transfers, the function is fully asynchronous. If pageable memory must first be staged to pinned memory, this will be handled asynchronously with a worker thread. &lt;/ol&gt;</p>
<p>section memset_sync_async_behavior Memset The cudaMemset functions are asynchronous with respect to the host except when the target memory is pinned host memory. The e Async versions are always asynchronous with respect to the host.</p>
<p>section kernel_launch_details Kernel Launches Kernel launches are asynchronous with respect to the host. Details of concurrent kernel execution and data transfers can be found in the CUDA Programmers Guide.</p>
<p>endlatexonly</p>
<p>There are two levels for the runtime API.</p>
<p>The C API (&lt;i&gt;cuda_runtime_api.h&lt;/i&gt;) is a C-style interface that does not require compiling with p nvcc.</p>
<p>The ref CUDART_HIGHLEVEL &quot;C++ API&quot; (&lt;i&gt;cuda_runtime.h&lt;/i&gt;) is a C++-style interface built on top of the C API. It wraps some of the C API routines, using overloading, references and default arguments. These wrappers can be used from C++ code and can be compiled with any C++ compiler. The C++ API also has some CUDA-specific wrappers that wrap C API routines that deal with symbols, textures, and device functions. These wrappers require the use of p nvcc because they depend on code being generated by the compiler. For example, the execution configuration syntax to invoke kernels is only available in source code compiled with p nvcc.</p>
<p>CUDA Runtime API Version</p>
<p>defgroup CUDART_DEVICE Device Management</p>
<p>___MANBRIEF___ device management functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the device management functions of the CUDA runtime application programming interface.</p>
<p>@{</p>
<p>brief Destroy all allocations and reset all state on the current device in the current process.</p>
<p>Explicitly destroys and cleans up all resources associated with the current device in the current process.  Any subsequent API call to this device will reinitialize the device.</p>
<p>Note that this function will reset the device immediately.  It is the caller's responsibility to ensure that the device is not being accessed by any other host threads from the process when this function is called.</p>
<p>return ::cudaSuccess notefnerr</p>
<p>sa ::cudaDeviceSynchronize </p>
<p>brief Wait for compute device to finish</p>
<p>Blocks until the device has completed all preceding requested tasks. ::cudaDeviceSynchronize() returns an error if one of the preceding tasks has failed. If the ::cudaDeviceScheduleBlockingSync flag was set for this device, the host thread will block until the device has finished its work.</p>
<p>return ::cudaSuccess notefnerr</p>
<p>sa ::cudaDeviceReset </p>
<p>brief Set resource limits</p>
<p>Setting p limit to p value is a request by the application to update the current limit maintained by the device.  The driver is free to modify the requested value to meet h/w requirements (this could be clamping to minimum or maximum values, rounding up to nearest element size, etc).  The application can use ::cudaDeviceGetLimit() to find out exactly what the limit has been set to.</p>
<p>Setting each ::cudaLimit has its own specific restrictions, so each is discussed here.</p>
<ul class="simple"><li>::cudaLimitStackSize controls the stack size in bytes of each GPU thread.</li>
<li>::cudaLimitPrintfFifoSize controls the size in bytes of the shared FIFO used by the ::printf() and ::fprintf() device system calls. Setting ::cudaLimitPrintfFifoSize must not be performed after launching any kernel that uses the ::printf() or ::fprintf() device system calls - in such case ::cudaErrorInvalidValue will be returned.</li>
<li>::cudaLimitMallocHeapSize controls the size in bytes of the heap used by the ::malloc() and ::free() device system calls. Setting ::cudaLimitMallocHeapSize must not be performed after launching any kernel that uses the ::malloc() or ::free() device system calls - in such case ::cudaErrorInvalidValue will be returned.</li>
<li>::cudaLimitDevRuntimeSyncDepth controls the maximum nesting depth of a grid at which a thread can safely call ::cudaDeviceSynchronize(). Setting this limit must be performed before any launch of a kernel that uses the device runtime and calls ::cudaDeviceSynchronize() above the default sync depth, two levels of grids. Calls to ::cudaDeviceSynchronize() will fail with error code ::cudaErrorSyncDepthExceeded if the limitation is violated. This limit can be set smaller than the default or up the maximum launch depth of 24. When setting this limit, keep in mind that additional levels of sync depth require the runtime to reserve large amounts of device memory which can no longer be used for user allocations. If these reservations of device memory fail, ::cudaDeviceSetLimit will return ::cudaErrorMemoryAllocation, and the limit can be reset to a lower value. This limit is only applicable to devices of compute capability 3.5 and higher. Attempting to set this limit on devices of compute capability less than 3.5 will result in the error ::cudaErrorUnsupportedLimit being returned.</li>
<li>::cudaLimitDevRuntimePendingLaunchCount controls the maximum number of outstanding device runtime launches that can be made from the current device. A grid is outstanding from the point of launch up until the grid is known to have been completed. Device runtime launches which violate this limitation fail and return ::cudaErrorLaunchPendingCountExceeded when ::cudaGetLastError() is called after launch. If more pending launches than the default (2048 launches) are needed for a module using the device runtime, this limit can be increased. Keep in mind that being able to sustain additional pending launches will require the runtime to reserve larger amounts of device memory upfront which can no longer be used for allocations. If these reservations fail, ::cudaDeviceSetLimit will return ::cudaErrorMemoryAllocation, and the limit can be reset to a lower value. This limit is only applicable to devices of compute capability 3.5 and higher. Attempting to set this limit on devices of compute capability less than 3.5 will result in the error ::cudaErrorUnsupportedLimit being returned.</li>
</ul>
<p>param limit - Limit to set param value - Size of limit</p>
<p>return ::cudaSuccess, ::cudaErrorUnsupportedLimit, ::cudaErrorInvalidValue, ::cudaErrorMemoryAllocation notefnerr</p>
<p>sa ::cudaDeviceGetLimit </p>
<pre>
\brief Returns resource limits

Returns in \p *pValue the current size of \p limit.  The supported
::cudaLimit values are:
- ::cudaLimitStackSize: stack size in bytes of each GPU thread;
- ::cudaLimitPrintfFifoSize: size in bytes of the shared FIFO used by the
  ::printf() and ::fprintf() device system calls.
- ::cudaLimitMallocHeapSize: size in bytes of the heap used by the
  ::malloc() and ::free() device system calls;
- ::cudaLimitDevRuntimeSyncDepth: maximum grid depth at which a
  thread can isssue the device runtime call ::cudaDeviceSynchronize()
  to wait on child grid launches to complete.
- ::cudaLimitDevRuntimePendingLaunchCount: maximum number of outstanding
  device runtime launches.

\param limit  - Limit to query
\param pValue - Returned size of the limit

\return
::cudaSuccess,
::cudaErrorUnsupportedLimit,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaDeviceSetLimit
</pre>
<p>brief Returns the preferred cache configuration for the current device.</p>
<p>On devices where the L1 cache and shared memory use the same hardware resources, this returns through p pCacheConfig the preferred cache configuration for the current device. This is only a preference. The runtime will use the requested configuration if possible, but it is free to choose a different configuration if required to execute functions.</p>
<p>This will return a p pCacheConfig of ::cudaFuncCachePreferNone on devices where the size of the L1 cache and shared memory are fixed.</p>
<p>The supported cache configurations are:</p>
<ul class="simple"><li>::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)</li>
<li>::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache</li>
<li>::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory</li>
<li>::cudaFuncCachePreferEqual: prefer equal size L1 cache and shared memory</li>
</ul>
<p>param pCacheConfig - Returned cache configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInitializationError notefnerr</p>
<p>sa cudaDeviceSetCacheConfig, ref ::cudaFuncSetCacheConfig(const void<em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;, ref ::cudaFuncSetCacheConfig(T</em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C++ API)&quot; </p>
<pre>
\brief Returns numerical values that correspond to the least and
greatest stream priorities.

Returns in \p *leastPriority and \p *greatestPriority the numerical values that correspond
to the least and greatest stream priorities respectively. Stream priorities
follow a convention where lower numbers imply greater priorities. The range of
meaningful stream priorities is given by [\p *greatestPriority, \p *leastPriority].
If the user attempts to create a stream with a priority value that is
outside the the meaningful range as specified by this API, the priority is
automatically clamped down or up to either \p *leastPriority or \p *greatestPriority
respectively. See ::cudaStreamCreateWithPriority for details on creating a
priority stream.
A NULL may be passed in for \p *leastPriority or \p *greatestPriority if the value
is not desired.

This function will return '0' in both \p *leastPriority and \p *greatestPriority if
the current context's device does not support stream priorities
(see ::cudaDeviceGetAttribute).

\param leastPriority    - Pointer to an int in which the numerical value for least
                          stream priority is returned
\param greatestPriority - Pointer to an int in which the numerical value for greatest
                          stream priority is returned

\return
::cudaSuccess,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaStreamCreateWithPriority,
::cudaStreamGetPriority
</pre>
<p>brief Sets the preferred cache configuration for the current device.</p>
<p>On devices where the L1 cache and shared memory use the same hardware resources, this sets through p cacheConfig the preferred cache configuration for the current device. This is only a preference. The runtime will use the requested configuration if possible, but it is free to choose a different configuration if required to execute the function. Any function preference set via ref ::cudaFuncSetCacheConfig(const void<em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot; or ref ::cudaFuncSetCacheConfig(T</em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C++ API)&quot; will be preferred over this device-wide setting. Setting the device-wide cache configuration to ::cudaFuncCachePreferNone will cause subsequent kernel launches to prefer to not change the cache configuration unless required to launch the kernel.</p>
<p>This setting does nothing on devices where the size of the L1 cache and shared memory are fixed.</p>
<p>Launching a kernel with a different preference than the most recent preference setting may insert a device-side synchronization point.</p>
<p>The supported cache configurations are:</p>
<ul class="simple"><li>::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)</li>
<li>::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache</li>
<li>::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory</li>
<li>::cudaFuncCachePreferEqual: prefer equal size L1 cache and shared memory</li>
</ul>
<p>param cacheConfig - Requested cache configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInitializationError notefnerr</p>
<p>sa ::cudaDeviceGetCacheConfig, ref ::cudaFuncSetCacheConfig(const void<em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;, ref ::cudaFuncSetCacheConfig(T</em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C++ API)&quot; </p>
<p>brief Returns the shared memory configuration for the current device.</p>
<p>This function will return in p pConfig the current size of shared memory banks on the current device. On devices with configurable shared memory banks, ::cudaDeviceSetSharedMemConfig can be used to change this setting, so that all subsequent kernel launches will by default use the new bank size. When ::cudaDeviceGetSharedMemConfig is called on devices without configurable shared memory, it will return the fixed bank size of the hardware.</p>
<p>The returned bank configurations can be either:</p>
<ul class="simple"><li>::cudaSharedMemBankSizeFourByte - shared memory bank width is four bytes.</li>
<li>::cudaSharedMemBankSizeEightByte - shared memory bank width is eight bytes.</li>
</ul>
<p>param pConfig - Returned cache configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInitializationError notefnerr</p>
<p>sa ::cudaDeviceSetCacheConfig, ::cudaDeviceGetCacheConfig, ::cudaDeviceSetSharedMemConfig, ::cudaFuncSetCacheConfig </p>
<p>brief Sets the shared memory configuration for the current device.</p>
<p>On devices with configurable shared memory banks, this function will set the shared memory bank size which is used for all subsequent kernel launches. Any per-function setting of shared memory set via ::cudaFuncSetSharedMemConfig will override the device wide setting.</p>
<p>Changing the shared memory configuration between launches may introduce a device side synchronization point.</p>
<p>Changing the shared memory bank size will not increase shared memory usage or affect occupancy of kernels, but may have major effects on performance. Larger bank sizes will allow for greater potential bandwidth to shared memory, but will change what kinds of accesses to shared memory will result in bank conflicts.</p>
<p>This function will do nothing on devices with fixed shared memory bank size.</p>
<p>The supported bank configurations are:</p>
<ul class="simple"><li>::cudaSharedMemBankSizeDefault: set bank width the device default (currently, four bytes)</li>
<li>::cudaSharedMemBankSizeFourByte: set shared memory bank width to be four bytes natively.</li>
<li>::cudaSharedMemBankSizeEightByte: set shared memory bank width to be eight bytes natively.</li>
</ul>
<p>param config - Requested cache configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInitializationError notefnerr</p>
<p>sa ::cudaDeviceSetCacheConfig, ::cudaDeviceGetCacheConfig, ::cudaDeviceGetSharedMemConfig, ::cudaFuncSetCacheConfig </p>
<pre>
\brief Returns a handle to a compute device

Returns in \p *device a device ordinal given a PCI bus ID string.

\param device   - Returned device ordinal

\param pciBusId - String in one of the following forms:
[domain]:[bus]:[device].[function]
[domain]:[bus]:[device]
[bus]:[device].[function]
where \p domain, \p bus, \p device, and \p function are all hexadecimal values

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidDevice
\notefnerr

\sa ::cudaDeviceGetPCIBusId
</pre>
<p>brief Returns a PCI Bus Id string for the device</p>
<p>Returns an ASCII string identifying the device p dev in the NULL-terminated string pointed to by p pciBusId. p len specifies the maximum length of the string that may be returned.</p>
<p>param pciBusId - Returned identifier string for the device in the following format <a class="reference internal" href="#domain">domain</a>:<a class="reference internal" href="#bus">bus</a>:<a class="reference internal" href="#device">device</a>.<a class="reference internal" href="#function">function</a> where p domain, p bus, p device, and p function are all hexadecimal values. pciBusId should be large enough to store 13 characters including the NULL-terminator.</p>
<p>param len      - Maximum length of string to store in p name</p>
<p>param device   - Device to get identifier string for</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr</p>
<p>sa ::cudaDeviceGetByPCIBusId</p>
<p>brief Gets an interprocess handle for a previously allocated event</p>
<p>Takes as input a previously allocated event. This event must have been created with the ::cudaEventInterprocess and ::cudaEventDisableTiming flags set. This opaque handle may be copied into other processes and opened with ::cudaIpcOpenEventHandle to allow efficient hardware synchronization between GPU work in different processes.</p>
<p>After the event has been been opened in the importing process, ::cudaEventRecord, ::cudaEventSynchronize, ::cudaStreamWaitEvent and ::cudaEventQuery may be used in either process. Performing operations on the imported event after the exported event has been freed with ::cudaEventDestroy will result in undefined behavior.</p>
<p>IPC functionality is restricted to devices with support for unified addressing on Linux operating systems.</p>
<p>param handle - Pointer to a user allocated cudaIpcEventHandle in which to return the opaque event handle param event   - Event allocated with ::cudaEventInterprocess and ::cudaEventDisableTiming flags.</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle, ::cudaErrorMemoryAllocation, ::cudaErrorMapBufferObjectFailed</p>
<p>sa ::cudaEventCreate, ::cudaEventDestroy, ::cudaEventSynchronize, ::cudaEventQuery, ::cudaStreamWaitEvent, ::cudaIpcOpenEventHandle, ::cudaIpcGetMemHandle, ::cudaIpcOpenMemHandle, ::cudaIpcCloseMemHandle </p>
<p>brief Opens an interprocess event handle for use in the current process</p>
<p>Opens an interprocess event handle exported from another process with ::cudaIpcGetEventHandle. This function returns a ::cudaEvent_t that behaves like a locally created event with the ::cudaEventDisableTiming flag specified. This event must be freed with ::cudaEventDestroy.</p>
<p>Performing operations on the imported event after the exported event has been freed with ::cudaEventDestroy will result in undefined behavior.</p>
<p>IPC functionality is restricted to devices with support for unified addressing on Linux operating systems.</p>
<p>param event - Returns the imported event param handle  - Interprocess handle to open</p>
<p>returns ::cudaSuccess, ::cudaErrorMapBufferObjectFailed, ::cudaErrorInvalidResourceHandle</p>
<p>sa ::cudaEventCreate, ::cudaEventDestroy, ::cudaEventSynchronize, ::cudaEventQuery, ::cudaStreamWaitEvent, ::cudaIpcGetEventHandle, ::cudaIpcGetMemHandle, ::cudaIpcOpenMemHandle, ::cudaIpcCloseMemHandle </p>
<p>brief Gets an interprocess memory handle for an existing device memory allocation</p>
<p>Takes a pointer to the base of an existing device memory allocation created with ::cudaMalloc and exports it for use in another process. This is a lightweight operation and may be called multiple times on an allocation without adverse effects.</p>
<p>If a region of memory is freed with ::cudaFree and a subsequent call to ::cudaMalloc returns memory with the same device address, ::cudaIpcGetMemHandle will return a unique handle for the new memory.</p>
<p>IPC functionality is restricted to devices with support for unified addressing on Linux operating systems.</p>
<p>param handle - Pointer to user allocated ::cudaIpcMemHandle to return the handle in. param devPtr - Base pointer to previously allocated device memory</p>
<p>returns ::cudaSuccess, ::cudaErrorInvalidResourceHandle, ::cudaErrorMemoryAllocation, ::cudaErrorMapBufferObjectFailed,</p>
<p>sa ::cudaMalloc, ::cudaFree, ::cudaIpcGetEventHandle, ::cudaIpcOpenEventHandle, ::cudaIpcOpenMemHandle, ::cudaIpcCloseMemHandle </p>
<pre>
\brief Opens an interprocess memory handle exported from another process
         and returns a device pointer usable in the local process.

Maps memory exported from another process with ::cudaIpcGetMemHandle into
the current device address space. For contexts on different devices
::cudaIpcOpenMemHandle can attempt to enable peer access between the
devices as if the user called ::cudaDeviceEnablePeerAccess. This behavior is
controlled by the ::cudaIpcMemLazyEnablePeerAccess flag.
::cudaDeviceCanAccessPeer can determine if a mapping is possible.

Contexts that may open ::cudaIpcMemHandles are restricted in the following way.
::cudaIpcMemHandles from each device in a given process may only be opened
by one context per device per other process.

Memory returned from ::cudaIpcOpenMemHandle must be freed with
::cudaIpcCloseMemHandle.

Calling ::cudaFree on an exported memory region before calling
::cudaIpcCloseMemHandle in the importing context will result in undefined
behavior.

IPC functionality is restricted to devices with support for unified
addressing on Linux operating systems.

\param devPtr - Returned device pointer
\param handle - ::cudaIpcMemHandle to open
\param flags  - Flags for this operation. Must be specified as ::cudaIpcMemLazyEnablePeerAccess

\returns
::cudaSuccess,
::cudaErrorMapBufferObjectFailed,
::cudaErrorInvalidResourceHandle,
::cudaErrorTooManyPeers

\note No guarantees are made about the address returned in \p *devPtr.
In particular, multiple processes may not receive the same address for the same \p handle.

\sa
::cudaMalloc,
::cudaFree,
::cudaIpcGetEventHandle,
::cudaIpcOpenEventHandle,
::cudaIpcGetMemHandle,
::cudaIpcCloseMemHandle,
::cudaDeviceEnablePeerAccess,
::cudaDeviceCanAccessPeer,
</pre>
<p>brief Close memory mapped with cudaIpcOpenMemHandle</p>
<p>Unmaps memory returnd by ::cudaIpcOpenMemHandle. The original allocation in the exporting process as well as imported mappings in other processes will be unaffected.</p>
<p>Any resources used to enable peer access will be freed if this is the last mapping using them.</p>
<p>IPC functionality is restricted to devices with support for unified addressing on Linux operating systems.</p>
<p>param devPtr - Device pointer returned by ::cudaIpcOpenMemHandle</p>
<p>returns ::cudaSuccess, ::cudaErrorMapBufferObjectFailed, ::cudaErrorInvalidResourceHandle,</p>
<p>sa ::cudaMalloc, ::cudaFree, ::cudaIpcGetEventHandle, ::cudaIpcOpenEventHandle, ::cudaIpcGetMemHandle, ::cudaIpcOpenMemHandle, </p>
<p>@} END CUDART_DEVICE</p>
<p>defgroup CUDART_THREAD_DEPRECATED Thread Management <a class="reference internal" href="#DEPRECATED">DEPRECATED</a></p>
<p>___MANBRIEF___ deprecated thread management functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes deprecated thread management functions of the CUDA runtime application programming interface.</p>
<p>@{</p>
<p>brief Exit and clean up from CUDA launches</p>
<p>deprecated</p>
<p>Note that this function is deprecated because its name does not reflect its behavior.  Its functionality is identical to the non-deprecated function ::cudaDeviceReset(), which should be used instead.</p>
<p>Explicitly destroys all cleans up all resources associated with the current device in the current process.  Any subsequent API call to this device will reinitialize the device.</p>
<p>Note that this function will reset the device immediately.  It is the caller's responsibility to ensure that the device is not being accessed by any other host threads from the process when this function is called.</p>
<p>return ::cudaSuccess notefnerr</p>
<p>sa ::cudaDeviceReset </p>
<p>brief Wait for compute device to finish</p>
<p>deprecated</p>
<p>Note that this function is deprecated because its name does not reflect its behavior.  Its functionality is similar to the non-deprecated function ::cudaDeviceSynchronize(), which should be used instead.</p>
<p>Blocks until the device has completed all preceding requested tasks. ::cudaThreadSynchronize() returns an error if one of the preceding tasks has failed. If the ::cudaDeviceScheduleBlockingSync flag was set for this device, the host thread will block until the device has finished its work.</p>
<p>return ::cudaSuccess notefnerr</p>
<p>sa ::cudaDeviceSynchronize </p>
<p>brief Set resource limits</p>
<p>deprecated</p>
<p>Note that this function is deprecated because its name does not reflect its behavior.  Its functionality is identical to the non-deprecated function ::cudaDeviceSetLimit(), which should be used instead.</p>
<p>Setting p limit to p value is a request by the application to update the current limit maintained by the device.  The driver is free to modify the requested value to meet h/w requirements (this could be clamping to minimum or maximum values, rounding up to nearest element size, etc).  The application can use ::cudaThreadGetLimit() to find out exactly what the limit has been set to.</p>
<p>Setting each ::cudaLimit has its own specific restrictions, so each is discussed here.</p>
<ul class="simple"><li>::cudaLimitStackSize controls the stack size of each GPU thread.</li>
<li>::cudaLimitPrintfFifoSize controls the size of the shared FIFO used by the ::printf() and ::fprintf() device system calls. Setting ::cudaLimitPrintfFifoSize must be performed before launching any kernel that uses the ::printf() or ::fprintf() device system calls, otherwise ::cudaErrorInvalidValue will be returned.</li>
<li>::cudaLimitMallocHeapSize controls the size of the heap used by the ::malloc() and ::free() device system calls.  Setting ::cudaLimitMallocHeapSize must be performed before launching any kernel that uses the ::malloc() or ::free() device system calls, otherwise ::cudaErrorInvalidValue will be returned.</li>
</ul>
<p>param limit - Limit to set param value - Size in bytes of limit</p>
<p>return ::cudaSuccess, ::cudaErrorUnsupportedLimit, ::cudaErrorInvalidValue notefnerr</p>
<p>sa ::cudaDeviceSetLimit </p>
<pre>
\brief Returns resource limits

\deprecated

Note that this function is deprecated because its name does not
reflect its behavior.  Its functionality is identical to the
non-deprecated function ::cudaDeviceGetLimit(), which should be used
instead.

Returns in \p *pValue the current size of \p limit.  The supported
::cudaLimit values are:
- ::cudaLimitStackSize: stack size of each GPU thread;
- ::cudaLimitPrintfFifoSize: size of the shared FIFO used by the
  ::printf() and ::fprintf() device system calls.
- ::cudaLimitMallocHeapSize: size of the heap used by the
  ::malloc() and ::free() device system calls;

\param limit  - Limit to query
\param pValue - Returned size in bytes of limit

\return
::cudaSuccess,
::cudaErrorUnsupportedLimit,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaDeviceGetLimit
</pre>
<p>brief Returns the preferred cache configuration for the current device.</p>
<p>deprecated</p>
<p>Note that this function is deprecated because its name does not reflect its behavior.  Its functionality is identical to the non-deprecated function ::cudaDeviceGetCacheConfig(), which should be used instead.</p>
<p>On devices where the L1 cache and shared memory use the same hardware resources, this returns through p pCacheConfig the preferred cache configuration for the current device. This is only a preference. The runtime will use the requested configuration if possible, but it is free to choose a different configuration if required to execute functions.</p>
<p>This will return a p pCacheConfig of ::cudaFuncCachePreferNone on devices where the size of the L1 cache and shared memory are fixed.</p>
<p>The supported cache configurations are:</p>
<ul class="simple"><li>::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)</li>
<li>::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache</li>
<li>::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory</li>
</ul>
<p>param pCacheConfig - Returned cache configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInitializationError notefnerr</p>
<p>sa cudaDeviceGetCacheConfig </p>
<p>brief Sets the preferred cache configuration for the current device.</p>
<p>deprecated</p>
<p>Note that this function is deprecated because its name does not reflect its behavior.  Its functionality is identical to the non-deprecated function ::cudaDeviceSetCacheConfig(), which should be used instead.</p>
<p>On devices where the L1 cache and shared memory use the same hardware resources, this sets through p cacheConfig the preferred cache configuration for the current device. This is only a preference. The runtime will use the requested configuration if possible, but it is free to choose a different configuration if required to execute the function. Any function preference set via ref ::cudaFuncSetCacheConfig(const void<em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot; or ref ::cudaFuncSetCacheConfig(T</em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C++ API)&quot; will be preferred over this device-wide setting. Setting the device-wide cache configuration to ::cudaFuncCachePreferNone will cause subsequent kernel launches to prefer to not change the cache configuration unless required to launch the kernel.</p>
<p>This setting does nothing on devices where the size of the L1 cache and shared memory are fixed.</p>
<p>Launching a kernel with a different preference than the most recent preference setting may insert a device-side synchronization point.</p>
<p>The supported cache configurations are:</p>
<ul class="simple"><li>::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)</li>
<li>::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache</li>
<li>::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory</li>
</ul>
<p>param cacheConfig - Requested cache configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInitializationError notefnerr</p>
<p>sa ::cudaDeviceSetCacheConfig </p>
<p>@} END CUDART_THREAD_DEPRECATED</p>
<p>defgroup CUDART_ERROR Error Handling</p>
<p>___MANBRIEF___ error handling functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the error handling functions of the CUDA runtime application programming interface.</p>
<p>@{</p>
<p>brief Returns the last error from a runtime call</p>
<p>Returns the last error that has been produced by any of the runtime calls in the same host thread and resets it to ::cudaSuccess.</p>
<p>return ::cudaSuccess, ::cudaErrorMissingConfiguration, ::cudaErrorMemoryAllocation, ::cudaErrorInitializationError, ::cudaErrorLaunchFailure, ::cudaErrorLaunchTimeout, ::cudaErrorLaunchOutOfResources, ::cudaErrorInvalidDeviceFunction, ::cudaErrorInvalidConfiguration, ::cudaErrorInvalidDevice, ::cudaErrorInvalidValue, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidSymbol, ::cudaErrorUnmapBufferObjectFailed, ::cudaErrorInvalidHostPointer, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidTexture, ::cudaErrorInvalidTextureBinding, ::cudaErrorInvalidChannelDescriptor, ::cudaErrorInvalidMemcpyDirection, ::cudaErrorInvalidFilterSetting, ::cudaErrorInvalidNormSetting, ::cudaErrorUnknown, ::cudaErrorInvalidResourceHandle, ::cudaErrorInsufficientDriver, ::cudaErrorSetOnActiveProcess, ::cudaErrorStartupFailure, notefnerr</p>
<p>sa ::cudaPeekAtLastError, ::cudaGetErrorName, ::cudaGetErrorString, ::cudaError </p>
<p>brief Returns the last error from a runtime call</p>
<p>Returns the last error that has been produced by any of the runtime calls in the same host thread. Note that this call does not reset the error to ::cudaSuccess like ::cudaGetLastError().</p>
<p>return ::cudaSuccess, ::cudaErrorMissingConfiguration, ::cudaErrorMemoryAllocation, ::cudaErrorInitializationError, ::cudaErrorLaunchFailure, ::cudaErrorLaunchTimeout, ::cudaErrorLaunchOutOfResources, ::cudaErrorInvalidDeviceFunction, ::cudaErrorInvalidConfiguration, ::cudaErrorInvalidDevice, ::cudaErrorInvalidValue, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidSymbol, ::cudaErrorUnmapBufferObjectFailed, ::cudaErrorInvalidHostPointer, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidTexture, ::cudaErrorInvalidTextureBinding, ::cudaErrorInvalidChannelDescriptor, ::cudaErrorInvalidMemcpyDirection, ::cudaErrorInvalidFilterSetting, ::cudaErrorInvalidNormSetting, ::cudaErrorUnknown, ::cudaErrorInvalidResourceHandle, ::cudaErrorInsufficientDriver, ::cudaErrorSetOnActiveProcess, ::cudaErrorStartupFailure, notefnerr</p>
<p>sa ::cudaGetLastError, ::cudaGetErrorName, ::cudaGetErrorString, ::cudaError </p>
<p>brief Returns the string representation of an error code enum name</p>
<p>Returns a string containing the name of an error code in the enum.  If the error code is not recognized, &quot;unrecognized error code&quot; is returned.</p>
<p>param error - Error code to convert to string</p>
<p>return p char* pointer to a NULL-terminated string</p>
<p>sa ::cudaGetErrorString, ::cudaGetLastError, ::cudaPeekAtLastError, ::cudaError </p>
<p>brief Returns the description string for an error code</p>
<p>Returns the description string for an error code.  If the error code is not recognized, &quot;unrecognized error code&quot; is returned.</p>
<p>param error - Error code to convert to string</p>
<p>return p char* pointer to a NULL-terminated string</p>
<p>sa ::cudaGetErrorName, ::cudaGetLastError, ::cudaPeekAtLastError, ::cudaError </p>
<pre>@}
END CUDART_ERROR

\addtogroup CUDART_DEVICE

@{


\brief Returns the number of compute-capable devices

Returns in \p *count the number of devices with compute capability greater
or equal to 2.0 that are available for execution.  If there is no such
device then ::cudaGetDeviceCount() will return ::cudaErrorNoDevice.
If no driver can be loaded to determine if any such devices exist then
::cudaGetDeviceCount() will return ::cudaErrorInsufficientDriver.

\param count - Returns the number of devices with compute capability
greater or equal to 2.0

\return
::cudaSuccess,
::cudaErrorNoDevice,
::cudaErrorInsufficientDriver
\notefnerr

\sa ::cudaGetDevice, ::cudaSetDevice, ::cudaGetDeviceProperties,
::cudaChooseDevice
</pre>
<pre>
\brief Returns information about the compute-device

Returns in \p *prop the properties of device \p dev. The ::cudaDeviceProp
structure is defined as:
\code
   struct cudaDeviceProp {
       char name[256];
       size_t totalGlobalMem;
       size_t sharedMemPerBlock;
       int regsPerBlock;
       int warpSize;
       size_t memPitch;
       int maxThreadsPerBlock;
       int maxThreadsDim[3];
       int maxGridSize[3];
       int clockRate;
       size_t totalConstMem;
       int major;
       int minor;
       size_t textureAlignment;
       size_t texturePitchAlignment;
       int deviceOverlap;
       int multiProcessorCount;
       int kernelExecTimeoutEnabled;
       int integrated;
       int canMapHostMemory;
       int computeMode;
       int maxTexture1D;
       int maxTexture1DMipmap;
       int maxTexture1DLinear;
       int maxTexture2D[2];
       int maxTexture2DMipmap[2];
       int maxTexture2DLinear[3];
       int maxTexture2DGather[2];
       int maxTexture3D[3];
       int maxTexture3DAlt[3];
       int maxTextureCubemap;
       int maxTexture1DLayered[2];
       int maxTexture2DLayered[3];
       int maxTextureCubemapLayered[2];
       int maxSurface1D;
       int maxSurface2D[2];
       int maxSurface3D[3];
       int maxSurface1DLayered[2];
       int maxSurface2DLayered[3];
       int maxSurfaceCubemap;
       int maxSurfaceCubemapLayered[2];
       size_t surfaceAlignment;
       int concurrentKernels;
       int ECCEnabled;
       int pciBusID;
       int pciDeviceID;
       int pciDomainID;
       int tccDriver;
       int asyncEngineCount;
       int unifiedAddressing;
       int memoryClockRate;
       int memoryBusWidth;
       int l2CacheSize;
       int maxThreadsPerMultiProcessor;
       int streamPrioritiesSupported;
       int globalL1CacheSupported;
       int localL1CacheSupported;
       size_t sharedMemPerMultiprocessor;
       int regsPerMultiprocessor;
       int managedMemSupported;
       int isMultiGpuBoard;
       int multiGpuBoardGroupID;
       int singleToDoublePrecisionPerfRatio;
       int pageableMemoryAccess;
       int concurrentManagedAccess;
   }
\endcode
where:
- \ref ::cudaDeviceProp::name &quot;name[256]&quot; is an ASCII string identifying
  the device;
- \ref ::cudaDeviceProp::totalGlobalMem &quot;totalGlobalMem&quot; is the total
  amount of global memory available on the device in bytes;
- \ref ::cudaDeviceProp::sharedMemPerBlock &quot;sharedMemPerBlock&quot; is the
  maximum amount of shared memory available to a thread block in bytes;
- \ref ::cudaDeviceProp::regsPerBlock &quot;regsPerBlock&quot; is the maximum number
  of 32-bit registers available to a thread block;
- \ref ::cudaDeviceProp::warpSize &quot;warpSize&quot; is the warp size in threads;
- \ref ::cudaDeviceProp::memPitch &quot;memPitch&quot; is the maximum pitch in
  bytes allowed by the memory copy functions that involve memory regions
  allocated through ::cudaMallocPitch();
- \ref ::cudaDeviceProp::maxThreadsPerBlock &quot;maxThreadsPerBlock&quot; is the
  maximum number of threads per block;
- \ref ::cudaDeviceProp::maxThreadsDim &quot;maxThreadsDim[3]&quot; contains the
  maximum size of each dimension of a block;
- \ref ::cudaDeviceProp::maxGridSize &quot;maxGridSize[3]&quot; contains the
  maximum size of each dimension of a grid;
- \ref ::cudaDeviceProp::clockRate &quot;clockRate&quot; is the clock frequency in
  kilohertz;
- \ref ::cudaDeviceProp::totalConstMem &quot;totalConstMem&quot; is the total amount
  of constant memory available on the device in bytes;
- \ref ::cudaDeviceProp::major &quot;major&quot;,
  \ref ::cudaDeviceProp::minor &quot;minor&quot; are the major and minor revision
  numbers defining the device's compute capability;
- \ref ::cudaDeviceProp::textureAlignment &quot;textureAlignment&quot; is the
  alignment requirement; texture base addresses that are aligned to
  \ref ::cudaDeviceProp::textureAlignment &quot;textureAlignment&quot; bytes do not
  need an offset applied to texture fetches;
- \ref ::cudaDeviceProp::texturePitchAlignment &quot;texturePitchAlignment&quot; is the
  pitch alignment requirement for 2D texture references that are bound to
  pitched memory;
- \ref ::cudaDeviceProp::deviceOverlap &quot;deviceOverlap&quot; is 1 if the device
  can concurrently copy memory between host and device while executing a
  kernel, or 0 if not.  Deprecated, use instead asyncEngineCount.
- \ref ::cudaDeviceProp::multiProcessorCount &quot;multiProcessorCount&quot; is the
  number of multiprocessors on the device;
- \ref ::cudaDeviceProp::kernelExecTimeoutEnabled &quot;kernelExecTimeoutEnabled&quot;
  is 1 if there is a run time limit for kernels executed on the device, or
  0 if not.
- \ref ::cudaDeviceProp::integrated &quot;integrated&quot; is 1 if the device is an
  integrated (motherboard) GPU and 0 if it is a discrete (card) component.
- \ref ::cudaDeviceProp::canMapHostMemory &quot;canMapHostMemory&quot; is 1 if the
  device can map host memory into the CUDA address space for use with
  ::cudaHostAlloc()/::cudaHostGetDevicePointer(), or 0 if not;
- \ref ::cudaDeviceProp::computeMode &quot;computeMode&quot; is the compute mode
  that the device is currently in. Available modes are as follows:
  - cudaComputeModeDefault: Default mode - Device is not restricted and
    multiple threads can use ::cudaSetDevice() with this device.
  - cudaComputeModeExclusive: Compute-exclusive mode - Only one thread will
    be able to use ::cudaSetDevice() with this device.
  - cudaComputeModeProhibited: Compute-prohibited mode - No threads can use
    ::cudaSetDevice() with this device.
  - cudaComputeModeExclusiveProcess: Compute-exclusive-process mode - Many
    threads in one process will be able to use ::cudaSetDevice() with this device.
  &lt;br&gt; If ::cudaSetDevice() is called on an already occupied \p device with
  computeMode ::cudaComputeModeExclusive, ::cudaErrorDeviceAlreadyInUse
  will be immediately returned indicating the device cannot be used.
  When an occupied exclusive mode device is chosen with ::cudaSetDevice,
  all subsequent non-device management runtime functions will return
  ::cudaErrorDevicesUnavailable.
- \ref ::cudaDeviceProp::maxTexture1D &quot;maxTexture1D&quot; is the maximum 1D
  texture size.
- \ref ::cudaDeviceProp::maxTexture1DMipmap &quot;maxTexture1DMipmap&quot; is the maximum
  1D mipmapped texture texture size.
- \ref ::cudaDeviceProp::maxTexture1DLinear &quot;maxTexture1DLinear&quot; is the maximum
  1D texture size for textures bound to linear memory.
- \ref ::cudaDeviceProp::maxTexture2D &quot;maxTexture2D[2]&quot; contains the maximum
  2D texture dimensions.
- \ref ::cudaDeviceProp::maxTexture2DMipmap &quot;maxTexture2DMipmap[2]&quot; contains the
  maximum 2D mipmapped texture dimensions.
- \ref ::cudaDeviceProp::maxTexture2DLinear &quot;maxTexture2DLinear[3]&quot; contains the
  maximum 2D texture dimensions for 2D textures bound to pitch linear memory.
- \ref ::cudaDeviceProp::maxTexture2DGather &quot;maxTexture2DGather[2]&quot; contains the
  maximum 2D texture dimensions if texture gather operations have to be performed.
- \ref ::cudaDeviceProp::maxTexture3D &quot;maxTexture3D[3]&quot; contains the maximum
  3D texture dimensions.
- \ref ::cudaDeviceProp::maxTexture3DAlt &quot;maxTexture3DAlt[3]&quot;
  contains the maximum alternate 3D texture dimensions.
- \ref ::cudaDeviceProp::maxTextureCubemap &quot;maxTextureCubemap&quot; is the
  maximum cubemap texture width or height.
- \ref ::cudaDeviceProp::maxTexture1DLayered &quot;maxTexture1DLayered[2]&quot; contains
  the maximum 1D layered texture dimensions.
- \ref ::cudaDeviceProp::maxTexture2DLayered &quot;maxTexture2DLayered[3]&quot; contains
  the maximum 2D layered texture dimensions.
- \ref ::cudaDeviceProp::maxTextureCubemapLayered &quot;maxTextureCubemapLayered[2]&quot;
  contains the maximum cubemap layered texture dimensions.
- \ref ::cudaDeviceProp::maxSurface1D &quot;maxSurface1D&quot; is the maximum 1D
  surface size.
- \ref ::cudaDeviceProp::maxSurface2D &quot;maxSurface2D[2]&quot; contains the maximum
  2D surface dimensions.
- \ref ::cudaDeviceProp::maxSurface3D &quot;maxSurface3D[3]&quot; contains the maximum
  3D surface dimensions.
- \ref ::cudaDeviceProp::maxSurface1DLayered &quot;maxSurface1DLayered[2]&quot; contains
  the maximum 1D layered surface dimensions.
- \ref ::cudaDeviceProp::maxSurface2DLayered &quot;maxSurface2DLayered[3]&quot; contains
  the maximum 2D layered surface dimensions.
- \ref ::cudaDeviceProp::maxSurfaceCubemap &quot;maxSurfaceCubemap&quot; is the maximum
  cubemap surface width or height.
- \ref ::cudaDeviceProp::maxSurfaceCubemapLayered &quot;maxSurfaceCubemapLayered[2]&quot;
  contains the maximum cubemap layered surface dimensions.
- \ref ::cudaDeviceProp::surfaceAlignment &quot;surfaceAlignment&quot; specifies the
  alignment requirements for surfaces.
- \ref ::cudaDeviceProp::concurrentKernels &quot;concurrentKernels&quot; is 1 if the
  device supports executing multiple kernels within the same context
  simultaneously, or 0 if not. It is not guaranteed that multiple kernels
  will be resident on the device concurrently so this feature should not be
  relied upon for correctness;
- \ref ::cudaDeviceProp::ECCEnabled &quot;ECCEnabled&quot; is 1 if the device has ECC
  support turned on, or 0 if not.
- \ref ::cudaDeviceProp::pciBusID &quot;pciBusID&quot; is the PCI bus identifier of
  the device.
- \ref ::cudaDeviceProp::pciDeviceID &quot;pciDeviceID&quot; is the PCI device
  (sometimes called slot) identifier of the device.
- \ref ::cudaDeviceProp::pciDomainID &quot;pciDomainID&quot; is the PCI domain identifier
  of the device.
- \ref ::cudaDeviceProp::tccDriver &quot;tccDriver&quot; is 1 if the device is using a
  TCC driver or 0 if not.
- \ref ::cudaDeviceProp::asyncEngineCount &quot;asyncEngineCount&quot; is 1 when the
  device can concurrently copy memory between host and device while executing
  a kernel. It is 2 when the device can concurrently copy memory between host
  and device in both directions and execute a kernel at the same time. It is
  0 if neither of these is supported.
- \ref ::cudaDeviceProp::unifiedAddressing &quot;unifiedAddressing&quot; is 1 if the device
  shares a unified address space with the host and 0 otherwise.
- \ref ::cudaDeviceProp::memoryClockRate &quot;memoryClockRate&quot; is the peak memory
  clock frequency in kilohertz.
- \ref ::cudaDeviceProp::memoryBusWidth &quot;memoryBusWidth&quot; is the memory bus width
  in bits.
- \ref ::cudaDeviceProp::l2CacheSize &quot;l2CacheSize&quot; is L2 cache size in bytes.
- \ref ::cudaDeviceProp::maxThreadsPerMultiProcessor &quot;maxThreadsPerMultiProcessor&quot;
  is the number of maximum resident threads per multiprocessor.
- \ref ::cudaDeviceProp::streamPrioritiesSupported &quot;streamPrioritiesSupported&quot;
  is 1 if the device supports stream priorities, or 0 if it is not supported.
- \ref ::cudaDeviceProp::globalL1CacheSupported &quot;globalL1CacheSupported&quot;
  is 1 if the device supports caching of globals in L1 cache, or 0 if it is not supported.
- \ref ::cudaDeviceProp::localL1CacheSupported &quot;localL1CacheSupported&quot;
  is 1 if the device supports caching of locals in L1 cache, or 0 if it is not supported.
- \ref ::cudaDeviceProp::sharedMemPerMultiprocessor &quot;sharedMemPerMultiprocessor&quot; is the
  maximum amount of shared memory available to a multiprocessor in bytes; this amount is
  shared by all thread blocks simultaneously resident on a multiprocessor;
- \ref ::cudaDeviceProp::regsPerMultiprocessor &quot;regsPerMultiprocessor&quot; is the maximum number
  of 32-bit registers available to a multiprocessor; this number is shared
  by all thread blocks simultaneously resident on a multiprocessor;
- \ref ::cudaDeviceProp::managedMemory &quot;managedMemory&quot;
  is 1 if the device supports allocating managed memory on this system, or 0 if it is not supported.
- \ref ::cudaDeviceProp::isMultiGpuBoard &quot;isMultiGpuBoard&quot;
  is 1 if the device is on a multi-GPU board (e.g. Gemini cards), and 0 if not;
- \ref ::cudaDeviceProp::multiGpuBoardGroupID &quot;multiGpuBoardGroupID&quot; is a unique identifier
  for a group of devices associated with the same board.
  Devices on the same multi-GPU board will share the same identifier;
- \ref ::cudaDeviceProp::singleToDoublePrecisionPerfRatio &quot;singleToDoublePrecisionPerfRatio&quot;
  is the ratio of single precision performance (in floating-point operations per second)
  to double precision performance.
- \ref ::cudaDeviceProp::pageableMemoryAccess &quot;pageableMemoryAccess&quot; is 1 if the device supports
  coherently accessing pageable memory without calling cudaHostRegister on it, and 0 otherwise.
- \ref ::cudaDeviceProp::concurrentManagedAccess &quot;concurrentManagedAccess&quot; is 1 if the device can
  coherently access managed memory concurrently with the CPU, and 0 otherwise.

\param prop   - Properties for the specified device
\param device - Device number to get properties for

\return
::cudaSuccess,
::cudaErrorInvalidDevice

\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice, ::cudaChooseDevice,
::cudaDeviceGetAttribute
</pre>
<pre>
\brief Returns information about the device

Returns in \p *value the integer value of the attribute \p attr on device
\p device. The supported attributes are:
- ::cudaDevAttrMaxThreadsPerBlock: Maximum number of threads per block;
- ::cudaDevAttrMaxBlockDimX: Maximum x-dimension of a block;
- ::cudaDevAttrMaxBlockDimY: Maximum y-dimension of a block;
- ::cudaDevAttrMaxBlockDimZ: Maximum z-dimension of a block;
- ::cudaDevAttrMaxGridDimX: Maximum x-dimension of a grid;
- ::cudaDevAttrMaxGridDimY: Maximum y-dimension of a grid;
- ::cudaDevAttrMaxGridDimZ: Maximum z-dimension of a grid;
- ::cudaDevAttrMaxSharedMemoryPerBlock: Maximum amount of shared memory
  available to a thread block in bytes;
- ::cudaDevAttrTotalConstantMemory: Memory available on device for
  __constant__ variables in a CUDA C kernel in bytes;
- ::cudaDevAttrWarpSize: Warp size in threads;
- ::cudaDevAttrMaxPitch: Maximum pitch in bytes allowed by the memory copy
  functions that involve memory regions allocated through ::cudaMallocPitch();
- ::cudaDevAttrMaxTexture1DWidth: Maximum 1D texture width;
- ::cudaDevAttrMaxTexture1DLinearWidth: Maximum width for a 1D texture bound
  to linear memory;
- ::cudaDevAttrMaxTexture1DMipmappedWidth: Maximum mipmapped 1D texture width;
- ::cudaDevAttrMaxTexture2DWidth: Maximum 2D texture width;
- ::cudaDevAttrMaxTexture2DHeight: Maximum 2D texture height;
- ::cudaDevAttrMaxTexture2DLinearWidth: Maximum width for a 2D texture
  bound to linear memory;
- ::cudaDevAttrMaxTexture2DLinearHeight: Maximum height for a 2D texture
  bound to linear memory;
- ::cudaDevAttrMaxTexture2DLinearPitch: Maximum pitch in bytes for a 2D
  texture bound to linear memory;
- ::cudaDevAttrMaxTexture2DMipmappedWidth: Maximum mipmapped 2D texture
  width;
- ::cudaDevAttrMaxTexture2DMipmappedHeight: Maximum mipmapped 2D texture
  height;
- ::cudaDevAttrMaxTexture3DWidth: Maximum 3D texture width;
- ::cudaDevAttrMaxTexture3DHeight: Maximum 3D texture height;
- ::cudaDevAttrMaxTexture3DDepth: Maximum 3D texture depth;
- ::cudaDevAttrMaxTexture3DWidthAlt: Alternate maximum 3D texture width,
  0 if no alternate maximum 3D texture size is supported;
- ::cudaDevAttrMaxTexture3DHeightAlt: Alternate maximum 3D texture height,
  0 if no alternate maximum 3D texture size is supported;
- ::cudaDevAttrMaxTexture3DDepthAlt: Alternate maximum 3D texture depth,
  0 if no alternate maximum 3D texture size is supported;
- ::cudaDevAttrMaxTextureCubemapWidth: Maximum cubemap texture width or
  height;
- ::cudaDevAttrMaxTexture1DLayeredWidth: Maximum 1D layered texture width;
- ::cudaDevAttrMaxTexture1DLayeredLayers: Maximum layers in a 1D layered
  texture;
- ::cudaDevAttrMaxTexture2DLayeredWidth: Maximum 2D layered texture width;
- ::cudaDevAttrMaxTexture2DLayeredHeight: Maximum 2D layered texture height;
- ::cudaDevAttrMaxTexture2DLayeredLayers: Maximum layers in a 2D layered
  texture;
- ::cudaDevAttrMaxTextureCubemapLayeredWidth: Maximum cubemap layered
  texture width or height;
- ::cudaDevAttrMaxTextureCubemapLayeredLayers: Maximum layers in a cubemap
  layered texture;
- ::cudaDevAttrMaxSurface1DWidth: Maximum 1D surface width;
- ::cudaDevAttrMaxSurface2DWidth: Maximum 2D surface width;
- ::cudaDevAttrMaxSurface2DHeight: Maximum 2D surface height;
- ::cudaDevAttrMaxSurface3DWidth: Maximum 3D surface width;
- ::cudaDevAttrMaxSurface3DHeight: Maximum 3D surface height;
- ::cudaDevAttrMaxSurface3DDepth: Maximum 3D surface depth;
- ::cudaDevAttrMaxSurface1DLayeredWidth: Maximum 1D layered surface width;
- ::cudaDevAttrMaxSurface1DLayeredLayers: Maximum layers in a 1D layered
  surface;
- ::cudaDevAttrMaxSurface2DLayeredWidth: Maximum 2D layered surface width;
- ::cudaDevAttrMaxSurface2DLayeredHeight: Maximum 2D layered surface height;
- ::cudaDevAttrMaxSurface2DLayeredLayers: Maximum layers in a 2D layered
  surface;
- ::cudaDevAttrMaxSurfaceCubemapWidth: Maximum cubemap surface width;
- ::cudaDevAttrMaxSurfaceCubemapLayeredWidth: Maximum cubemap layered
  surface width;
- ::cudaDevAttrMaxSurfaceCubemapLayeredLayers: Maximum layers in a cubemap
  layered surface;
- ::cudaDevAttrMaxRegistersPerBlock: Maximum number of 32-bit registers
  available to a thread block;
- ::cudaDevAttrClockRate: Peak clock frequency in kilohertz;
- ::cudaDevAttrTextureAlignment: Alignment requirement; texture base
  addresses aligned to ::textureAlign bytes do not need an offset applied
  to texture fetches;
- ::cudaDevAttrTexturePitchAlignment: Pitch alignment requirement for 2D
  texture references bound to pitched memory;
- ::cudaDevAttrGpuOverlap: 1 if the device can concurrently copy memory
  between host and device while executing a kernel, or 0 if not;
- ::cudaDevAttrMultiProcessorCount: Number of multiprocessors on the device;
- ::cudaDevAttrKernelExecTimeout: 1 if there is a run time limit for kernels
  executed on the device, or 0 if not;
- ::cudaDevAttrIntegrated: 1 if the device is integrated with the memory
  subsystem, or 0 if not;
- ::cudaDevAttrCanMapHostMemory: 1 if the device can map host memory into
  the CUDA address space, or 0 if not;
- ::cudaDevAttrComputeMode: Compute mode is the compute mode that the device
  is currently in. Available modes are as follows:
  - ::cudaComputeModeDefault: Default mode - Device is not restricted and
    multiple threads can use ::cudaSetDevice() with this device.
  - ::cudaComputeModeExclusive: Compute-exclusive mode - Only one thread will
    be able to use ::cudaSetDevice() with this device.
  - ::cudaComputeModeProhibited: Compute-prohibited mode - No threads can use
    ::cudaSetDevice() with this device.
  - ::cudaComputeModeExclusiveProcess: Compute-exclusive-process mode - Many
    threads in one process will be able to use ::cudaSetDevice() with this
    device.
- ::cudaDevAttrConcurrentKernels: 1 if the device supports executing
  multiple kernels within the same context simultaneously, or 0 if
  not. It is not guaranteed that multiple kernels will be resident on the
  device concurrently so this feature should not be relied upon for
  correctness;
- ::cudaDevAttrEccEnabled: 1 if error correction is enabled on the device,
  0 if error correction is disabled or not supported by the device;
- ::cudaDevAttrPciBusId: PCI bus identifier of the device;
- ::cudaDevAttrPciDeviceId: PCI device (also known as slot) identifier of
  the device;
- ::cudaDevAttrTccDriver: 1 if the device is using a TCC driver. TCC is only
  available on Tesla hardware running Windows Vista or later;
- ::cudaDevAttrMemoryClockRate: Peak memory clock frequency in kilohertz;
- ::cudaDevAttrGlobalMemoryBusWidth: Global memory bus width in bits;
- ::cudaDevAttrL2CacheSize: Size of L2 cache in bytes. 0 if the device
  doesn't have L2 cache;
- ::cudaDevAttrMaxThreadsPerMultiProcessor: Maximum resident threads per
  multiprocessor;
- ::cudaDevAttrUnifiedAddressing: 1 if the device shares a unified address
  space with the host, or 0 if not;
- ::cudaDevAttrComputeCapabilityMajor: Major compute capability version
  number;
- ::cudaDevAttrComputeCapabilityMinor: Minor compute capability version
  number;
- ::cudaDevAttrStreamPrioritiesSupported: 1 if the device supports stream
  priorities, or 0 if not;
- ::cudaDevAttrGlobalL1CacheSupported: 1 if device supports caching globals
   in L1 cache, 0 if not;
- ::cudaDevAttrGlobalL1CacheSupported: 1 if device supports caching locals
   in L1 cache, 0 if not;
- ::cudaDevAttrMaxSharedMemoryPerMultiprocessor: Maximum amount of shared memory
  available to a multiprocessor in bytes; this amount is shared by all
  thread blocks simultaneously resident on a multiprocessor;
- ::cudaDevAttrMaxRegistersPerMultiprocessor: Maximum number of 32-bit registers
  available to a multiprocessor; this number is shared by all thread blocks
  simultaneously resident on a multiprocessor;
- ::cudaDevAttrManagedMemSupported: 1 if device supports allocating
  managed memory, 0 if not;
- ::cudaDevAttrIsMultiGpuBoard: 1 if device is on a multi-GPU board, 0 if not;
- ::cudaDevAttrMultiGpuBoardGroupID: Unique identifier for a group of devices on the
  same multi-GPU board;
- ::cudaDevAttrHostNativeAtomicSupported: 1 if the link between the device and the
  host supports native atomic operations;
- ::cudaDevAttrSingleToDoublePrecisionPerfRatio: Ratio of single precision performance
  (in floating-point operations per second) to double precision performance;
- ::cudaDevAttrPageableMemoryAccess: 1 if the device supports coherently accessing
  pageable memory without calling cudaHostRegister on it, and 0 otherwise.
- ::cudaDevAttrConcurrentManagedAccess: 1 if the device can coherently access managed
  memory concurrently with the CPU, and 0 otherwise.
- ::cudaDevAttrComputePreemptionSupported: 1 if the device supports
  Compute Preemption, 0 if not.
- ::cudaDevAttrCanUseHostPointerForRegisteredMem: 1 if the device can access host
  registered memory at the same virtual address as the CPU, and 0 otherwise.

\param value  - Returned device attribute value
\param attr   - Device attribute to query
\param device - Device number to query

\return
::cudaSuccess,
::cudaErrorInvalidDevice,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice, ::cudaChooseDevice,
::cudaGetDeviceProperties
</pre>
<pre>
\brief Queries attributes of the link between two devices.

Returns in \p *value the value of the requested attribute \p attrib of the
link between \p srcDevice and \p dstDevice. The supported attributes are:
- ::CudaDevP2PAttrPerformanceRank: A relative value indicating the
  performance of the link between two devices. Lower value means better
  performance (0 being the value used for most performant link).
- ::CudaDevP2PAttrAccessSupported: 1 if peer access is enabled.
- ::CudaDevP2PAttrNativeAtomicSupported: 1 if native atomic operations over
  the link are supported.

Returns ::cudaErrorInvalidDevice if \p srcDevice or \p dstDevice are not valid
or if they represent the same device.

Returns ::cudaErrorInvalidValue if \p attrib is not valid or if \p value is
a null pointer.

\param value         - Returned value of the requested attribute
\param attrib        - The requested attribute of the link between \p srcDevice and \p dstDevice.
\param srcDevice     - The source device of the target link.
\param dstDevice     - The destination device of the target link.

\return
::cudaSuccess,
::cudaErrorInvalidDevice,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaCtxEnablePeerAccess,
::cudaCtxDisablePeerAccess,
::cudaCtxCanAccessPeer
</pre>
<pre>
\brief Select compute-device which best matches criteria

Returns in \p *device the device which has properties that best match
\p *prop.

\param device - Device with best match
\param prop   - Desired device properties

\return
::cudaSuccess,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice,
::cudaGetDeviceProperties
</pre>
<p>brief Set device to be used for GPU executions</p>
<p>Sets p device as the current device for the calling host thread. Valid device id's are 0 to (::cudaGetDeviceCount() - 1).</p>
<p>Any device memory subsequently allocated from this host thread using ::cudaMalloc(), ::cudaMallocPitch() or ::cudaMallocArray() will be physically resident on p device.  Any host memory allocated from this host thread using ::cudaMallocHost() or ::cudaHostAlloc() or ::cudaHostRegister() will have its lifetime associated  with p device.  Any streams or events created from this host thread will be associated with p device.  Any kernels launched from this host thread using the &lt;&lt;&lt;&gt;&gt;&gt; operator or ::cudaLaunchKernel() will be executed on p device.</p>
<p>This call may be made from any host thread, to any device, and at any time.  This function will do no synchronization with the previous or new device, and should be considered a very low overhead call.</p>
<p>param device - Device on which the active host thread should execute the device code.</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidDevice, ::cudaErrorDeviceAlreadyInUse notefnerr</p>
<p>sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaGetDeviceProperties, ::cudaChooseDevice </p>
<pre>
\brief Returns which device is currently being used

Returns in \p *device the current device for the calling host thread.

\param device - Returns the device on which the active host thread
executes the device code.

\return
::cudaSuccess
\notefnerr

\sa ::cudaGetDeviceCount, ::cudaSetDevice, ::cudaGetDeviceProperties,
::cudaChooseDevice
</pre>
<p>brief Set a list of devices that can be used for CUDA</p>
<p>Sets a list of devices for CUDA execution in priority order using p device_arr. The parameter p len specifies the number of elements in the list.  CUDA will try devices from the list sequentially until it finds one that works.  If this function is not called, or if it is called with a p len of 0, then CUDA will go back to its default behavior of trying devices sequentially from a default list containing all of the available CUDA devices in the system. If a specified device ID in the list does not exist, this function will return ::cudaErrorInvalidDevice. If p len is not 0 and p device_arr is NULL or if p len exceeds the number of devices in the system, then ::cudaErrorInvalidValue is returned.</p>
<p>param device_arr - List of devices to try param len        - Number of devices in specified list</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr</p>
<p>sa ::cudaGetDeviceCount, ::cudaSetDevice, ::cudaGetDeviceProperties, ::cudaSetDeviceFlags, ::cudaChooseDevice </p>
<p>brief Sets flags to be used for device executions</p>
<p>Records p flags as the flags to use when initializing the current device.  If no device has been made current to the calling thread, then p flags will be applied to the initialization of any device initialized by the calling host thread, unless that device has had its initialization flags set explicitly by this or any host thread.</p>
<p>If the current device has been set and that device has already been initialized then this call will fail with the error ::cudaErrorSetOnActiveProcess.  In this case it is necessary to reset p device using ::cudaDeviceReset() before the device's initialization flags may be set.</p>
<p>The two LSBs of the p flags parameter can be used to control how the CPU thread interacts with the OS scheduler when waiting for results from the device.</p>
<ul class="simple"><li>::cudaDeviceScheduleAuto: The default value if the p flags parameter is</li>
</ul>
<p>zero, uses a heuristic based on the number of active CUDA contexts in the process p C and the number of logical processors in the system p P. If p C &gt; p P, then CUDA will yield to other OS threads when waiting for the device, otherwise CUDA will not yield while waiting for results and actively spin on the processor.</p>
<ul class="simple"><li>::cudaDeviceScheduleSpin: Instruct CUDA to actively spin when waiting for</li>
</ul>
<p>results from the device. This can decrease latency when waiting for the device, but may lower the performance of CPU threads if they are performing work in parallel with the CUDA thread.</p>
<ul class="simple"><li>::cudaDeviceScheduleYield: Instruct CUDA to yield its thread when waiting</li>
</ul>
<p>for results from the device. This can increase latency when waiting for the device, but can increase the performance of CPU threads performing work in parallel with the device.</p>
<ul class="simple"><li>::cudaDeviceScheduleBlockingSync: Instruct CUDA to block the CPU thread</li>
</ul>
<p>on a synchronization primitive when waiting for the device to finish work.</p>
<ul class="simple"><li>::cudaDeviceBlockingSync: Instruct CUDA to block the CPU thread on a</li>
</ul>
<p>synchronization primitive when waiting for the device to finish work. &lt;br&gt; ref deprecated &quot;Deprecated:&quot; This flag was deprecated as of CUDA 4.0 and replaced with ::cudaDeviceScheduleBlockingSync.</p>
<ul class="simple"><li>::cudaDeviceMapHost: This flag enables allocating pinned</li>
</ul>
<p>host memory that is accessible to the device. It is implicit for the runtime but may be absent if a context is created using the driver API. If this flag is not set, ::cudaHostGetDevicePointer() will always return a failure code.</p>
<ul class="simple"><li>::cudaDeviceLmemResizeToMax: Instruct CUDA to not reduce local memory</li>
</ul>
<p>after resizing local memory for a kernel. This can prevent thrashing by local memory allocations when launching many kernels with high local memory usage at the cost of potentially increased memory usage.</p>
<p>param flags - Parameters for device operation</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidDevice, ::cudaErrorSetOnActiveProcess</p>
<p>sa ::cudaGetDeviceFlags, ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaGetDeviceProperties, ::cudaSetDevice, ::cudaSetValidDevices, ::cudaChooseDevice </p>
<p>brief Gets the flags for the current device</p>
<p>Returns in p flags the flags for the current device.  If there is a current device for the calling thread, and the device has been initialized or flags have been set on that device specifically, the flags for the device are returned.  If there is no current device, but flags have been set for the thread with ::cudaSetDeviceFlags, the thread flags are returned. Finally, if there is no current device and no thread flags, the flags for the first device are returned, which may be the default flags.  Compare to the behavior of ::cudaSetDeviceFlags.</p>
<p>Typically, the flags returned should match the behavior that will be seen if the calling thread uses a device after this call, without any change to the flags or current device inbetween by this or another thread.  Note that if the device is not initialized, it is possible for another thread to change the flags for the current device before it is initialized. Additionally, when using exclusive mode, if this thread has not requested a specific device, it may use a device other than the first device, contrary to the assumption made by this function.</p>
<p>If a context has been created via the driver API and is current to the calling thread, the flags for that context are always returned.</p>
<p>Flags returned by this function may specifically include ::cudaDeviceMapHost even though it is not accepted by ::cudaSetDeviceFlags because it is implicit in runtime API flags.  The reason for this is that the current context may have been created via the driver API in which case the flag is not implicit and may be unset.</p>
<p>param flags - Pointer to store the device flags</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidDevice</p>
<p>sa ::cudaGetDevice, ::cudaGetDeviceProperties, ::cudaSetDevice, ::cudaSetDeviceFlags </p>
<p>@} END CUDART_DEVICE</p>
<p>defgroup CUDART_STREAM Stream Management</p>
<p>___MANBRIEF___ stream management functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the stream management functions of the CUDA runtime application programming interface.</p>
<p>@{</p>
<p>brief Create an asynchronous stream</p>
<p>Creates a new asynchronous stream.</p>
<p>param pStream - Pointer to new stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue notefnerr</p>
<p>sa ::cudaStreamCreateWithPriority, ::cudaStreamCreateWithFlags, ::cudaStreamGetPriority, ::cudaStreamGetFlags, ::cudaStreamQuery, ::cudaStreamSynchronize, ::cudaStreamWaitEvent, ::cudaStreamAddCallback, ::cudaStreamDestroy </p>
<p>brief Create an asynchronous stream</p>
<p>Creates a new asynchronous stream.  The p flags argument determines the behaviors of the stream.  Valid values for p flags are</p>
<ul class="simple"><li>::cudaStreamDefault: Default stream creation flag.</li>
<li>::cudaStreamNonBlocking: Specifies that work running in the created stream may run concurrently with work in stream 0 (the NULL stream), and that the created stream should perform no implicit synchronization with stream 0.</li>
</ul>
<p>param pStream - Pointer to new stream identifier param flags   - Parameters for stream creation</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue notefnerr</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithPriority, ::cudaStreamGetFlags, ::cudaStreamQuery, ::cudaStreamSynchronize, ::cudaStreamWaitEvent, ::cudaStreamAddCallback, ::cudaStreamDestroy </p>
<p>brief Create an asynchronous stream with the specified priority</p>
<p>Creates a stream with the specified priority and returns a handle in p pStream. This API alters the scheduler priority of work in the stream. Work in a higher priority stream may preempt work already executing in a low priority stream.</p>
<p>p priority follows a convention where lower numbers represent higher priorities. '0' represents default priority. The range of meaningful numerical priorities can be queried using ::cudaDeviceGetStreamPriorityRange. If the specified priority is outside the numerical range returned by ::cudaDeviceGetStreamPriorityRange, it will automatically be clamped to the lowest or the highest number in the range.</p>
<p>param pStream  - Pointer to new stream identifier param flags    - Flags for stream creation. See ::cudaStreamCreateWithFlags for a list of valid flags that can be passed param priority - Priority of the stream. Lower numbers represent higher priorities. See ::cudaDeviceGetStreamPriorityRange for more information about the meaningful stream priorities that can be passed.</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue notefnerr</p>
<p>note Stream priorities are supported only on GPUs with compute capability 3.5 or higher.</p>
<p>note In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaDeviceGetStreamPriorityRange, ::cudaStreamGetPriority, ::cudaStreamQuery, ::cudaStreamWaitEvent, ::cudaStreamAddCallback, ::cudaStreamSynchronize, ::cudaStreamDestroy </p>
<p>brief Query the priority of a stream</p>
<p>Query the priority of a stream. The priority is returned in in p priority. Note that if the stream was created with a priority outside the meaningful numerical range returned by ::cudaDeviceGetStreamPriorityRange, this function returns the clamped priority. See ::cudaStreamCreateWithPriority for details about priority clamping.</p>
<p>param hStream    - Handle to the stream to be queried param priority   - Pointer to a signed integer in which the stream's priority is returned</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidResourceHandle notefnerr</p>
<p>sa ::cudaStreamCreateWithPriority, ::cudaDeviceGetStreamPriorityRange, ::cudaStreamGetFlags </p>
<p>brief Query the flags of a stream</p>
<p>Query the flags of a stream. The flags are returned in p flags. See ::cudaStreamCreateWithFlags for a list of valid flags.</p>
<p>param hStream - Handle to the stream to be queried param flags   - Pointer to an unsigned integer in which the stream's flags are returned</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidResourceHandle notefnerr</p>
<p>sa ::cudaStreamCreateWithPriority, ::cudaStreamCreateWithFlags, ::cudaStreamGetPriority </p>
<p>brief Destroys and cleans up an asynchronous stream</p>
<p>Destroys and cleans up the asynchronous stream specified by p stream.</p>
<p>In case the device is still doing work in the stream p stream when ::cudaStreamDestroy() is called, the function will return immediately and the resources associated with p stream will be released automatically once the device has completed all work in p stream.</p>
<p>param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle notefnerr</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamQuery, ::cudaStreamWaitEvent, ::cudaStreamSynchronize, ::cudaStreamAddCallback </p>
<p>brief Make a compute stream wait on an event</p>
<p>Makes all future work submitted to p stream wait until p event reports completion before beginning execution.  This synchronization will be performed efficiently on the device.  The event p event may be from a different context than p stream, in which case this function will perform cross-device synchronization.</p>
<p>The stream p stream will wait only for the completion of the most recent host call to ::cudaEventRecord() on p event.  Once this call has returned, any functions (including ::cudaEventRecord() and ::cudaEventDestroy()) may be called on p event again, and the subsequent calls will not have any effect on p stream.</p>
<p>If ::cudaEventRecord() has not been called on p event, this call acts as if the record has already completed, and so is a functional no-op.</p>
<p>param stream - Stream to wait param event  - Event to wait on param flags  - Parameters for the operation (must be 0)</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle note_null_stream notefnerr</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamQuery, ::cudaStreamSynchronize, ::cudaStreamAddCallback, ::cudaStreamDestroy </p>
Type of stream callback functions. param stream The stream as passed to ::cudaStreamAddCallback, may be NULL. param status ::cudaSuccess or any persistent error on the stream. param userData User parameter provided at registration. <p>brief Add a callback to a compute stream</p>
<p>Adds a callback to be called on the host after all currently enqueued items in the stream have completed.  For each cudaStreamAddCallback call, a callback will be executed exactly once. The callback will block later work in the stream until it is finished.</p>
<p>The callback may be passed ::cudaSuccess or an error code.  In the event of a device error, all subsequently executed callbacks will receive an appropriate ::cudaError_t.</p>
<p>Callbacks must not make any CUDA API calls.  Attempting to use CUDA APIs will result in ::cudaErrorNotPermitted.  Callbacks must not perform any synchronization that may depend on outstanding device work or other callbacks that are not mandated to run earlier.  Callbacks without a mandated order (in independent streams) execute in undefined order and may be serialized.</p>
<p>For the purposes of Unified Memory, callback execution makes a number of guarantees: &lt;ul&gt; &lt;li&gt;The callback stream is considered idle for the duration of the callback.  Thus, for example, a callback may always use memory attached to the callback stream.&lt;/li&gt; &lt;li&gt;The start of execution of a callback has the same effect as synchronizing an event recorded in the same stream immediately prior to the callback.  It thus synchronizes streams which have been &quot;joined&quot; prior to the callback.&lt;/li&gt; &lt;li&gt;Adding device work to any stream does not have the effect of making the stream active until all preceding callbacks have executed.  Thus, for example, a callback might use global attached memory even if work has been added to another stream, if it has been properly ordered with an event.&lt;/li&gt; &lt;li&gt;Completion of a callback does not cause a stream to become active except as described above.  The callback stream will remain idle if no device work follows the callback, and will remain idle across consecutive callbacks without device work in between.  Thus, for example, stream synchronization can be done by signaling from a callback at the end of the stream.&lt;/li&gt; &lt;/ul&gt;</p>
<p>param stream   - Stream to add callback to param callback - The function to call once preceding stream operations are complete param userData - User specified data to be passed to the callback function param flags    - Reserved for future use, must be 0</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle, ::cudaErrorNotSupported note_null_stream notefnerr</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamQuery, ::cudaStreamSynchronize, ::cudaStreamWaitEvent, ::cudaStreamDestroy, ::cudaMallocManaged, ::cudaStreamAttachMemAsync </p>
<p>brief Waits for stream tasks to complete</p>
<p>Blocks until p stream has completed all operations. If the ::cudaDeviceScheduleBlockingSync flag was set for this device, the host thread will block until the stream is finished with all of its tasks.</p>
<p>param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle notefnerr</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamQuery, ::cudaStreamWaitEvent, ::cudaStreamAddCallback, ::cudaStreamDestroy </p>
<p>brief Queries an asynchronous stream for completion status</p>
<p>Returns ::cudaSuccess if all operations in p stream have completed, or ::cudaErrorNotReady if not.</p>
<p>For the purposes of Unified Memory, a return value of ::cudaSuccess is equivalent to having called ::cudaStreamSynchronize().</p>
<p>param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorNotReady, ::cudaErrorInvalidResourceHandle notefnerr</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamWaitEvent, ::cudaStreamSynchronize, ::cudaStreamAddCallback, ::cudaStreamDestroy </p>
<p>brief Attach memory to a stream asynchronously</p>
<p>Enqueues an operation in p stream to specify stream association of p length bytes of memory starting from p devPtr. This function is a stream-ordered operation, meaning that it is dependent on, and will only take effect when, previous work in stream has completed. Any previous association is automatically replaced.</p>
<p>p devPtr must point to an address within managed memory space declared using the __managed__ keyword or allocated with ::cudaMallocManaged.</p>
<p>p length must be zero, to indicate that the entire allocation's stream association is being changed.  Currently, it's not possible to change stream association for a portion of an allocation. The default value for p length is zero.</p>
<p>The stream association is specified using p flags which must be one of ::cudaMemAttachGlobal, ::cudaMemAttachHost or ::cudaMemAttachSingle. The default value for p flags is ::cudaMemAttachSingle If the ::cudaMemAttachGlobal flag is specified, the memory can be accessed by any stream on any device. If the ::cudaMemAttachHost flag is specified, the program makes a guarantee that it won't access the memory on the device from any stream on a device that has a zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess. If the ::cudaMemAttachSingle flag is specified and p stream is associated with a device that has a zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess, the program makes a guarantee that it will only access the memory on the device from p stream. It is illegal to attach singly to the NULL stream, because the NULL stream is a virtual global stream and not a specific stream. An error will be returned in this case.</p>
<p>When memory is associated with a single stream, the Unified Memory system will allow CPU access to this memory region so long as all operations in p stream have completed, regardless of whether other streams are active. In effect, this constrains exclusive ownership of the managed memory region by an active GPU to per-stream activity instead of whole-GPU activity.</p>
<p>Accessing memory on the device from streams that are not associated with it will produce undefined results. No error checking is performed by the Unified Memory system to ensure that kernels launched into other streams do not access this region.</p>
<p>It is a program's responsibility to order calls to ::cudaStreamAttachMemAsync via events, synchronization or other means to ensure legal access to memory at all times. Data visibility and coherency will be changed appropriately for all kernels which follow a stream-association change.</p>
<p>If p stream is destroyed while data is associated with it, the association is removed and the association reverts to the default visibility of the allocation as specified at ::cudaMallocManaged. For __managed__ variables, the default association is always ::cudaMemAttachGlobal. Note that destroying a stream is an asynchronous operation, and as a result, the change to default association won't happen until all work in the stream has completed.</p>
<p>param stream  - Stream in which to enqueue the attach operation param devPtr  - Pointer to memory (must be a pointer to managed memory) param length  - Length of memory (must be zero, defaults to zero) param flags   - Must be one of ::cudaMemAttachGlobal, ::cudaMemAttachHost or ::cudaMemAttachSingle (defaults to ::cudaMemAttachSingle)</p>
<p>return ::cudaSuccess, ::cudaErrorNotReady, ::cudaErrorInvalidValue ::cudaErrorInvalidResourceHandle notefnerr</p>
<p>sa ::cudaStreamCreate, ::cudaStreamCreateWithFlags, ::cudaStreamWaitEvent, ::cudaStreamSynchronize, ::cudaStreamAddCallback, ::cudaStreamDestroy, ::cudaMallocManaged </p>
<pre>@}
END CUDART_STREAM

\defgroup CUDART_EVENT Event Management

___MANBRIEF___ event management functions of the CUDA runtime API
(___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the event management functions of the CUDA runtime
application programming interface.

@{


\brief Creates an event object

Creates an event object using ::cudaEventDefault.

\param event - Newly created event

\return
::cudaSuccess,
::cudaErrorInitializationError,
::cudaErrorInvalidValue,
::cudaErrorLaunchFailure,
::cudaErrorMemoryAllocation
\notefnerr

\sa \ref ::cudaEventCreate(cudaEvent_t*, unsigned int) &quot;cudaEventCreate (C++ API)&quot;,
::cudaEventCreateWithFlags, ::cudaEventRecord, ::cudaEventQuery,
::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime,
::cudaStreamWaitEvent
</pre>
<pre>
\brief Creates an event object with the specified flags

Creates an event object with the specified flags. Valid flags include:
- ::cudaEventDefault: Default event creation flag.
- ::cudaEventBlockingSync: Specifies that event should use blocking
  synchronization. A host thread that uses ::cudaEventSynchronize() to wait
  on an event created with this flag will block until the event actually
  completes.
- ::cudaEventDisableTiming: Specifies that the created event does not need
  to record timing data.  Events created with this flag specified and
  the ::cudaEventBlockingSync flag not specified will provide the best
  performance when used with ::cudaStreamWaitEvent() and ::cudaEventQuery().
- ::cudaEventInterprocess: Specifies that the created event may be used as an
  interprocess event by ::cudaIpcGetEventHandle(). ::cudaEventInterprocess must
  be specified along with ::cudaEventDisableTiming.

\param event - Newly created event
\param flags - Flags for new event

\return
::cudaSuccess,
::cudaErrorInitializationError,
::cudaErrorInvalidValue,
::cudaErrorLaunchFailure,
::cudaErrorMemoryAllocation
\notefnerr

\sa \ref ::cudaEventCreate(cudaEvent_t*) &quot;cudaEventCreate (C API)&quot;,
::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime,
::cudaStreamWaitEvent
</pre>
<pre>
\brief Records an event

Records an event. See note about NULL stream behavior. Since operation
is asynchronous, ::cudaEventQuery() or ::cudaEventSynchronize() must
be used to determine when the event has actually been recorded.

If ::cudaEventRecord() has previously been called on \p event, then this
call will overwrite any existing state in \p event.  Any subsequent calls
which examine the status of \p event will only examine the completion of
this most recent call to ::cudaEventRecord().

\param event  - Event to record
\param stream - Stream in which to record event

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInitializationError,
::cudaErrorInvalidResourceHandle,
::cudaErrorLaunchFailure
\note_null_stream
\notefnerr

\sa \ref ::cudaEventCreate(cudaEvent_t*) &quot;cudaEventCreate (C API)&quot;,
::cudaEventCreateWithFlags, ::cudaEventQuery,
::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime,
::cudaStreamWaitEvent
</pre>
<pre>
\brief Queries an event's status

Query the status of all device work preceding the most recent call to
::cudaEventRecord() (in the appropriate compute streams, as specified by the
arguments to ::cudaEventRecord()).

If this work has successfully been completed by the device, or if
::cudaEventRecord() has not been called on \p event, then ::cudaSuccess is
returned. If this work has not yet been completed by the device then
::cudaErrorNotReady is returned.

For the purposes of Unified Memory, a return value of ::cudaSuccess
is equivalent to having called ::cudaEventSynchronize().

\param event - Event to query

\return
::cudaSuccess,
::cudaErrorNotReady,
::cudaErrorInitializationError,
::cudaErrorInvalidValue,
::cudaErrorInvalidResourceHandle,
::cudaErrorLaunchFailure
\notefnerr

\sa \ref ::cudaEventCreate(cudaEvent_t*) &quot;cudaEventCreate (C API)&quot;,
::cudaEventCreateWithFlags, ::cudaEventRecord,
::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventElapsedTime
</pre>
<pre>
\brief Waits for an event to complete

Wait until the completion of all device work preceding the most recent
call to ::cudaEventRecord() (in the appropriate compute streams, as specified
by the arguments to ::cudaEventRecord()).

If ::cudaEventRecord() has not been called on \p event, ::cudaSuccess is
returned immediately.

Waiting for an event that was created with the ::cudaEventBlockingSync
flag will cause the calling CPU thread to block until the event has
been completed by the device.  If the ::cudaEventBlockingSync flag has
not been set, then the CPU thread will busy-wait until the event has
been completed by the device.

\param event - Event to wait for

\return
::cudaSuccess,
::cudaErrorInitializationError,
::cudaErrorInvalidValue,
::cudaErrorInvalidResourceHandle,
::cudaErrorLaunchFailure
\notefnerr

\sa \ref ::cudaEventCreate(cudaEvent_t*) &quot;cudaEventCreate (C API)&quot;,
::cudaEventCreateWithFlags, ::cudaEventRecord,
::cudaEventQuery, ::cudaEventDestroy, ::cudaEventElapsedTime
</pre>
<pre>
\brief Destroys an event object

Destroys the event specified by \p event.

In case \p event has been recorded but has not yet been completed
when ::cudaEventDestroy() is called, the function will return immediately and
the resources associated with \p event will be released automatically once
the device has completed \p event.

\param event - Event to destroy

\return
::cudaSuccess,
::cudaErrorInitializationError,
::cudaErrorInvalidValue,
::cudaErrorLaunchFailure
\notefnerr

\sa \ref ::cudaEventCreate(cudaEvent_t*) &quot;cudaEventCreate (C API)&quot;,
::cudaEventCreateWithFlags, ::cudaEventQuery,
::cudaEventSynchronize, ::cudaEventRecord, ::cudaEventElapsedTime
</pre>
<pre>
\brief Computes the elapsed time between events

Computes the elapsed time between two events (in milliseconds with a
resolution of around 0.5 microseconds).

If either event was last recorded in a non-NULL stream, the resulting time
may be greater than expected (even if both used the same stream handle). This
happens because the ::cudaEventRecord() operation takes place asynchronously
and there is no guarantee that the measured latency is actually just between
the two events. Any number of other different stream operations could execute
in between the two measured events, thus altering the timing in a significant
way.

If ::cudaEventRecord() has not been called on either event, then
::cudaErrorInvalidResourceHandle is returned. If ::cudaEventRecord() has been
called on both events but one or both of them has not yet been completed
(that is, ::cudaEventQuery() would return ::cudaErrorNotReady on at least one
of the events), ::cudaErrorNotReady is returned. If either event was created
with the ::cudaEventDisableTiming flag, then this function will return
::cudaErrorInvalidResourceHandle.

\param ms    - Time between \p start and \p end in ms
\param start - Starting event
\param end   - Ending event

\return
::cudaSuccess,
::cudaErrorNotReady,
::cudaErrorInvalidValue,
::cudaErrorInitializationError,
::cudaErrorInvalidResourceHandle,
::cudaErrorLaunchFailure
\notefnerr

\sa \ref ::cudaEventCreate(cudaEvent_t*) &quot;cudaEventCreate (C API)&quot;,
::cudaEventCreateWithFlags, ::cudaEventQuery,
::cudaEventSynchronize, ::cudaEventDestroy, ::cudaEventRecord
</pre>
<p>@} END CUDART_EVENT</p>
<p>defgroup CUDART_EXECUTION Execution Control</p>
<p>___MANBRIEF___ execution control functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the execution control functions of the CUDA runtime application programming interface.</p>
<p>Some functions have overloaded C++ API template versions documented separately in the ref CUDART_HIGHLEVEL &quot;C++ API Routines&quot; module.</p>
<p>@{ </p>
<pre>
\brief Launches a device function

The function invokes kernel \p func on \p gridDim (\p gridDim.x Ã— \p gridDim.y
Ã— \p gridDim.z) grid of blocks. Each block contains \p blockDim (\p blockDim.x Ã—
\p blockDim.y Ã— \p blockDim.z) threads.

If the kernel has N parameters the \p args should point to array of N pointers.
Each pointer, from &lt;tt&gt;args[0]&lt;/tt&gt; to &lt;tt&gt;args[N - 1]&lt;/tt&gt;, point to the region
of memory from which the actual parameter will be copied.

For templated functions, pass the function symbol as follows:
func_name&lt;template_arg_0,...,template_arg_N&gt;

\p sharedMem sets the amount of dynamic shared memory that will be available to
each thread block.

\p stream specifies a stream the invocation is associated to.

\param func        - Device function symbol
\param gridDim     - Grid dimentions
\param blockDim    - Block dimentions
\param args        - Arguments
\param sharedMem   - Shared memory
\param stream      - Stream identifier

\return
::cudaSuccess,
::cudaErrorInvalidDeviceFunction,
::cudaErrorInvalidConfiguration,
::cudaErrorLaunchFailure,
::cudaErrorLaunchTimeout,
::cudaErrorLaunchOutOfResources,
::cudaErrorSharedObjectInitFailed
\note_null_stream
\notefnerr

\ref ::cudaLaunchKernel(const T *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) &quot;cudaLaunchKernel (C++ API)&quot;
</pre>
<p>brief Sets the preferred cache configuration for a device function</p>
<p>On devices where the L1 cache and shared memory use the same hardware resources, this sets through p cacheConfig the preferred cache configuration for the function specified via p func. This is only a preference. The runtime will use the requested configuration if possible, but it is free to choose a different configuration if required to execute p func.</p>
<p>p func is a device function symbol and must be declared as a c __global__ function. If the specified function does not exist, then ::cudaErrorInvalidDeviceFunction is returned. For templated functions, pass the function symbol as follows: func_name&lt;template_arg_0,...,template_arg_N&gt;</p>
<p>This setting does nothing on devices where the size of the L1 cache and shared memory are fixed.</p>
<p>Launching a kernel with a different preference than the most recent preference setting may insert a device-side synchronization point.</p>
<p>The supported cache configurations are:</p>
<ul class="simple"><li>::cudaFuncCachePreferNone: no preference for shared memory or L1 (default)</li>
<li>::cudaFuncCachePreferShared: prefer larger shared memory and smaller L1 cache</li>
<li>::cudaFuncCachePreferL1: prefer larger L1 cache and smaller shared memory</li>
<li>::cudaFuncCachePreferEqual: prefer equal size L1 cache and shared memory</li>
</ul>
<p>param func        - Device function symbol param cacheConfig - Requested cache configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInitializationError, ::cudaErrorInvalidDeviceFunction notefnerr note_string_api_deprecation2</p>
<p>sa ::cudaConfigureCall, ref ::cudaFuncSetCacheConfig(T<em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C++ API)&quot;, ref ::cudaFuncGetAttributes(struct cudaFuncAttributes</em>, const void<em>) &quot;cudaFuncGetAttributes (C API)&quot;, ref ::cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) &quot;cudaLaunchKernel (C API)&quot;, ::cudaSetDoubleForDevice, ::cudaSetDoubleForHost, ref ::cudaSetupArgument(const void</em>, size_t, size_t) &quot;cudaSetupArgument (C API)&quot;, ::cudaThreadGetCacheConfig, ::cudaThreadSetCacheConfig </p>
<p>brief Sets the shared memory configuration for a device function</p>
<p>On devices with configurable shared memory banks, this function will force all subsequent launches of the specified device function to have the given shared memory bank size configuration. On any given launch of the function, the shared memory configuration of the device will be temporarily changed if needed to suit the function's preferred configuration. Changes in shared memory configuration between subsequent launches of functions, may introduce a device side synchronization point.</p>
<p>Any per-function setting of shared memory bank size set via ::cudaFuncSetSharedMemConfig will override the device wide setting set by ::cudaDeviceSetSharedMemConfig.</p>
<p>Changing the shared memory bank size will not increase shared memory usage or affect occupancy of kernels, but may have major effects on performance. Larger bank sizes will allow for greater potential bandwidth to shared memory, but will change what kinds of accesses to shared memory will result in bank conflicts.</p>
<p>This function will do nothing on devices with fixed shared memory bank size.</p>
<p>For templated functions, pass the function symbol as follows: func_name&lt;template_arg_0,...,template_arg_N&gt;</p>
<p>The supported bank configurations are:</p>
<ul class="simple"><li>::cudaSharedMemBankSizeDefault: use the device's shared memory configuration when launching this function.</li>
<li>::cudaSharedMemBankSizeFourByte: set shared memory bank width to be four bytes natively when launching this function.</li>
<li>::cudaSharedMemBankSizeEightByte: set shared memory bank width to be eight bytes natively when launching this function.</li>
</ul>
<p>param func   - Device function symbol param config - Requested shared memory configuration</p>
<p>return ::cudaSuccess, ::cudaErrorInitializationError, ::cudaErrorInvalidDeviceFunction, ::cudaErrorInvalidValue, notefnerr note_string_api_deprecation2</p>
<p>sa ::cudaConfigureCall, ::cudaDeviceSetSharedMemConfig, ::cudaDeviceGetSharedMemConfig, ::cudaDeviceSetCacheConfig, ::cudaDeviceGetCacheConfig, ::cudaFuncSetCacheConfig </p>
<p>brief Find out attributes for a given function</p>
<p>This function obtains the attributes of a function specified via p func. p func is a device function symbol and must be declared as a c __global__ function. The fetched attributes are placed in p attr. If the specified function does not exist, then ::cudaErrorInvalidDeviceFunction is returned. For templated functions, pass the function symbol as follows: func_name&lt;template_arg_0,...,template_arg_N&gt;</p>
<p>Note that some function attributes such as ref ::cudaFuncAttributes::maxThreadsPerBlock &quot;maxThreadsPerBlock&quot; may vary based on the device that is currently being used.</p>
<p>param attr - Return pointer to function's attributes param func - Device function symbol</p>
<p>return ::cudaSuccess, ::cudaErrorInitializationError, ::cudaErrorInvalidDeviceFunction notefnerr note_string_api_deprecation2</p>
<p>sa ::cudaConfigureCall, ref ::cudaFuncSetCacheConfig(const void<em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;, ref ::cudaFuncGetAttributes(struct cudaFuncAttributes</em>, T<em>) &quot;cudaFuncGetAttributes (C++ API)&quot;, ref ::cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) &quot;cudaLaunchKernel (C API)&quot;, ::cudaSetDoubleForDevice, ::cudaSetDoubleForHost, ref ::cudaSetupArgument(const void</em>, size_t, size_t) &quot;cudaSetupArgument (C API)&quot; </p>
<pre>
\brief Converts a double argument to be executed on a device

\param d - Double to convert

\deprecated This function is deprecated as of CUDA 7.5

Converts the double value of \p d to an internal float representation if
the device does not support double arithmetic. If the device does natively
support doubles, then this function does nothing.

\return
::cudaSuccess
\notefnerr

\ref ::cudaLaunch(const void*) &quot;cudaLaunch (C API)&quot;,
\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;,
\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) &quot;cudaFuncGetAttributes (C API)&quot;,
::cudaSetDoubleForHost,
\ref ::cudaSetupArgument(const void*, size_t, size_t) &quot;cudaSetupArgument (C API)&quot;
</pre>
<pre>
\brief Converts a double argument after execution on a device

\deprecated This function is deprecated as of CUDA 7.5

Converts the double value of \p d from a potentially internal float
representation if the device does not support double arithmetic. If the
device does natively support doubles, then this function does nothing.

\param d - Double to convert

\return
::cudaSuccess
\notefnerr

\ref ::cudaLaunch(const void*) &quot;cudaLaunch (C API)&quot;,
\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;,
\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) &quot;cudaFuncGetAttributes (C API)&quot;,
::cudaSetDoubleForDevice,
\ref ::cudaSetupArgument(const void*, size_t, size_t) &quot;cudaSetupArgument (C API)&quot;
</pre>
@} END CUDART_EXECUTION<pre>
\defgroup CUDART_OCCUPANCY Occupancy

___MANBRIEF___ occupancy calculation functions of the CUDA runtime API
(___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the occupancy calculation functions of the CUDA runtime
application programming interface.

Besides the occupancy calculator functions
(\ref ::cudaOccupancyMaxActiveBlocksPerMultiprocessor and \ref ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags),
there are also C++ only occupancy-based launch configuration functions documented in
\ref CUDART_HIGHLEVEL &quot;C++ API Routines&quot; module.

See
\ref ::cudaOccupancyMaxPotentialBlockSize(int*, int*, T, size_t, int) &quot;cudaOccupancyMaxPotentialBlockSize (C++ API)&quot;,
\ref ::cudaOccupancyMaxPotentialBlockSizeWithFlags(int*, int*, T, size_t, int, unsigned int) &quot;cudaOccupancyMaxPotentialBlockSize (C++ API)&quot;,
\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMem(int*, int*, T, UnaryFunction, int) &quot;cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API)&quot;,
\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int*, int*, T, UnaryFunction, int, unsigned int) &quot;cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API)&quot;,

@{


\brief Returns occupancy for a device function

Returns in \p *numBlocks the maximum number of active blocks per
streaming multiprocessor for the device function.

\param numBlocks       - Returned occupancy
\param func            - Kernel function for which occupancy is calculated
\param blockSize       - Block size the kernel is intended to be launched with
\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes

\return
::cudaSuccess,
::cudaErrorCudartUnloading,
::cudaErrorInitializationError,
::cudaErrorInvalidDevice,
::cudaErrorInvalidDeviceFunction,
::cudaErrorInvalidValue,
::cudaErrorUnknown,
\notefnerr

\sa ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags,
\ref ::cudaOccupancyMaxPotentialBlockSize(int*, int*, T, size_t, int) &quot;cudaOccupancyMaxPotentialBlockSize (C++ API)&quot;,
\ref ::cudaOccupancyMaxPotentialBlockSizeWithFlags(int*, int*, T, size_t, int, unsigned int) &quot;cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API)&quot;,
\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMem(int*, int*, T, UnaryFunction, int) &quot;cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API)&quot;
\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int*, int*, T, UnaryFunction, int, unsigned int) &quot;cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API)&quot;
</pre>
<pre>
\brief Returns occupancy for a device function with the specified flags

Returns in \p *numBlocks the maximum number of active blocks per
streaming multiprocessor for the device function.

The \p flags parameter controls how special cases are handled. Valid flags include:

- ::cudaOccupancyDefault: keeps the default behavior as
  ::cudaOccupancyMaxActiveBlocksPerMultiprocessor

- ::cudaOccupancyDisableCachingOverride: This flag suppresses the default behavior
  on platform where global caching affects occupancy. On such platforms, if caching
  is enabled, but per-block SM resource usage would result in zero occupancy, the
  occupancy calculator will calculate the occupancy as if caching is disabled.
  Setting this flag makes the occupancy calculator to return 0 in such cases.
  More information can be found about this feature in the &quot;Unified L1/Texture Cache&quot;
  section of the Maxwell tuning guide.

\param numBlocks       - Returned occupancy
\param func            - Kernel function for which occupancy is calculated
\param blockSize       - Block size the kernel is intended to be launched with
\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes
\param flags           - Requested behavior for the occupancy calculator

\return
::cudaSuccess,
::cudaErrorCudartUnloading,
::cudaErrorInitializationError,
::cudaErrorInvalidDevice,
::cudaErrorInvalidDeviceFunction,
::cudaErrorInvalidValue,
::cudaErrorUnknown,
\notefnerr

\sa ::cudaOccupancyMaxActiveBlocksPerMultiprocessor,
\ref ::cudaOccupancyMaxPotentialBlockSize(int*, int*, T, size_t, int) &quot;cudaOccupancyMaxPotentialBlockSize (C++ API)&quot;,
\ref ::cudaOccupancyMaxPotentialBlockSizeWithFlags(int*, int*, T, size_t, int, unsigned int) &quot;cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API)&quot;,
\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMem(int*, int*, T, UnaryFunction, int) &quot;cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API)&quot;
\ref ::cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int*, int*, T, UnaryFunction, int, unsigned int) &quot;cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API)&quot;
</pre>
<p>@} END CUDA_OCCUPANCY</p>
<p>defgroup CUDART_EXECUTION_DEPRECATED Execution Control <a class="reference internal" href="#DEPRECATED">DEPRECATED</a></p>
<p>___MANBRIEF___ deprecated execution control functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the deprecated execution control functions of the CUDA runtime application programming interface.</p>
<p>Some functions have overloaded C++ API template versions documented separately in the ref CUDART_HIGHLEVEL &quot;C++ API Routines&quot; module.</p>
<p>@{</p>
<p>brief Configure a device-launch</p>
<p>deprecated This function is deprecated as of CUDA 7.0</p>
<p>Specifies the grid and block dimensions for the device call to be executed similar to the execution configuration syntax. ::cudaConfigureCall() is stack based. Each call pushes data on top of an execution stack. This data contains the dimension for the grid and thread blocks, together with any arguments for the call.</p>
<p>param gridDim   - Grid dimensions param blockDim  - Block dimensions param sharedMem - Shared memory param stream    - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidConfiguration note_null_stream notefnerr</p>
<p>ref ::cudaLaunchKernel(const void <em>func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) &quot;cudaLaunchKernel (C API)&quot;, ref ::cudaFuncSetCacheConfig(const void</em>, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;, ref ::cudaFuncGetAttributes(struct cudaFuncAttributes<em>, const void</em>) &quot;cudaFuncGetAttributes (C API)&quot;, ref ::cudaLaunch(const void<em>) &quot;cudaLaunch (C API)&quot;, ::cudaSetDoubleForDevice, ::cudaSetDoubleForHost, ref ::cudaSetupArgument(const void</em>, size_t, size_t) &quot;cudaSetupArgument (C API)&quot;, </p>
<pre>
\brief Configure a device launch

\deprecated This function is deprecated as of CUDA 7.0

Pushes \p size bytes of the argument pointed to by \p arg at \p offset
bytes from the start of the parameter passing area, which starts at
offset 0. The arguments are stored in the top of the execution stack.
\ref ::cudaSetupArgument(const void*, size_t, size_t) &quot;cudaSetupArgument()&quot;
must be preceded by a call to ::cudaConfigureCall().

\param arg    - Argument to push for a kernel launch
\param size   - Size of argument
\param offset - Offset in argument stack to push new arg

\return
::cudaSuccess
\notefnerr

\ref ::cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) &quot;cudaLaunchKernel (C API)&quot;,
\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;,
\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) &quot;cudaFuncGetAttributes (C API)&quot;,
\ref ::cudaLaunch(const void*) &quot;cudaLaunch (C API)&quot;,
::cudaSetDoubleForDevice,
::cudaSetDoubleForHost,
\ref ::cudaSetupArgument(T, size_t) &quot;cudaSetupArgument (C++ API)&quot;,
</pre>
<pre>
\brief Launches a device function

\deprecated This function is deprecated as of CUDA 7.0

Launches the function \p func on the device. The parameter \p func must
be a device function symbol. The parameter specified by \p func must be
declared as a \p __global__ function. For templated functions, pass the
function symbol as follows: func_name&lt;template_arg_0,...,template_arg_N&gt;
\ref ::cudaLaunch(const void*) &quot;cudaLaunch()&quot; must be preceded by a call to
::cudaConfigureCall() since it pops the data that was pushed by
::cudaConfigureCall() from the execution stack.

\param func - Device function symbol

\return
::cudaSuccess,
::cudaErrorInvalidDeviceFunction,
::cudaErrorInvalidConfiguration,
::cudaErrorLaunchFailure,
::cudaErrorLaunchTimeout,
::cudaErrorLaunchOutOfResources,
::cudaErrorSharedObjectInitFailed
\notefnerr
\note_string_api_deprecation_50

\ref ::cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream) &quot;cudaLaunchKernel (C API)&quot;,
\ref ::cudaFuncSetCacheConfig(const void*, enum cudaFuncCache) &quot;cudaFuncSetCacheConfig (C API)&quot;,
\ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const void*) &quot;cudaFuncGetAttributes (C API)&quot;,
\ref ::cudaLaunch(T*) &quot;cudaLaunch (C++ API)&quot;,
::cudaSetDoubleForDevice,
::cudaSetDoubleForHost,
\ref ::cudaSetupArgument(const void*, size_t, size_t) &quot;cudaSetupArgument (C API)&quot;,
::cudaThreadGetCacheConfig,
::cudaThreadSetCacheConfig
</pre>
<pre>@}
END CUDART_EXECUTION_DEPRECATED

\defgroup CUDART_MEMORY Memory Management

___MANBRIEF___ memory management functions of the CUDA runtime API
(___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the memory management functions of the CUDA runtime
application programming interface.

Some functions have overloaded C++ API template versions documented separately in the
\ref CUDART_HIGHLEVEL &quot;C++ API Routines&quot; module.

@{


\brief Allocates memory that will be automatically managed by the Unified Memory system

Allocates \p size bytes of managed memory on the device and returns in
\p *devPtr a pointer to the allocated memory. If the device doesn't support
allocating managed memory, ::cudaErrorNotSupported is returned. Support
for managed memory can be queried using the device attribute
::cudaDevAttrManagedMemory. The allocated memory is suitably
aligned for any kind of variable. The memory is not cleared. If \p size
is 0, ::cudaMallocManaged returns ::cudaErrorInvalidValue. The pointer
is valid on the CPU and on all GPUs in the system that support managed memory.
All accesses to this pointer must obey the Unified Memory programming model.

\p flags specifies the default stream association for this allocation.
\p flags must be one of ::cudaMemAttachGlobal or ::cudaMemAttachHost. The
default value for \p flags is ::cudaMemAttachGlobal.
If ::cudaMemAttachGlobal is specified, then this memory is accessible from
any stream on any device. If ::cudaMemAttachHost is specified, then the
allocation should not be accessed from devices that have a zero value for the
device attribute ::cudaDevAttrConcurrentManagedAccess; an explicit call to
::cudaStreamAttachMemAsync will be required to enable access on such devices.

If the association is later changed via ::cudaStreamAttachMemAsync to
a single stream, the default association, as specifed during ::cudaMallocManaged,
is restored when that stream is destroyed. For __managed__ variables, the
default association is always ::cudaMemAttachGlobal. Note that destroying a
stream is an asynchronous operation, and as a result, the change to default
association won't happen until all work in the stream has completed.

Memory allocated with ::cudaMallocManaged should be released with ::cudaFree.

Device memory oversubscription is possible for GPUs that have a non-zero value for the
device attribute ::cudaDevAttrConcurrentManagedAccess. Managed memory on
such GPUs may be evicted from device memory to host memory at any time by the Unified
Memory driver in order to make room for other allocations.

In a multi-GPU system where all GPUs have a non-zero value for the device attribute
::cudaDevAttrConcurrentManagedAccess, managed memory may not be populated when this
API returns and instead may be populated on access. In such systems, managed memory can
migrate to any processor's memory at any time. The Unified Memory driver will employ heuristics to
maintain data locality and prevent excessive page faults to the extent possible. The application
can also guide the driver about memory usage patterns via ::cudaMemAdvise. The application
can also explicitly migrate memory to a desired processor's memory via
::cudaMemPrefetchAsync.

In a multi-GPU system where all of the GPUs have a zero value for the device attribute
::cudaDevAttrConcurrentManagedAccess and all the GPUs have peer-to-peer support
with each other, the physical storage for managed memory is created on the GPU which is active
at the time ::cudaMallocManaged is called. All other GPUs will reference the data at reduced
bandwidth via peer mappings over the PCIe bus. The Unified Memory driver does not migrate
memory among such GPUs.

In a multi-GPU system where not all GPUs have peer-to-peer support with each other and
where the value of the device attribute ::cudaDevAttrConcurrentManagedAccess
is zero for at least one of those GPUs, the location chosen for physical storage of managed
memory is system-dependent.
- On Linux, the location chosen will be device memory as long as the current set of active
contexts are on devices that either have peer-to-peer support with each other or have a
non-zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess.
If there is an active context on a GPU that does not have a non-zero value for that device
attribute and it does not have peer-to-peer support with the other devices that have active
contexts on them, then the location for physical storage will be 'zero-copy' or host memory.
Note that this means that managed memory that is located in device memory is migrated to
host memory if a new context is created on a GPU that doesn't have a non-zero value for
the device attribute and does not support peer-to-peer with at least one of the other devices
that has an active context. This in turn implies that context creation may fail if there is
insufficient host memory to migrate all managed allocations.
- On Windows, the physical storage is always created in 'zero-copy' or host memory.
All GPUs will reference the data at reduced bandwidth over the PCIe bus. In these
circumstances, use of the environment variable CUDA_VISIBLE_DEVICES is recommended to
restrict CUDA to only use those GPUs that have peer-to-peer support.
Alternatively, users can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non-zero
value to force the driver to always use device memory for physical storage.
When this environment variable is set to a non-zero value, all devices used in
that process that support managed memory have to be peer-to-peer compatible
with each other. The error ::cudaErrorInvalidDevice will be returned if a device
that supports managed memory is used and it is not peer-to-peer compatible with
any of the other managed memory supporting devices that were previously used in
that process, even if ::cudaDeviceReset has been called on those devices. These
environment variables are described in the CUDA programming guide under the
&quot;CUDA environment variables&quot; section.

\param devPtr - Pointer to allocated device memory
\param size   - Requested allocation size in bytes
\param flags  - Must be either ::cudaMemAttachGlobal or ::cudaMemAttachHost (defaults to ::cudaMemAttachGlobal)

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
::cudaErrorNotSupported
::cudaErrorInvalidValue

\sa ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray, ::cudaFreeArray,
::cudaMalloc3D, ::cudaMalloc3DArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc, ::cudaDeviceGetAttribute, ::cudaStreamAttachMemAsync
</pre>
<pre>
\brief Allocate memory on the device

Allocates \p size bytes of linear memory on the device and returns in
\p *devPtr a pointer to the allocated memory. The allocated memory is
suitably aligned for any kind of variable. The memory is not cleared.
::cudaMalloc() returns ::cudaErrorMemoryAllocation in case of failure.

The device version of ::cudaFree cannot be used with a \p *devPtr
allocated using the host API, and vice versa.

\param devPtr - Pointer to allocated device memory
\param size   - Requested allocation size in bytes

\return
::cudaSuccess,
::cudaErrorMemoryAllocation

\sa ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray, ::cudaFreeArray,
::cudaMalloc3D, ::cudaMalloc3DArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc
</pre>
<pre>
\brief Allocates page-locked memory on the host

Allocates \p size bytes of host memory that is page-locked and accessible
to the device. The driver tracks the virtual memory ranges allocated with
this function and automatically accelerates calls to functions such as
::cudaMemcpy*(). Since the memory can be accessed directly by the device,
it can be read or written with much higher bandwidth than pageable memory
obtained with functions such as ::malloc(). Allocating excessive amounts of
memory with ::cudaMallocHost() may degrade system performance, since it
reduces the amount of memory available to the system for paging. As a
result, this function is best used sparingly to allocate staging areas for
data exchange between host and device.

\param ptr  - Pointer to allocated host memory
\param size - Requested allocation size in bytes

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
\notefnerr

\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaMallocArray, ::cudaMalloc3D,
::cudaMalloc3DArray, ::cudaHostAlloc, ::cudaFree, ::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t, unsigned int) &quot;cudaMallocHost (C++ API)&quot;,
::cudaFreeHost, ::cudaHostAlloc
</pre>
<pre>
\brief Allocates pitched memory on the device

Allocates at least \p width (in bytes) * \p height bytes of linear memory
on the device and returns in \p *devPtr a pointer to the allocated memory.
The function may pad the allocation to ensure that corresponding pointers
in any given row will continue to meet the alignment requirements for
coalescing as the address is updated from row to row. The pitch returned in
\p *pitch by ::cudaMallocPitch() is the width in bytes of the allocation.
The intended usage of \p pitch is as a separate parameter of the allocation,
used to compute addresses within the 2D array. Given the row and column of
an array element of type \p T, the address is computed as:
\code
   T* pElement = (T*)((char*)BaseAddress + Row * pitch) + Column;
  \endcode

For allocations of 2D arrays, it is recommended that programmers consider
performing pitch allocations using ::cudaMallocPitch(). Due to pitch
alignment restrictions in the hardware, this is especially true if the
application will be performing 2D memory copies between different regions
of device memory (whether linear memory or CUDA arrays).

\param devPtr - Pointer to allocated pitched device memory
\param pitch  - Pitch for allocation
\param width  - Requested pitched allocation width (in bytes)
\param height - Requested pitched allocation height

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
\notefnerr

\sa ::cudaMalloc, ::cudaFree, ::cudaMallocArray, ::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaMalloc3D, ::cudaMalloc3DArray,
::cudaHostAlloc
</pre>
<pre>
\brief Allocate an array on the device

Allocates a CUDA array according to the ::cudaChannelFormatDesc structure
\p desc and returns a handle to the new CUDA array in \p *array.

The ::cudaChannelFormatDesc is defined as:
\code
   struct cudaChannelFormatDesc {
       int x, y, z, w;
   enum cudaChannelFormatKind f;
   };
   \endcode
where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,
::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.

The \p flags parameter enables different options to be specified that affect
the allocation, as follows.
- ::cudaArrayDefault: This flag's value is defined to be 0 and provides default array allocation
- ::cudaArraySurfaceLoadStore: Allocates an array that can be read from or written to using a surface reference
- ::cudaArrayTextureGather: This flag indicates that texture gather operations will be performed on the array.

\p width and \p height must meet certain size requirements. See ::cudaMalloc3DArray() for more details.

\param array  - Pointer to allocated array in device memory
\param desc   - Requested channel format
\param width  - Requested array allocation width
\param height - Requested array allocation height
\param flags  - Requested properties of allocated array

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
\notefnerr

\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaMalloc3D, ::cudaMalloc3DArray,
::cudaHostAlloc
</pre>
<pre>
\brief Frees memory on the device

Frees the memory space pointed to by \p devPtr, which must have been
returned by a previous call to ::cudaMalloc() or ::cudaMallocPitch().
Otherwise, or if ::cudaFree(\p devPtr) has already been called before,
an error is returned. If \p devPtr is 0, no operation is performed.
::cudaFree() returns ::cudaErrorInvalidDevicePointer in case of failure.

The device version of ::cudaFree cannot be used with a \p *devPtr
allocated using the host API, and vice versa.

\param devPtr - Device pointer to memory to free

\return
::cudaSuccess,
::cudaErrorInvalidDevicePointer,
::cudaErrorInitializationError
\notefnerr

\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaMallocArray, ::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaMalloc3D, ::cudaMalloc3DArray,
::cudaHostAlloc
</pre>
<pre>
\brief Frees page-locked memory

Frees the memory space pointed to by \p hostPtr, which must have been
returned by a previous call to ::cudaMallocHost() or ::cudaHostAlloc().

\param ptr - Pointer to memory to free

\return
::cudaSuccess,
::cudaErrorInitializationError
\notefnerr

\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray,
::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaMalloc3D, ::cudaMalloc3DArray, ::cudaHostAlloc
</pre>
<pre>
\brief Frees an array on the device

Frees the CUDA array \p array, which must have been * returned by a
previous call to ::cudaMallocArray(). If ::cudaFreeArray(\p array) has
already been called before, ::cudaErrorInvalidValue is returned. If
\p devPtr is 0, no operation is performed.

\param array - Pointer to array to free

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInitializationError
\notefnerr

\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc
</pre>
<pre>
\brief Frees a mipmapped array on the device

Frees the CUDA mipmapped array \p mipmappedArray, which must have been
returned by a previous call to ::cudaMallocMipmappedArray().
If ::cudaFreeMipmappedArray(\p mipmappedArray) has already been called before,
::cudaErrorInvalidValue is returned.

\param mipmappedArray - Pointer to mipmapped array to free

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInitializationError
\notefnerr

\sa ::cudaMalloc, ::cudaMallocPitch, ::cudaFree, ::cudaMallocArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc
</pre>
<pre>
\brief Allocates page-locked memory on the host

Allocates \p size bytes of host memory that is page-locked and accessible
to the device. The driver tracks the virtual memory ranges allocated with
this function and automatically accelerates calls to functions such as
::cudaMemcpy(). Since the memory can be accessed directly by the device, it
can be read or written with much higher bandwidth than pageable memory
obtained with functions such as ::malloc(). Allocating excessive amounts of
pinned memory may degrade system performance, since it reduces the amount
of memory available to the system for paging. As a result, this function is
best used sparingly to allocate staging areas for data exchange between host
and device.

The \p flags parameter enables different options to be specified that affect
the allocation, as follows.
- ::cudaHostAllocDefault: This flag's value is defined to be 0 and causes
::cudaHostAlloc() to emulate ::cudaMallocHost().
- ::cudaHostAllocPortable: The memory returned by this call will be
considered as pinned memory by all CUDA contexts, not just the one that
performed the allocation.
- ::cudaHostAllocMapped: Maps the allocation into the CUDA address space.
The device pointer to the memory may be obtained by calling
::cudaHostGetDevicePointer().
- ::cudaHostAllocWriteCombined: Allocates the memory as write-combined (WC).
WC memory can be transferred across the PCI Express bus more quickly on some
system configurations, but cannot be read efficiently by most CPUs.  WC
memory is a good option for buffers that will be written by the CPU and read
by the device via mapped pinned memory or host-&gt;device transfers.

All of these flags are orthogonal to one another: a developer may allocate
memory that is portable, mapped and/or write-combined with no restrictions.

::cudaSetDeviceFlags() must have been called with the ::cudaDeviceMapHost
flag in order for the ::cudaHostAllocMapped flag to have any effect.

The ::cudaHostAllocMapped flag may be specified on CUDA contexts for devices
that do not support mapped pinned memory. The failure is deferred to
::cudaHostGetDevicePointer() because the memory may be mapped into other
CUDA contexts via the ::cudaHostAllocPortable flag.

Memory allocated by this function must be freed with ::cudaFreeHost().

\param pHost - Device pointer to allocated memory
\param size  - Requested allocation size in bytes
\param flags - Requested properties of allocated memory

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
\notefnerr

\sa ::cudaSetDeviceFlags,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost
</pre>
<p>brief Registers an existing host memory range for use by CUDA</p>
<p>Page-locks the memory range specified by p ptr and p size and maps it for the device(s) as specified by p flags. This memory range also is added to the same tracking mechanism as ::cudaHostAlloc() to automatically accelerate calls to functions such as ::cudaMemcpy(). Since the memory can be accessed directly by the device, it can be read or written with much higher bandwidth than pageable memory that has not been registered.  Page-locking excessive amounts of memory may degrade system performance, since it reduces the amount of memory available to the system for paging. As a result, this function is best used sparingly to register staging areas for data exchange between host and device.</p>
<p>The p flags parameter enables different options to be specified that affect the allocation, as follows.</p>
<ul class="simple"><li>::cudaHostRegisterDefault: On a system with unified virtual addressing, the memory will be both mapped and portable.  On a system with no unified virtual addressing, the memory will be neither mapped nor portable.</li>
<li>::cudaHostRegisterPortable: The memory returned by this call will be considered as pinned memory by all CUDA contexts, not just the one that performed the allocation.</li>
<li>::cudaHostRegisterMapped: Maps the allocation into the CUDA address space. The device pointer to the memory may be obtained by calling ::cudaHostGetDevicePointer().</li>
<li>::cudaHostRegisterIoMemory: The passed memory pointer is treated as pointing to some memory-mapped I/O space, e.g. belonging to a third-party PCIe device, and it will marked as non cache-coherent and contiguous.</li>
</ul>
<p>All of these flags are orthogonal to one another: a developer may page-lock memory that is portable or mapped with no restrictions.</p>
<p>The CUDA context must have been created with the ::cudaMapHost flag in order for the ::cudaHostRegisterMapped flag to have any effect.</p>
<p>The ::cudaHostRegisterMapped flag may be specified on CUDA contexts for devices that do not support mapped pinned memory. The failure is deferred to ::cudaHostGetDevicePointer() because the memory may be mapped into other CUDA contexts via the ::cudaHostRegisterPortable flag.</p>
<p>For devices that have a non-zero value for the device attribute ::cudaDevAttrCanUseHostPointerForRegisteredMem, the memory can also be accessed from the device using the host pointer p ptr. The device pointer returned by ::cudaHostGetDevicePointer() may or may not match the original host pointer p ptr and depends on the devices visible to the application. If all devices visible to the application have a non-zero value for the device attribute, the device pointer returned by ::cudaHostGetDevicePointer() will match the original pointer p ptr. If any device visible to the application has a zero value for the device attribute, the device pointer returned by ::cudaHostGetDevicePointer() will not match the original host pointer p ptr, but it will be suitable for use on all devices provided Unified Virtual Addressing is enabled. In such systems, it is valid to access the memory using either pointer on devices that have a non-zero value for the device attribute. Note however that such devices should access the memory using only of the two pointers and not both.</p>
<p>The memory page-locked by this function must be unregistered with ::cudaHostUnregister().</p>
<p>param ptr   - Host pointer to memory to page-lock param size  - Size in bytes of the address range to page-lock in bytes param flags - Flags for allocation request</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorMemoryAllocation, ::cudaErrorHostMemoryAlreadyRegistered notefnerr</p>
<p>sa ::cudaHostUnregister, ::cudaHostGetFlags, ::cudaHostGetDevicePointer </p>
<p>brief Unregisters a memory range that was registered with cudaHostRegister</p>
<p>Unmaps the memory range whose base address is specified by p ptr, and makes it pageable again.</p>
<p>The base address must be the same one specified to ::cudaHostRegister().</p>
<p>param ptr - Host pointer to memory to unregister</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue notefnerr</p>
<p>sa ::cudaHostUnregister </p>
<p>brief Passes back device pointer of mapped host memory allocated by cudaHostAlloc or registered by cudaHostRegister</p>
<p>Passes back the device pointer corresponding to the mapped, pinned host buffer allocated by ::cudaHostAlloc() or registered by ::cudaHostRegister().</p>
<p>::cudaHostGetDevicePointer() will fail if the ::cudaDeviceMapHost flag was not specified before deferred context creation occurred, or if called on a device that does not support mapped, pinned memory.</p>
<p>For devices that have a non-zero value for the device attribute ::cudaDevAttrCanUseHostPointerForRegisteredMem, the memory can also be accessed from the device using the host pointer p pHost. The device pointer returned by ::cudaHostGetDevicePointer() may or may not match the original host pointer p pHost and depends on the devices visible to the application. If all devices visible to the application have a non-zero value for the device attribute, the device pointer returned by ::cudaHostGetDevicePointer() will match the original pointer p pHost. If any device visible to the application has a zero value for the device attribute, the device pointer returned by ::cudaHostGetDevicePointer() will not match the original host pointer p pHost, but it will be suitable for use on all devices provided Unified Virtual Addressing is enabled. In such systems, it is valid to access the memory using either pointer on devices that have a non-zero value for the device attribute. Note however that such devices should access the memory using only of the two pointers and not both.</p>
<p>p flags provides for future releases.  For now, it must be set to 0.</p>
<p>param pDevice - Returned device pointer for mapped memory param pHost   - Requested host pointer mapping param flags   - Flags for extensions (must be 0 for now)</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorMemoryAllocation notefnerr</p>
<p>sa ::cudaSetDeviceFlags, ::cudaHostAlloc </p>
<p>brief Passes back flags used to allocate pinned host memory allocated by cudaHostAlloc</p>
<p>::cudaHostGetFlags() will fail if the input pointer does not reside in an address range allocated by ::cudaHostAlloc().</p>
<p>param pFlags - Returned flags word param pHost - Host pointer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue notefnerr</p>
<p>sa ::cudaHostAlloc </p>
<pre>
\brief Allocates logical 1D, 2D, or 3D memory objects on the device

Allocates at least \p width * \p height * \p depth bytes of linear memory
on the device and returns a ::cudaPitchedPtr in which \p ptr is a pointer
to the allocated memory. The function may pad the allocation to ensure
hardware alignment requirements are met. The pitch returned in the \p pitch
field of \p pitchedDevPtr is the width in bytes of the allocation.

The returned ::cudaPitchedPtr contains additional fields \p xsize and
\p ysize, the logical width and height of the allocation, which are
equivalent to the \p width and \p height \p extent parameters provided by
the programmer during allocation.

For allocations of 2D and 3D objects, it is highly recommended that
programmers perform allocations using ::cudaMalloc3D() or
::cudaMallocPitch(). Due to alignment restrictions in the hardware, this is
especially true if the application will be performing memory copies
involving 2D or 3D objects (whether linear memory or CUDA arrays).

\param pitchedDevPtr  - Pointer to allocated pitched device memory
\param extent         - Requested allocation size (\p width field in bytes)

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
\notefnerr

\sa ::cudaMallocPitch, ::cudaFree, ::cudaMemcpy3D, ::cudaMemset3D,
::cudaMalloc3DArray, ::cudaMallocArray, ::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc, ::make_cudaPitchedPtr, ::make_cudaExtent
</pre>
<pre>
\brief Allocate an array on the device

Allocates a CUDA array according to the ::cudaChannelFormatDesc structure
\p desc and returns a handle to the new CUDA array in \p *array.

The ::cudaChannelFormatDesc is defined as:
\code
   struct cudaChannelFormatDesc {
       int x, y, z, w;
       enum cudaChannelFormatKind f;
   };
   \endcode
where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,
::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.

::cudaMalloc3DArray() can allocate the following:

- A 1D array is allocated if the height and depth extents are both zero.
- A 2D array is allocated if only the depth extent is zero.
- A 3D array is allocated if all three extents are non-zero.
- A 1D layered CUDA array is allocated if only the height extent is zero and
the cudaArrayLayered flag is set. Each layer is a 1D array. The number of layers is
determined by the depth extent.
- A 2D layered CUDA array is allocated if all three extents are non-zero and
the cudaArrayLayered flag is set. Each layer is a 2D array. The number of layers is
determined by the depth extent.
- A cubemap CUDA array is allocated if all three extents are non-zero and the
cudaArrayCubemap flag is set. Width must be equal to height, and depth must be six. A cubemap is
a special type of 2D layered CUDA array, where the six layers represent the six faces of a cube.
The order of the six layers in memory is the same as that listed in ::cudaGraphicsCubeFace.
- A cubemap layered CUDA array is allocated if all three extents are non-zero, and both,
cudaArrayCubemap and cudaArrayLayered flags are set. Width must be equal to height, and depth must be
a multiple of six. A cubemap layered CUDA array is a special type of 2D layered CUDA array that consists
of a collection of cubemaps. The first six layers represent the first cubemap, the next six layers form
the second cubemap, and so on.


The \p flags parameter enables different options to be specified that affect
the allocation, as follows.
- ::cudaArrayDefault: This flag's value is defined to be 0 and provides default array allocation
- ::cudaArrayLayered: Allocates a layered CUDA array, with the depth extent indicating the number of layers
- ::cudaArrayCubemap: Allocates a cubemap CUDA array. Width must be equal to height, and depth must be six.
  If the cudaArrayLayered flag is also set, depth must be a multiple of six.
- ::cudaArraySurfaceLoadStore: Allocates a CUDA array that could be read from or written to using a surface
  reference.
- ::cudaArrayTextureGather: This flag indicates that texture gather operations will be performed on the CUDA
  array. Texture gather can only be performed on 2D CUDA arrays.

The width, height and depth extents must meet certain size requirements as listed in the following table.
All values are specified in elements.

Note that 2D CUDA arrays have different size requirements if the ::cudaArrayTextureGather flag is set. In that
case, the valid range for (width, height, depth) is ((1,maxTexture2DGather[0]), (1,maxTexture2DGather[1]), 0).

\xmlonly
&lt;table outputclass=&quot;xmlonly&quot;&gt;
&lt;tgroup cols=&quot;3&quot; colsep=&quot;1&quot; rowsep=&quot;1&quot;&gt;
&lt;colspec colname=&quot;c1&quot; colwidth=&quot;1.0*&quot;/&gt;
&lt;colspec colname=&quot;c2&quot; colwidth=&quot;3.0*&quot;/&gt;
&lt;colspec colname=&quot;c3&quot; colwidth=&quot;3.0*&quot;/&gt;
&lt;thead&gt;
&lt;row&gt;
&lt;entry&gt;CUDA array type&lt;/entry&gt;
&lt;entry&gt;Valid extents that must always be met {(width range in elements),
(height range), (depth range)}&lt;/entry&gt;
&lt;entry&gt;Valid extents with cudaArraySurfaceLoadStore set {(width range in
elements), (height range), (depth range)}&lt;/entry&gt;
&lt;/row&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;
&lt;entry&gt;1D&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture1D), 0, 0 }&lt;/entry&gt;
&lt;entry&gt;{ (1,maxSurface1D), 0, 0 }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;2D&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture2D[0]), (1,maxTexture2D[1]), 0 }&lt;/entry&gt;
&lt;entry&gt;{ (1,maxSurface2D[0]), (1,maxSurface2D[1]), 0 }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;3D&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture3D[0]), (1,maxTexture3D[1]), (1,maxTexture3D[2]) }
OR { (1,maxTexture3DAlt[0]), (1,maxTexture3DAlt[1]),
(1,maxTexture3DAlt[2]) }&lt;/entry&gt;
&lt;entry&gt;{ (1,maxSurface3D[0]), (1,maxSurface3D[1]), (1,maxSurface3D[2]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;1D Layered&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) }&lt;/entry&gt;
&lt;entry&gt;{ (1,maxSurface1DLayered[0]), 0, (1,maxSurface1DLayered[1]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;2D Layered&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),
(1,maxTexture2DLayered[2]) }&lt;/entry&gt;
&lt;entry&gt;{ (1,maxSurface2DLayered[0]), (1,maxSurface2DLayered[1]),
(1,maxSurface2DLayered[2]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;Cubemap&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTextureCubemap), (1,maxTextureCubemap), 6 }&lt;/entry&gt;
&lt;entry&gt;{ (1,maxSurfaceCubemap), (1,maxSurfaceCubemap), 6 }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;Cubemap Layered&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),
(1,maxTextureCubemapLayered[1]) }&lt;/entry&gt;
&lt;entry&gt;{ (1,maxSurfaceCubemapLayered[0]), (1,maxSurfaceCubemapLayered[0]),
(1,maxSurfaceCubemapLayered[1]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;/tbody&gt;
&lt;/tgroup&gt;
&lt;/table&gt;
\endxmlonly

\param array  - Pointer to allocated array in device memory
\param desc   - Requested channel format
\param extent - Requested allocation size (\p width field in elements)
\param flags  - Flags for extensions

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
\notefnerr

\sa ::cudaMalloc3D, ::cudaMalloc, ::cudaMallocPitch, ::cudaFree,
::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc,
::make_cudaExtent
</pre>
<pre>
\brief Allocate a mipmapped array on the device

Allocates a CUDA mipmapped array according to the ::cudaChannelFormatDesc structure
\p desc and returns a handle to the new CUDA mipmapped array in \p *mipmappedArray.
\p numLevels specifies the number of mipmap levels to be allocated. This value is
clamped to the range [1, 1 + floor(log2(max(width, height, depth)))].

The ::cudaChannelFormatDesc is defined as:
\code
   struct cudaChannelFormatDesc {
       int x, y, z, w;
       enum cudaChannelFormatKind f;
   };
   \endcode
where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,
::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.

::cudaMallocMipmappedArray() can allocate the following:

- A 1D mipmapped array is allocated if the height and depth extents are both zero.
- A 2D mipmapped array is allocated if only the depth extent is zero.
- A 3D mipmapped array is allocated if all three extents are non-zero.
- A 1D layered CUDA mipmapped array is allocated if only the height extent is zero and
the cudaArrayLayered flag is set. Each layer is a 1D mipmapped array. The number of layers is
determined by the depth extent.
- A 2D layered CUDA mipmapped array is allocated if all three extents are non-zero and
the cudaArrayLayered flag is set. Each layer is a 2D mipmapped array. The number of layers is
determined by the depth extent.
- A cubemap CUDA mipmapped array is allocated if all three extents are non-zero and the
cudaArrayCubemap flag is set. Width must be equal to height, and depth must be six.
The order of the six layers in memory is the same as that listed in ::cudaGraphicsCubeFace.
- A cubemap layered CUDA mipmapped array is allocated if all three extents are non-zero, and both,
cudaArrayCubemap and cudaArrayLayered flags are set. Width must be equal to height, and depth must be
a multiple of six. A cubemap layered CUDA mipmapped array is a special type of 2D layered CUDA mipmapped
array that consists of a collection of cubemap mipmapped arrays. The first six layers represent the
first cubemap mipmapped array, the next six layers form the second cubemap mipmapped array, and so on.


The \p flags parameter enables different options to be specified that affect
the allocation, as follows.
- ::cudaArrayDefault: This flag's value is defined to be 0 and provides default mipmapped array allocation
- ::cudaArrayLayered: Allocates a layered CUDA mipmapped array, with the depth extent indicating the number of layers
- ::cudaArrayCubemap: Allocates a cubemap CUDA mipmapped array. Width must be equal to height, and depth must be six.
  If the cudaArrayLayered flag is also set, depth must be a multiple of six.
- ::cudaArraySurfaceLoadStore: This flag indicates that individual mipmap levels of the CUDA mipmapped array
  will be read from or written to using a surface reference.
- ::cudaArrayTextureGather: This flag indicates that texture gather operations will be performed on the CUDA
  array. Texture gather can only be performed on 2D CUDA mipmapped arrays, and the gather operations are
  performed only on the most detailed mipmap level.

The width, height and depth extents must meet certain size requirements as listed in the following table.
All values are specified in elements.

\xmlonly
&lt;table outputclass=&quot;xmlonly&quot;&gt;
&lt;tgroup cols=&quot;2&quot; colsep=&quot;1&quot; rowsep=&quot;1&quot;&gt;
&lt;colspec colname=&quot;c1&quot; colwidth=&quot;1.0*&quot;/&gt;
&lt;colspec colname=&quot;c2&quot; colwidth=&quot;3.0*&quot;/&gt;
&lt;thead&gt;
&lt;row&gt;
&lt;entry&gt;CUDA array type&lt;/entry&gt;
&lt;entry&gt;Valid extents {(width range in elements), (height range), (depth
range)}&lt;/entry&gt;
&lt;/row&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;
&lt;entry&gt;1D&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture1DMipmap), 0, 0 }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;2D&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture2DMipmap[0]), (1,maxTexture2DMipmap[1]), 0 }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;3D&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture3D[0]), (1,maxTexture3D[1]), (1,maxTexture3D[2]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;1D Layered&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;2D Layered&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),
(1,maxTexture2DLayered[2]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;Cubemap&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTextureCubemap), (1,maxTextureCubemap), 6 }&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;Cubemap Layered&lt;/entry&gt;
&lt;entry&gt;{ (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),
(1,maxTextureCubemapLayered[1]) }&lt;/entry&gt;
&lt;/row&gt;
&lt;/tbody&gt;
&lt;/tgroup&gt;
&lt;/table&gt;
\endxmlonly

\param mipmappedArray  - Pointer to allocated mipmapped array in device memory
\param desc            - Requested channel format
\param extent          - Requested allocation size (\p width field in elements)
\param numLevels       - Number of mipmap levels to allocate
\param flags           - Flags for extensions

\return
::cudaSuccess,
::cudaErrorMemoryAllocation
\notefnerr

\sa ::cudaMalloc3D, ::cudaMalloc, ::cudaMallocPitch, ::cudaFree,
::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc,
::make_cudaExtent
</pre>
<pre>
\brief Gets a mipmap level of a CUDA mipmapped array

Returns in \p *levelArray a CUDA array that represents a single mipmap level
of the CUDA mipmapped array \p mipmappedArray.

If \p level is greater than the maximum number of levels in this mipmapped array,
::cudaErrorInvalidValue is returned.

\param levelArray     - Returned mipmap level CUDA array
\param mipmappedArray - CUDA mipmapped array
\param level          - Mipmap level

\return
::cudaSuccess,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaMalloc3D, ::cudaMalloc, ::cudaMallocPitch, ::cudaFree,
::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc,
::make_cudaExtent
</pre>
<p>brief Copies data between 3D objects</p>
<p>code struct cudaExtent { size_t width; size_t height; size_t depth; }; struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d);</p>
<p>struct cudaPos { size_t x; size_t y; size_t z; }; struct cudaPos make_cudaPos(size_t x, size_t y, size_t z);</p>
<p>struct cudaMemcpy3DParms { cudaArray_t           srcArray; struct cudaPos        srcPos; struct cudaPitchedPtr srcPtr; cudaArray_t           dstArray; struct cudaPos        dstPos; struct cudaPitchedPtr dstPtr; struct cudaExtent     extent; enum cudaMemcpyKind   kind; }; endcode</p>
<p>::cudaMemcpy3D() copies data betwen two 3D objects. The source and destination objects may be in either host memory, device memory, or a CUDA array. The source, destination, extent, and kind of copy performed is specified by the ::cudaMemcpy3DParms struct which should be initialized to zero before use: code cudaMemcpy3DParms myParms = {0}; endcode</p>
<p>The struct passed to ::cudaMemcpy3D() must specify one of p srcArray or p srcPtr and one of p dstArray or p dstPtr. Passing more than one non-zero source or destination will cause ::cudaMemcpy3D() to return an error.</p>
<p>The p srcPos and p dstPos fields are optional offsets into the source and destination objects and are defined in units of each object's elements. The element for a host or device pointer is assumed to be &lt;b&gt;unsigned char&lt;/b&gt;. For CUDA arrays, positions must be in the range [0, 2048) for any dimension.</p>
<p>The p extent field defines the dimensions of the transferred area in elements. If a CUDA array is participating in the copy, the extent is defined in terms of that array's elements. If no CUDA array is participating in the copy then the extents are defined in elements of &lt;b&gt;unsigned char&lt;/b&gt;.</p>
<p>The p kind field defines the direction of the copy. It must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>If the source and destination are both arrays, ::cudaMemcpy3D() will return an error if they do not have the same element size.</p>
<p>The source and destination object may not overlap. If overlapping source and destination objects are specified, undefined behavior will result.</p>
<p>The source object must lie entirely within the region defined by p srcPos and p extent. The destination object must lie entirely within the region defined by p dstPos and p extent.</p>
<p>::cudaMemcpy3D() returns an error if the pitch of p srcPtr or p dstPtr exceeds the maximum allowed. The pitch of a ::cudaPitchedPtr allocated with ::cudaMalloc3D() will always be valid.</p>
<p>param p - 3D memory copy parameters</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync</p>
<p>sa ::cudaMalloc3D, ::cudaMalloc3DArray, ::cudaMemset3D, ::cudaMemcpy3DAsync, ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync, ::make_cudaExtent, ::make_cudaPos </p>
<p>brief Copies memory between devices</p>
<p>Perform a 3D memory copy according to the parameters specified in p p.  See the definition of the ::cudaMemcpy3DPeerParms structure for documentation of its parameters.</p>
<p>Note that this function is synchronous with respect to the host only if the source or destination of the transfer is host memory.  Note also that this copy is serialized with respect to all pending and future asynchronous work in to the current device, the copy's source device, and the copy's destination device (use ::cudaMemcpy3DPeerAsync to avoid this synchronization).</p>
<p>param p - Parameters for the memory copy</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr note_sync</p>
<p>sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync, ::cudaMemcpyPeerAsync, ::cudaMemcpy3DPeerAsync </p>
<p>brief Copies data between 3D objects</p>
<p>code struct cudaExtent { size_t width; size_t height; size_t depth; }; struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d);</p>
<p>struct cudaPos { size_t x; size_t y; size_t z; }; struct cudaPos make_cudaPos(size_t x, size_t y, size_t z);</p>
<p>struct cudaMemcpy3DParms { cudaArray_t           srcArray; struct cudaPos        srcPos; struct cudaPitchedPtr srcPtr; cudaArray_t           dstArray; struct cudaPos        dstPos; struct cudaPitchedPtr dstPtr; struct cudaExtent     extent; enum cudaMemcpyKind   kind; }; endcode</p>
<p>::cudaMemcpy3DAsync() copies data betwen two 3D objects. The source and destination objects may be in either host memory, device memory, or a CUDA array. The source, destination, extent, and kind of copy performed is specified by the ::cudaMemcpy3DParms struct which should be initialized to zero before use: code cudaMemcpy3DParms myParms = {0}; endcode</p>
<p>The struct passed to ::cudaMemcpy3DAsync() must specify one of p srcArray or p srcPtr and one of p dstArray or p dstPtr. Passing more than one non-zero source or destination will cause ::cudaMemcpy3DAsync() to return an error.</p>
<p>The p srcPos and p dstPos fields are optional offsets into the source and destination objects and are defined in units of each object's elements. The element for a host or device pointer is assumed to be &lt;b&gt;unsigned char&lt;/b&gt;. For CUDA arrays, positions must be in the range [0, 2048) for any dimension.</p>
<p>The p extent field defines the dimensions of the transferred area in elements. If a CUDA array is participating in the copy, the extent is defined in terms of that array's elements. If no CUDA array is participating in the copy then the extents are defined in elements of &lt;b&gt;unsigned char&lt;/b&gt;.</p>
<p>The p kind field defines the direction of the copy. It must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>If the source and destination are both arrays, ::cudaMemcpy3DAsync() will return an error if they do not have the same element size.</p>
<p>The source and destination object may not overlap. If overlapping source and destination objects are specified, undefined behavior will result.</p>
<p>The source object must lie entirely within the region defined by p srcPos and p extent. The destination object must lie entirely within the region defined by p dstPos and p extent.</p>
<p>::cudaMemcpy3DAsync() returns an error if the pitch of p srcPtr or p dstPtr exceeds the maximum allowed. The pitch of a ::cudaPitchedPtr allocated with ::cudaMalloc3D() will always be valid.</p>
<p>::cudaMemcpy3DAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>The device version of this function only handles device to device copies and cannot be given local or shared pointers.</p>
<p>param p      - 3D memory copy parameters param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream</p>
<p>sa ::cudaMalloc3D, ::cudaMalloc3DArray, ::cudaMemset3D, ::cudaMemcpy3D, ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync, ::make_cudaExtent, ::make_cudaPos </p>
<p>brief Copies memory between devices asynchronously.</p>
<p>Perform a 3D memory copy according to the parameters specified in p p.  See the definition of the ::cudaMemcpy3DPeerParms structure for documentation of its parameters.</p>
<p>param p      - Parameters for the memory copy param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync, ::cudaMemcpyPeerAsync, ::cudaMemcpy3DPeerAsync </p>
<pre>
\brief Gets free and total device memory

Returns in \p *free and \p *total respectively, the free and total amount of
memory available for allocation by the device in bytes.

\param free  - Returned free memory in bytes
\param total - Returned total memory in bytes

\return
::cudaSuccess,
::cudaErrorInitializationError,
::cudaErrorInvalidValue,
::cudaErrorLaunchFailure
\notefnerr

</pre>
<pre>
\brief Gets info about the specified cudaArray

Returns in \p *desc, \p *extent and \p *flags respectively, the type, shape
and flags of \p array.

Any of \p *desc, \p *extent and \p *flags may be specified as NULL.

\param desc   - Returned array type
\param extent - Returned array shape. 2D arrays will have depth of zero
\param flags  - Returned array flags
\param array  - The ::cudaArray to get info for

\return
::cudaSuccess,
::cudaErrorInvalidValue
\notefnerr

</pre>
<p>brief Copies data between host and device</p>
<p>Copies p count bytes from the memory area pointed to by p src to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. Calling ::cudaMemcpy() with dst and src pointers that do not match the direction of the copy results in an undefined behavior.</p>
<p>param dst   - Destination memory address param src   - Source memory address param count - Size in bytes to copy param kind  - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr</p>
<p>note_sync</p>
<p>sa ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies memory between two devices</p>
<p>Copies memory from one device to memory on another device.  p dst is the base device pointer of the destination memory and p dstDevice is the destination device.  p src is the base device pointer of the source memory and p srcDevice is the source device.  p count specifies the number of bytes to copy.</p>
<p>Note that this function is asynchronous with respect to the host, but serialized with respect all pending and future asynchronous work in to the current device, p srcDevice, and p dstDevice (use ::cudaMemcpyPeerAsync to avoid this synchronization).</p>
<p>param dst       - Destination device pointer param dstDevice - Destination device param src       - Source device pointer param srcDevice - Source device param count     - Size of memory copy in bytes</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr note_sync</p>
<p>sa ::cudaMemcpy, ::cudaMemcpyAsync, ::cudaMemcpyPeerAsync, ::cudaMemcpy3DPeerAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies p count bytes from the memory area pointed to by p src to the CUDA array p dst starting at the upper left corner (p wOffset, p hOffset), where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>param dst     - Destination memory address param wOffset - Destination starting X offset param hOffset - Destination starting Y offset param src     - Source memory address param count   - Size in bytes to copy param kind    - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies p count bytes from the CUDA array p src starting at the upper left corner (p wOffset, hOffset) to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>param dst     - Destination memory address param src     - Source memory address param wOffset - Source starting X offset param hOffset - Source starting Y offset param count   - Size in bytes to copy param kind    - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies p count bytes from the CUDA array p src starting at the upper left corner (p wOffsetSrc, p hOffsetSrc) to the CUDA array p dst starting at the upper left corner (p wOffsetDst, p hOffsetDst) where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>param dst        - Destination memory address param wOffsetDst - Destination starting X offset param hOffsetDst - Destination starting Y offset param src        - Source memory address param wOffsetSrc - Source starting X offset param hOffsetSrc - Source starting Y offset param count      - Size in bytes to copy param kind       - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidMemcpyDirection notefnerr</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies a matrix (p height rows of p width bytes each) from the memory area pointed to by p src to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. p dpitch and p spitch are the widths in memory in bytes of the 2D arrays pointed to by p dst and p src, including any padding added to the end of each row. The memory areas may not overlap. p width must not exceed either p dpitch or p spitch. Calling ::cudaMemcpy2D() with p dst and p src pointers that do not match the direction of the copy results in an undefined behavior. ::cudaMemcpy2D() returns an error if p dpitch or p spitch exceeds the maximum allowed.</p>
<p>param dst    - Destination memory address param dpitch - Pitch of destination memory param src    - Source memory address param spitch - Pitch of source memory param width  - Width of matrix transfer (columns in bytes) param height - Height of matrix transfer (rows) param kind   - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr</p>
<p>sa ::cudaMemcpy, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies a matrix (p height rows of p width bytes each) from the memory area pointed to by p src to the CUDA array p dst starting at the upper left corner (p wOffset, p hOffset) where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. p spitch is the width in memory in bytes of the 2D array pointed to by p src, including any padding added to the end of each row. p wOffset + p width must not exceed the width of the CUDA array p dst. p width must not exceed p spitch. ::cudaMemcpy2DToArray() returns an error if p spitch exceeds the maximum allowed.</p>
<p>param dst     - Destination memory address param wOffset - Destination starting X offset param hOffset - Destination starting Y offset param src     - Source memory address param spitch  - Pitch of source memory param width   - Width of matrix transfer (columns in bytes) param height  - Height of matrix transfer (rows) param kind    - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies a matrix (p height rows of p width bytes each) from the CUDA array p srcArray starting at the upper left corner (p wOffset, p hOffset) to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. p dpitch is the width in memory in bytes of the 2D array pointed to by p dst, including any padding added to the end of each row. p wOffset + p width must not exceed the width of the CUDA array p src. p width must not exceed p dpitch. ::cudaMemcpy2DFromArray() returns an error if p dpitch exceeds the maximum allowed.</p>
<p>param dst     - Destination memory address param dpitch  - Pitch of destination memory param src     - Source memory address param wOffset - Source starting X offset param hOffset - Source starting Y offset param width   - Width of matrix transfer (columns in bytes) param height  - Height of matrix transfer (rows) param kind    - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies a matrix (p height rows of p width bytes each) from the CUDA array p srcArray starting at the upper left corner (p wOffsetSrc, p hOffsetSrc) to the CUDA array p dst starting at the upper left corner (p wOffsetDst, p hOffsetDst), where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. p wOffsetDst + p width must not exceed the width of the CUDA array p dst. p wOffsetSrc + p width must not exceed the width of the CUDA array p src.</p>
<p>param dst        - Destination memory address param wOffsetDst - Destination starting X offset param hOffsetDst - Destination starting Y offset param src        - Source memory address param wOffsetSrc - Source starting X offset param hOffsetSrc - Source starting Y offset param width      - Width of matrix transfer (columns in bytes) param height     - Height of matrix transfer (rows) param kind       - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data to the given symbol on the device</p>
<p>Copies p count bytes from the memory area pointed to by p src to the memory area pointed to by p offset bytes from the start of symbol p symbol. The memory areas may not overlap. p symbol is a variable that resides in global or constant memory space. p kind can be either ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>param symbol - Device symbol address param src    - Source memory address param count  - Size in bytes to copy param offset - Offset from start of symbol in bytes param kind   - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidSymbol, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync note_string_api_deprecation</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data from the given symbol on the device</p>
<p>Copies p count bytes from the memory area pointed to by p offset bytes from the start of symbol p symbol to the memory area pointed to by p dst. The memory areas may not overlap. p symbol is a variable that resides in global or constant memory space. p kind can be either ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>param dst    - Destination memory address param symbol - Device symbol address param count  - Size in bytes to copy param offset - Offset from start of symbol in bytes param kind   - Type of transfer</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidSymbol, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_sync note_string_api_deprecation</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies p count bytes from the memory area pointed to by p src to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>The memory areas may not overlap. Calling ::cudaMemcpyAsync() with p dst and p src pointers that do not match the direction of the copy results in an undefined behavior.</p>
<p>::cudaMemcpyAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and the p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>The device version of this function only handles device to device copies and cannot be given local or shared pointers.</p>
<p>param dst    - Destination memory address param src    - Source memory address param count  - Size in bytes to copy param kind   - Type of transfer param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies memory between two devices asynchronously.</p>
<p>Copies memory from one device to memory on another device.  p dst is the base device pointer of the destination memory and p dstDevice is the destination device.  p src is the base device pointer of the source memory and p srcDevice is the source device.  p count specifies the number of bytes to copy.</p>
<p>Note that this function is asynchronous with respect to the host and all work on other devices.</p>
<p>param dst       - Destination device pointer param dstDevice - Destination device param src       - Source device pointer param srcDevice - Source device param count     - Size of memory copy in bytes param stream    - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync, ::cudaMemcpy3DPeerAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies p count bytes from the memory area pointed to by p src to the CUDA array p dst starting at the upper left corner (p wOffset, p hOffset), where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>::cudaMemcpyToArrayAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>param dst     - Destination memory address param wOffset - Destination starting X offset param hOffset - Destination starting Y offset param src     - Source memory address param count   - Size in bytes to copy param kind    - Type of transfer param stream  - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies p count bytes from the CUDA array p src starting at the upper left corner (p wOffset, hOffset) to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>::cudaMemcpyFromArrayAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>param dst     - Destination memory address param src     - Source memory address param wOffset - Source starting X offset param hOffset - Source starting Y offset param count   - Size in bytes to copy param kind    - Type of transfer param stream  - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies a matrix (p height rows of p width bytes each) from the memory area pointed to by p src to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. p dpitch and p spitch are the widths in memory in bytes of the 2D arrays pointed to by p dst and p src, including any padding added to the end of each row. The memory areas may not overlap. p width must not exceed either p dpitch or p spitch.</p>
<p>Calling ::cudaMemcpy2DAsync() with p dst and p src pointers that do not match the direction of the copy results in an undefined behavior. ::cudaMemcpy2DAsync() returns an error if p dpitch or p spitch is greater than the maximum allowed.</p>
<p>::cudaMemcpy2DAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>The device version of this function only handles device to device copies and cannot be given local or shared pointers.</p>
<p>param dst    - Destination memory address param dpitch - Pitch of destination memory param src    - Source memory address param spitch - Pitch of source memory param width  - Width of matrix transfer (columns in bytes) param height - Height of matrix transfer (rows) param kind   - Type of transfer param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies a matrix (p height rows of p width bytes each) from the memory area pointed to by p src to the CUDA array p dst starting at the upper left corner (p wOffset, p hOffset) where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. p spitch is the width in memory in bytes of the 2D array pointed to by p src, including any padding added to the end of each row. p wOffset + p width must not exceed the width of the CUDA array p dst. p width must not exceed p spitch. ::cudaMemcpy2DToArrayAsync() returns an error if p spitch exceeds the maximum allowed.</p>
<p>::cudaMemcpy2DToArrayAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>param dst     - Destination memory address param wOffset - Destination starting X offset param hOffset - Destination starting Y offset param src     - Source memory address param spitch  - Pitch of source memory param width   - Width of matrix transfer (columns in bytes) param height  - Height of matrix transfer (rows) param kind    - Type of transfer param stream  - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data between host and device</p>
<p>Copies a matrix (p height rows of p width bytes each) from the CUDA array p srcArray starting at the upper left corner (p wOffset, p hOffset) to the memory area pointed to by p dst, where p kind specifies the direction of the copy, and must be one of ::cudaMemcpyHostToHost, ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing. p dpitch is the width in memory in bytes of the 2D array pointed to by p dst, including any padding added to the end of each row. p wOffset + p width must not exceed the width of the CUDA array p src. p width must not exceed p dpitch. ::cudaMemcpy2DFromArrayAsync() returns an error if p dpitch exceeds the maximum allowed.</p>
<p>::cudaMemcpy2DFromArrayAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice or ::cudaMemcpyDeviceToHost and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>param dst     - Destination memory address param dpitch  - Pitch of destination memory param src     - Source memory address param wOffset - Source starting X offset param hOffset - Source starting Y offset param width   - Width of matrix transfer (columns in bytes) param height  - Height of matrix transfer (rows) param kind    - Type of transfer param stream  - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidPitchValue, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpyToSymbolAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data to the given symbol on the device</p>
<p>Copies p count bytes from the memory area pointed to by p src to the memory area pointed to by p offset bytes from the start of symbol p symbol. The memory areas may not overlap. p symbol is a variable that resides in global or constant memory space. p kind can be either ::cudaMemcpyHostToDevice, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>::cudaMemcpyToSymbolAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyHostToDevice and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>param symbol - Device symbol address param src    - Source memory address param count  - Size in bytes to copy param offset - Offset from start of symbol in bytes param kind   - Type of transfer param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidSymbol, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream note_string_api_deprecation</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyFromSymbolAsync </p>
<p>brief Copies data from the given symbol on the device</p>
<p>Copies p count bytes from the memory area pointed to by p offset bytes from the start of symbol p symbol to the memory area pointed to by p dst. The memory areas may not overlap. p symbol is a variable that resides in global or constant memory space. p kind can be either ::cudaMemcpyDeviceToHost, ::cudaMemcpyDeviceToDevice, or ::cudaMemcpyDefault. Passing ::cudaMemcpyDefault is recommended, in which case the type of transfer is inferred from the pointer values. However, ::cudaMemcpyDefault is only allowed on systems that support unified virtual addressing.</p>
<p>::cudaMemcpyFromSymbolAsync() is asynchronous with respect to the host, so the call may return before the copy is complete. The copy can optionally be associated to a stream by passing a non-zero p stream argument. If p kind is ::cudaMemcpyDeviceToHost and p stream is non-zero, the copy may overlap with operations in other streams.</p>
<p>param dst    - Destination memory address param symbol - Device symbol address param count  - Size in bytes to copy param offset - Offset from start of symbol in bytes param kind   - Type of transfer param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidSymbol, ::cudaErrorInvalidDevicePointer, ::cudaErrorInvalidMemcpyDirection notefnerr note_async note_null_stream note_string_api_deprecation</p>
<p>sa ::cudaMemcpy, ::cudaMemcpy2D, ::cudaMemcpyToArray, ::cudaMemcpy2DToArray, ::cudaMemcpyFromArray, ::cudaMemcpy2DFromArray, ::cudaMemcpyArrayToArray, ::cudaMemcpy2DArrayToArray, ::cudaMemcpyToSymbol, ::cudaMemcpyFromSymbol, ::cudaMemcpyAsync, ::cudaMemcpy2DAsync, ::cudaMemcpyToArrayAsync, ::cudaMemcpy2DToArrayAsync, ::cudaMemcpyFromArrayAsync, ::cudaMemcpy2DFromArrayAsync, ::cudaMemcpyToSymbolAsync </p>
<p>brief Initializes or sets device memory to a value</p>
<p>Fills the first p count bytes of the memory area pointed to by p devPtr with the constant byte value p value.</p>
<p>Note that this function is asynchronous with respect to the host unless p devPtr refers to pinned host memory.</p>
<p>param devPtr - Pointer to device memory param value  - Value to set for each byte of specified memory param count  - Size in bytes to set</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer notefnerr note_memset</p>
<p>sa ::cudaMemset2D, ::cudaMemset3D, ::cudaMemsetAsync, ::cudaMemset2DAsync, ::cudaMemset3DAsync </p>
<p>brief Initializes or sets device memory to a value</p>
<p>Sets to the specified value p value a matrix (p height rows of p width bytes each) pointed to by p dstPtr. p pitch is the width in bytes of the 2D array pointed to by p dstPtr, including any padding added to the end of each row. This function performs fastest when the pitch is one that has been passed back by ::cudaMallocPitch().</p>
<p>Note that this function is asynchronous with respect to the host unless p devPtr refers to pinned host memory.</p>
<p>param devPtr - Pointer to 2D device memory param pitch  - Pitch in bytes of 2D device memory param value  - Value to set for each byte of specified memory param width  - Width of matrix set (columns in bytes) param height - Height of matrix set (rows)</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer notefnerr note_memset</p>
<p>sa ::cudaMemset, ::cudaMemset3D, ::cudaMemsetAsync, ::cudaMemset2DAsync, ::cudaMemset3DAsync </p>
<p>brief Initializes or sets device memory to a value</p>
<p>Initializes each element of a 3D array to the specified value p value. The object to initialize is defined by p pitchedDevPtr. The p pitch field of p pitchedDevPtr is the width in memory in bytes of the 3D array pointed to by p pitchedDevPtr, including any padding added to the end of each row. The p xsize field specifies the logical width of each row in bytes, while the p ysize field specifies the height of each 2D slice in rows.</p>
<p>The extents of the initialized region are specified as a p width in bytes, a p height in rows, and a p depth in slices.</p>
<p>Extents with p width greater than or equal to the p xsize of p pitchedDevPtr may perform significantly faster than extents narrower than the p xsize. Secondarily, extents with p height equal to the p ysize of p pitchedDevPtr will perform faster than when the p height is shorter than the p ysize.</p>
<p>This function performs fastest when the p pitchedDevPtr has been allocated by ::cudaMalloc3D().</p>
<p>Note that this function is asynchronous with respect to the host unless p pitchedDevPtr refers to pinned host memory.</p>
<p>param pitchedDevPtr - Pointer to pitched device memory param value         - Value to set for each byte of specified memory param extent        - Size parameters for where to set device memory (p width field in bytes)</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer notefnerr note_memset</p>
<p>sa ::cudaMemset, ::cudaMemset2D, ::cudaMemsetAsync, ::cudaMemset2DAsync, ::cudaMemset3DAsync, ::cudaMalloc3D, ::make_cudaPitchedPtr, ::make_cudaExtent </p>
<p>brief Initializes or sets device memory to a value</p>
<p>Fills the first p count bytes of the memory area pointed to by p devPtr with the constant byte value p value.</p>
<p>::cudaMemsetAsync() is asynchronous with respect to the host, so the call may return before the memset is complete. The operation can optionally be associated to a stream by passing a non-zero p stream argument. If p stream is non-zero, the operation may overlap with operations in other streams.</p>
<p>The device version of this function only handles device to device copies and cannot be given local or shared pointers.</p>
<p>param devPtr - Pointer to device memory param value  - Value to set for each byte of specified memory param count  - Size in bytes to set param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer notefnerr note_memset note_null_stream</p>
<p>sa ::cudaMemset, ::cudaMemset2D, ::cudaMemset3D, ::cudaMemset2DAsync, ::cudaMemset3DAsync </p>
<p>brief Initializes or sets device memory to a value</p>
<p>Sets to the specified value p value a matrix (p height rows of p width bytes each) pointed to by p dstPtr. p pitch is the width in bytes of the 2D array pointed to by p dstPtr, including any padding added to the end of each row. This function performs fastest when the pitch is one that has been passed back by ::cudaMallocPitch().</p>
<p>::cudaMemset2DAsync() is asynchronous with respect to the host, so the call may return before the memset is complete. The operation can optionally be associated to a stream by passing a non-zero p stream argument. If p stream is non-zero, the operation may overlap with operations in other streams.</p>
<p>The device version of this function only handles device to device copies and cannot be given local or shared pointers.</p>
<p>param devPtr - Pointer to 2D device memory param pitch  - Pitch in bytes of 2D device memory param value  - Value to set for each byte of specified memory param width  - Width of matrix set (columns in bytes) param height - Height of matrix set (rows) param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer notefnerr note_memset note_null_stream</p>
<p>sa ::cudaMemset, ::cudaMemset2D, ::cudaMemset3D, ::cudaMemsetAsync, ::cudaMemset3DAsync </p>
<p>brief Initializes or sets device memory to a value</p>
<p>Initializes each element of a 3D array to the specified value p value. The object to initialize is defined by p pitchedDevPtr. The p pitch field of p pitchedDevPtr is the width in memory in bytes of the 3D array pointed to by p pitchedDevPtr, including any padding added to the end of each row. The p xsize field specifies the logical width of each row in bytes, while the p ysize field specifies the height of each 2D slice in rows.</p>
<p>The extents of the initialized region are specified as a p width in bytes, a p height in rows, and a p depth in slices.</p>
<p>Extents with p width greater than or equal to the p xsize of p pitchedDevPtr may perform significantly faster than extents narrower than the p xsize. Secondarily, extents with p height equal to the p ysize of p pitchedDevPtr will perform faster than when the p height is shorter than the p ysize.</p>
<p>This function performs fastest when the p pitchedDevPtr has been allocated by ::cudaMalloc3D().</p>
<p>::cudaMemset3DAsync() is asynchronous with respect to the host, so the call may return before the memset is complete. The operation can optionally be associated to a stream by passing a non-zero p stream argument. If p stream is non-zero, the operation may overlap with operations in other streams.</p>
<p>The device version of this function only handles device to device copies and cannot be given local or shared pointers.</p>
<p>param pitchedDevPtr - Pointer to pitched device memory param value         - Value to set for each byte of specified memory param extent        - Size parameters for where to set device memory (p width field in bytes) param stream - Stream identifier</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevicePointer notefnerr note_memset note_null_stream</p>
<p>sa ::cudaMemset, ::cudaMemset2D, ::cudaMemset3D, ::cudaMemsetAsync, ::cudaMemset2DAsync, ::cudaMalloc3D, ::make_cudaPitchedPtr, ::make_cudaExtent </p>
<pre>
\brief Finds the address associated with a CUDA symbol

Returns in \p *devPtr the address of symbol \p symbol on the device.
\p symbol is a variable that resides in global or constant memory space.
If \p symbol cannot be found, or if \p symbol is not declared in the
global or constant memory space, \p *devPtr is unchanged and the error
::cudaErrorInvalidSymbol is returned.

\param devPtr - Return device pointer associated with symbol
\param symbol - Device symbol address

\return
::cudaSuccess,
::cudaErrorInvalidSymbol
\notefnerr
\note_string_api_deprecation

\sa \ref ::cudaGetSymbolAddress(void**, const T&amp;) &quot;cudaGetSymbolAddress (C++ API)&quot;,
\ref ::cudaGetSymbolSize(size_t*, const void*) &quot;cudaGetSymbolSize (C API)&quot;
</pre>
<pre>
\brief Finds the size of the object associated with a CUDA symbol

Returns in \p *size the size of symbol \p symbol. \p symbol is a variable that
resides in global or constant memory space. If \p symbol cannot be found, or
if \p symbol is not declared in global or constant memory space, \p *size is
unchanged and the error ::cudaErrorInvalidSymbol is returned.

\param size   - Size of object associated with symbol
\param symbol - Device symbol address

\return
::cudaSuccess,
::cudaErrorInvalidSymbol
\notefnerr
\note_string_api_deprecation

\sa \ref ::cudaGetSymbolAddress(void**, const void*) &quot;cudaGetSymbolAddress (C API)&quot;,
\ref ::cudaGetSymbolSize(size_t*, const T&amp;) &quot;cudaGetSymbolSize (C++ API)&quot;
</pre>
<p>brief Prefetches memory to the specified destination device</p>
<p>Prefetches memory to the specified destination device.  p devPtr is the base device pointer of the memory to be prefetched and p dstDevice is the destination device. p count specifies the number of bytes to copy. p stream is the stream in which the operation is enqueued. The memory range must refer to managed memory allocated via ::cudaMallocManaged or declared via __managed__ variables.</p>
<p>Passing in cudaCpuDeviceId for p dstDevice will prefetch the data to host memory. If p dstDevice is a GPU, then the device attribute ::cudaDevAttrConcurrentManagedAccess must be non-zero. Additionally, p stream must be associated with a device that has a non-zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess.</p>
<p>The start address and end address of the memory range will be rounded down and rounded up respectively to be aligned to CPU page size before the prefetch operation is enqueued in the stream.</p>
<p>If no physical memory has been allocated for this region, then this memory region will be populated and mapped on the destination device. If there's insufficient memory to prefetch the desired region, the Unified Memory driver may evict pages from other ::cudaMallocManaged allocations to host memory in order to make room. Device memory allocated using ::cudaMalloc or ::cudaMallocArray will not be evicted.</p>
<p>By default, any mappings to the previous location of the migrated pages are removed and mappings for the new location are only setup on p dstDevice. The exact behavior however also depends on the settings applied to this memory range via ::cudaMemAdvise as described below:</p>
<p>If ::cudaMemAdviseSetReadMostly was set on any subset of this memory range, then that subset will create a read-only copy of the pages on p dstDevice.</p>
<p>If ::cudaMemAdviseSetPreferredLocation was called on any subset of this memory range, then the pages will be migrated to p dstDevice even if p dstDevice is not the preferred location of any pages in the memory range.</p>
<p>If ::cudaMemAdviseSetAccessedBy was called on any subset of this memory range, then mappings to those pages from all the appropriate processors are updated to refer to the new location if establishing such a mapping is possible. Otherwise, those mappings are cleared.</p>
<p>Note that this API is not required for functionality and only serves to improve performance by allowing the application to migrate data to a suitable location before it is accessed. Memory accesses to this range are always coherent and are allowed even when the data is actively being migrated.</p>
<p>Note that this function is asynchronous with respect to the host and all work on other devices.</p>
<p>param devPtr    - Pointer to be prefetched param count     - Size in bytes param dstDevice - Destination device to prefetch to param stream    - Stream to enqueue prefetch operation</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync, ::cudaMemcpy3DPeerAsync, ::cudaMemAdvise </p>
<p>brief Advise about the usage of a given memory range</p>
<p>Advise the Unified Memory subsystem about the usage pattern for the memory range starting at p devPtr with a size of p count bytes. The start address and end address of the memory range will be rounded down and rounded up respectively to be aligned to CPU page size before the advice is applied. The memory range must refer to managed memory allocated via ::cudaMallocManaged or declared via __managed__ variables.</p>
<p>The p advice parameter can take the following values:</p>
<ul class="simple"><li>::cudaMemAdviseSetReadMostly: This implies that the data is mostly going to be read</li>
</ul>
<p>from and only occasionally written to. Any read accesses from any processor to this region will create a read-only copy of at least the accessed pages in that processor's memory. Additionally, if ::cudaMemPrefetchAsync is called on this region, it will create a read-only copy of the data on the destination processor. If any processor writes to this region, all copies of the corresponding page will be invalidated except for the one where the write occurred. The p device argument is ignored for this advice. Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU that has a non-zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess. Also, if a context is created on a device that does not have the device attribute ::cudaDevAttrConcurrentManagedAccess set, then read-duplication will not occur until all such contexts are destroyed.</p>
<ul class="simple"><li>::cudaMemAdviceUnsetReadMostly: Undoes the effect of ::cudaMemAdviceReadMostly and also prevents the</li>
</ul>
<p>Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated copies of the data will be collapsed into a single copy. The location for the collapsed copy will be the preferred location if the page has a preferred location and one of the read-duplicated copies was resident at that location. Otherwise, the location chosen is arbitrary.</p>
<ul class="simple"><li>::cudaMemAdviseSetPreferredLocation: This advice sets the preferred location for the</li>
</ul>
<p>data to be the memory belonging to p device. Passing in cudaCpuDeviceId for p device sets the preferred location as host memory. If p device is a GPU, then it must have a non-zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess. Setting the preferred location does not cause data to migrate to that location immediately. Instead, it guides the migration policy when a fault occurs on that memory region. If the data is already in its preferred location and the faulting processor can establish a mapping without requiring the data to be migrated, then data migration will be avoided. On the other hand, if the data is not in its preferred location or if a direct mapping cannot be established, then it will be migrated to the processor accessing it. It is important to note that setting the preferred location does not prevent data prefetching done using ::cudaMemPrefetchAsync. Having a preferred location can override the page thrash detection and resolution logic in the Unified Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device memory, the page may eventually be pinned to host memory by the Unified Memory driver. But if the preferred location is set as device memory, then the page will continue to thrash indefinitely. If ::cudaMemAdviseSetReadMostly is also set on this memory region or any subset of it, then the policies associated with that advice will override the policies of this advice.</p>
<ul class="simple"><li>::cudaMemAdviseUnsetPreferredLocation: Undoes the effect of ::cudaMemAdviseSetPreferredLocation</li>
</ul>
<p>and changes the preferred location to none.</p>
<ul class="simple"><li>::cudaMemAdviseSetAccessedBy: This advice implies that the data will be accessed by p device.</li>
</ul>
<p>Passing in ::cudaCpuDeviceId for p device will set the advice for the CPU. If p device is a GPU, then the device attribute ::cudaDevAttrConcurrentManagedAccess must be non-zero. This advice does not cause data migration and has no impact on the location of the data per se. Instead, it causes the data to always be mapped in the specified processor's page tables, as long as the location of the data permits a mapping to be established. If the data gets migrated for any reason, the mappings are updated accordingly. This advice is recommended in scenarios where data locality is not important, but avoiding faults is. Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data over to the other GPUs is not as important because the accesses are infrequent and the overhead of migration may be too high. But preventing faults can still help improve performance, and so having a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated to host memory because the CPU typically cannot access device memory directly. Any GPU that had the ::cudaMemAdviceSetAccessedBy flag set for this data will now have its mapping updated to point to the page in host memory. If ::cudaMemAdviseSetReadMostly is also set on this memory region or any subset of it, then the policies associated with that advice will override the policies of this advice. Additionally, if the preferred location of this memory region or any subset of it is also p device, then the policies associated with ::cudaMemAdviseSetPreferredLocation will override the policies of this advice.</p>
<ul class="simple"><li>::cudaMemAdviseUnsetAccessedBy: Undoes the effect of ::cudaMemAdviseSetAccessedBy. Any mappings to</li>
</ul>
<p>the data from p device may be removed at any time causing accesses to result in non-fatal page faults.</p>
<p>param devPtr - Pointer to memory to set the advice for param count  - Size in bytes of the memory range param advice - Advice to be applied for the specified memory range param device - Device to apply the advice for</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidDevice notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync, ::cudaMemcpy3DPeerAsync, ::cudaMemPrefetchAsync </p>
<p>brief Query an attribute of a given memory range</p>
<p>Query an attribute about the memory range starting at p devPtr with a size of p count bytes. The memory range must refer to managed memory allocated via ::cudaMallocManaged or declared via __managed__ variables.</p>
<p>The p attribute parameter can take the following values:</p>
<ul class="simple"><li>::cudaMemRangeAttributeReadMostly: If this attribute is specified, p data will be interpreted</li>
</ul>
<p>as a 32-bit integer, and p dataSize must be 4. The result returned will be 1 if all pages in the given memory range have read-duplication enabled, or 0 otherwise.</p>
<ul class="simple"><li>::cudaMemRangeAttributePreferredLocation: If this attribute is specified, p data will be</li>
</ul>
<p>interpreted as a 32-bit integer, and p dataSize must be 4. The result returned will be a GPU device id if all pages in the memory range have that GPU as their preferred location, or it will be cudaCpuDeviceId if all pages in the memory range have the CPU as their preferred location, or it will be cudaInvalidDeviceId if either all the pages don't have the same preferred location or some of the pages don't have a preferred location at all. Note that the actual location of the pages in the memory range at the time of the query may be different from the preferred location.</p>
<ul class="simple"><li>::cudaMemRangeAttributeAccessedBy: If this attribute is specified, p data will be interpreted</li>
</ul>
<p>as an array of 32-bit integers, and p dataSize must be a non-zero multiple of 4. The result returned will be a list of device ids that had ::cudaMemAdviceSetAccessedBy set for that entire memory range. If any device does not have that advice set for the entire memory range, that device will not be included. If p data is larger than the number of devices that have that advice set for that memory range, cudaInvalidDeviceId will be returned in all the extra space provided. For ex., if p dataSize is 12 (i.e. p data has 3 elements) and only device 0 has the advice set, then the result returned will be { 0, cudaInvalidDeviceId, cudaInvalidDeviceId }. If p data is smaller than the number of devices that have that advice set, then only as many devices will be returned as can fit in the array. There is no guarantee on which specific devices will be returned, however.</p>
<ul class="simple"><li>::cudaMemRangeAttributeLastPrefetchLocation: If this attribute is specified, p data will be</li>
</ul>
<p>interpreted as a 32-bit integer, and p dataSize must be 4. The result returned will be the last location to which all pages in the memory range were prefetched explicitly via ::cudaMemPrefetchAsync. This will either be a GPU id or cudaCpuDeviceId depending on whether the last location for prefetch was a GPU or the CPU respectively. If any page in the memory range was never explicitly prefetched or if all pages were not prefetched to the same location, cudaInvalidDeviceId will be returned. Note that this simply returns the last location that the applicaton requested to prefetch the memory range to. It gives no indication as to whether the prefetch operation to that location has completed or even begun.</p>
<p>param data      - A pointers to a memory location where the result of each attribute query will be written to. param dataSize  - Array containing the size of data param attribute - The attribute to query param devPtr    - Start of the range to query param count     - Size of the range to query</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue notefnerr note_async note_null_stream</p>
<p>sa ::cudaMemRangeGetAttributes, ::cudaMemPrefetchAsync, ::cudaMemAdvise </p>
<p>brief Query attributes of a given memory range.</p>
<p>Query attributes of the memory range starting at p devPtr with a size of p count bytes. The memory range must refer to managed memory allocated via ::cudaMallocManaged or declared via __managed__ variables. The p attributes array will be interpreted to have p numAttributes entries. The p dataSizes array will also be interpreted to have p numAttributes entries. The results of the query will be stored in p data.</p>
<p>The list of supported attributes are given below. Please refer to ::cudaMemRangeGetAttribute for attribute descriptions and restrictions.</p>
<ul class="simple"><li>::cudaMemRangeAttributeReadMostly</li>
<li>::cudaMemRangeAttributePreferredLocation</li>
<li>::cudaMemRangeAttributeAccessedBy</li>
<li>::cudaMemRangeAttributeLastPrefetchLocation</li>
</ul>
<p>param data          - A two-dimensional array containing pointers to memory locations where the result of each attribute query will be written to. param dataSizes     - Array containing the sizes of each result param attributes    - An array of attributes to query (numAttributes and the number of attributes in this array should match) param numAttributes - Number of attributes to query param devPtr        - Start of the range to query param count         - Size of the range to query</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue notefnerr</p>
<p>sa ::cudaMemRangeGetAttribute, ::cudaMemAdvise ::cudaMemPrefetchAsync </p>
<pre>@}
END CUDART_MEMORY

\defgroup CUDART_UNIFIED Unified Addressing

___MANBRIEF___ unified addressing functions of the CUDA runtime API
(___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the unified addressing functions of the CUDA
runtime application programming interface.

@{

\section CUDART_UNIFIED_overview Overview

CUDA devices can share a unified address space with the host.
For these devices there is no distinction between a device
pointer and a host pointer -- the same pointer value may be
used to access memory from the host program and from a kernel
running on the device (with exceptions enumerated below).

\section CUDART_UNIFIED_support Supported Platforms

Whether or not a device supports unified addressing may be
queried by calling ::cudaGetDeviceProperties() with the device
property ::cudaDeviceProp::unifiedAddressing.

Unified addressing is automatically enabled in 64-bit processes .

Unified addressing is not yet supported on Windows Vista or
Windows 7 for devices that do not use the TCC driver model.

\section CUDART_UNIFIED_lookup Looking Up Information from Pointer Values

It is possible to look up information about the memory which backs a
pointer value.  For instance, one may want to know if a pointer points
to host or device memory.  As another example, in the case of device
memory, one may want to know on which CUDA device the memory
resides.  These properties may be queried using the function
::cudaPointerGetAttributes()

Since pointers are unique, it is not necessary to specify information
about the pointers specified to ::cudaMemcpy() and other copy functions.
The copy direction ::cudaMemcpyDefault may be used to specify that the
CUDA runtime should infer the location of the pointer from its value.

\section CUDART_UNIFIED_automaphost Automatic Mapping of Host Allocated Host Memory

All host memory allocated through all devices using ::cudaMallocHost() and
::cudaHostAlloc() is always directly accessible from all devices that
support unified addressing.  This is the case regardless of whether or
not the flags ::cudaHostAllocPortable and ::cudaHostAllocMapped are
specified.

The pointer value through which allocated host memory may be accessed
in kernels on all devices that support unified addressing is the same
as the pointer value through which that memory is accessed on the host.
It is not necessary to call ::cudaHostGetDevicePointer() to get the device
pointer for these allocations.

Note that this is not the case for memory allocated using the flag
::cudaHostAllocWriteCombined, as discussed below.

\section CUDART_UNIFIED_autopeerregister Direct Access of Peer Memory

Upon enabling direct access from a device that supports unified addressing
to another peer device that supports unified addressing using
::cudaDeviceEnablePeerAccess() all memory allocated in the peer device using
::cudaMalloc() and ::cudaMallocPitch() will immediately be accessible
by the current device.  The device pointer value through
which any peer's memory may be accessed in the current device
is the same pointer value through which that memory may be
accessed from the peer device.

\section CUDART_UNIFIED_exceptions Exceptions, Disjoint Addressing

Not all memory may be accessed on devices through the same pointer
value through which they are accessed on the host.  These exceptions
are host memory registered using ::cudaHostRegister() and host memory
allocated using the flag ::cudaHostAllocWriteCombined.  For these
exceptions, there exists a distinct host and device address for the
memory.  The device address is guaranteed to not overlap any valid host
pointer range and is guaranteed to have the same value across all devices
that support unified addressing.

This device address may be queried using ::cudaHostGetDevicePointer()
when a device using unified addressing is current.  Either the host
or the unified device pointer value may be used to refer to this memory
in ::cudaMemcpy() and similar functions using the ::cudaMemcpyDefault
memory direction.



\brief Returns attributes about a specified pointer

Returns in \p *attributes the attributes of the pointer \p ptr.
If pointer was not allocated in, mapped by or registered with context
supporting unified addressing ::cudaErrorInvalidValue is returned.

The ::cudaPointerAttributes structure is defined as:
\code
   struct cudaPointerAttributes {
       enum cudaMemoryType memoryType;
       int device;
       void *devicePointer;
       void *hostPointer;
       int isManaged;
   }
   \endcode
In this structure, the individual fields mean

- \ref ::cudaPointerAttributes::memoryType &quot;memoryType&quot; identifies the physical
  location of the memory associated with pointer \p ptr.  It can be
  ::cudaMemoryTypeHost for host memory or ::cudaMemoryTypeDevice for device
  memory.

- \ref ::cudaPointerAttributes::device &quot;device&quot; is the device against which
  \p ptr was allocated.  If \p ptr has memory type ::cudaMemoryTypeDevice
  then this identifies the device on which the memory referred to by \p ptr
  physically resides.  If \p ptr has memory type ::cudaMemoryTypeHost then this
  identifies the device which was current when the allocation was made
  (and if that device is deinitialized then this allocation will vanish
  with that device's state).

- \ref ::cudaPointerAttributes::devicePointer &quot;devicePointer&quot; is
  the device pointer alias through which the memory referred to by \p ptr
  may be accessed on the current device.
  If the memory referred to by \p ptr cannot be accessed directly by the
  current device then this is NULL.

- \ref ::cudaPointerAttributes::hostPointer &quot;hostPointer&quot; is
  the host pointer alias through which the memory referred to by \p ptr
  may be accessed on the host.
  If the memory referred to by \p ptr cannot be accessed directly by the
  host then this is NULL.

- \ref ::cudaPointerAttributes::isManaged &quot;isManaged&quot; indicates if
  the pointer \p ptr points to managed memory or not.

\param attributes - Attributes for the specified pointer
\param ptr        - Pointer to get attributes for

\return
::cudaSuccess,
::cudaErrorInvalidDevice,
::cudaErrorInvalidValue

\sa ::cudaGetDeviceCount, ::cudaGetDevice, ::cudaSetDevice,
::cudaChooseDevice
</pre>
<pre>@}
END CUDART_UNIFIED

\defgroup CUDART_PEER Peer Device Memory Access

___MANBRIEF___ peer device memory access functions of the CUDA runtime API
(___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the peer device memory access functions of the CUDA runtime
application programming interface.

@{


\brief Queries if a device may directly access a peer device's memory.

Returns in \p *canAccessPeer a value of 1 if device \p device is capable of
directly accessing memory from \p peerDevice and 0 otherwise.  If direct
access of \p peerDevice from \p device is possible, then access may be
enabled by calling ::cudaDeviceEnablePeerAccess().

\param canAccessPeer - Returned access capability
\param device        - Device from which allocations on \p peerDevice are to
                       be directly accessed.
\param peerDevice    - Device on which the allocations to be directly accessed
                       by \p device reside.

\return
::cudaSuccess,
::cudaErrorInvalidDevice
\notefnerr

\sa ::cudaDeviceEnablePeerAccess,
::cudaDeviceDisablePeerAccess
</pre>
<p>brief Enables direct access to memory allocations on a peer device.</p>
<p>On success, all allocations from p peerDevice will immediately be accessible by the current device.  They will remain accessible until access is explicitly disabled using ::cudaDeviceDisablePeerAccess() or either device is reset using ::cudaDeviceReset().</p>
<p>Note that access granted by this call is unidirectional and that in order to access memory on the current device from p peerDevice, a separate symmetric call to ::cudaDeviceEnablePeerAccess() is required.</p>
<p>Each device can support a system-wide maximum of eight peer connections.</p>
<p>Peer access is not supported in 32 bit applications.</p>
<p>Returns ::cudaErrorInvalidDevice if ::cudaDeviceCanAccessPeer() indicates that the current device cannot directly access memory from p peerDevice.</p>
<p>Returns ::cudaErrorPeerAccessAlreadyEnabled if direct access of p peerDevice from the current device has already been enabled.</p>
<p>Returns ::cudaErrorInvalidValue if p flags is not 0.</p>
<p>param peerDevice  - Peer device to enable direct access to from the current device param flags       - Reserved for future use and must be set to 0</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidDevice, ::cudaErrorPeerAccessAlreadyEnabled, ::cudaErrorInvalidValue notefnerr</p>
<p>sa ::cudaDeviceCanAccessPeer, ::cudaDeviceDisablePeerAccess </p>
<p>brief Disables direct access to memory allocations on a peer device.</p>
<p>Returns ::cudaErrorPeerAccessNotEnabled if direct access to memory on p peerDevice has not yet been enabled from the current device.</p>
<p>param peerDevice - Peer device to disable direct access to</p>
<p>return ::cudaSuccess, ::cudaErrorPeerAccessNotEnabled, ::cudaErrorInvalidDevice notefnerr</p>
<p>sa ::cudaDeviceCanAccessPeer, ::cudaDeviceEnablePeerAccess </p>
<p>@} END CUDART_PEER defgroup CUDART_OPENGL OpenGL Interoperability defgroup CUDART_OPENGL_DEPRECATED OpenGL Interoperability <a class="reference internal" href="#DEPRECATED">DEPRECATED</a> defgroup CUDART_D3D9 Direct3D 9 Interoperability defgroup CUDART_D3D9_DEPRECATED Direct3D 9 Interoperability <a class="reference internal" href="#DEPRECATED">DEPRECATED</a> defgroup CUDART_D3D10 Direct3D 10 Interoperability defgroup CUDART_D3D10_DEPRECATED Direct3D 10 Interoperability <a class="reference internal" href="#DEPRECATED">DEPRECATED</a> defgroup CUDART_D3D11 Direct3D 11 Interoperability defgroup CUDART_D3D11_DEPRECATED Direct3D 11 Interoperability <a class="reference internal" href="#DEPRECATED">DEPRECATED</a> defgroup CUDART_VDPAU VDPAU Interoperability defgroup CUDART_EGL EGL Interoperability</p>
<p>defgroup CUDART_INTEROP Graphics Interoperability</p>
<p>___MANBRIEF___ graphics interoperability functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the graphics interoperability functions of the CUDA runtime application programming interface.</p>
<p>@{</p>
<p>brief Unregisters a graphics resource for access by CUDA</p>
<p>Unregisters the graphics resource p resource so it is not accessible by CUDA unless registered again.</p>
<p>If p resource is invalid then ::cudaErrorInvalidResourceHandle is returned.</p>
<p>param resource - Resource to unregister</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle, ::cudaErrorUnknown notefnerr</p>
<p>sa ::cudaGraphicsD3D9RegisterResource, ::cudaGraphicsD3D10RegisterResource, ::cudaGraphicsD3D11RegisterResource, ::cudaGraphicsGLRegisterBuffer, ::cudaGraphicsGLRegisterImage </p>
<p>brief Set usage flags for mapping a graphics resource</p>
<p>Set p flags for mapping the graphics resource p resource.</p>
<p>Changes to p flags will take effect the next time p resource is mapped. The p flags argument may be any of the following:</p>
<ul class="simple"><li>::cudaGraphicsMapFlagsNone: Specifies no hints about how p resource will be used. It is therefore assumed that CUDA may read from or write to p resource.</li>
<li>::cudaGraphicsMapFlagsReadOnly: Specifies that CUDA will not write to p resource.</li>
<li>::cudaGraphicsMapFlagsWriteDiscard: Specifies CUDA will not read from p resource and will write over the entire contents of p resource, so none of the data previously stored in p resource will be preserved.</li>
</ul>
<p>If p resource is presently mapped for access by CUDA then ::cudaErrorUnknown is returned. If p flags is not one of the above values then ::cudaErrorInvalidValue is returned.</p>
<p>param resource - Registered resource to set flags for param flags    - Parameters for resource mapping</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidResourceHandle, ::cudaErrorUnknown, notefnerr</p>
<p>sa ::cudaGraphicsMapResources </p>
<p>brief Map graphics resources for access by CUDA</p>
<p>Maps the p count graphics resources in p resources for access by CUDA.</p>
<p>The resources in p resources may be accessed by CUDA until they are unmapped. The graphics API from which p resources were registered should not access any resources while they are mapped by CUDA. If an application does so, the results are undefined.</p>
<p>This function provides the synchronization guarantee that any graphics calls issued before ::cudaGraphicsMapResources() will complete before any subsequent CUDA work issued in p stream begins.</p>
<p>If p resources contains any duplicate entries then ::cudaErrorInvalidResourceHandle is returned. If any of p resources are presently mapped for access by CUDA then ::cudaErrorUnknown is returned.</p>
<p>param count     - Number of resources to map param resources - Resources to map for CUDA param stream    - Stream for synchronization</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle, ::cudaErrorUnknown note_null_stream notefnerr</p>
<p>sa ::cudaGraphicsResourceGetMappedPointer, ::cudaGraphicsSubResourceGetMappedArray, ::cudaGraphicsUnmapResources </p>
<p>brief Unmap graphics resources.</p>
<p>Unmaps the p count graphics resources in p resources.</p>
<p>Once unmapped, the resources in p resources may not be accessed by CUDA until they are mapped again.</p>
<p>This function provides the synchronization guarantee that any CUDA work issued in p stream before ::cudaGraphicsUnmapResources() will complete before any subsequently issued graphics work begins.</p>
<p>If p resources contains any duplicate entries then ::cudaErrorInvalidResourceHandle is returned. If any of p resources are not presently mapped for access by CUDA then ::cudaErrorUnknown is returned.</p>
<p>param count     - Number of resources to unmap param resources - Resources to unmap param stream    - Stream for synchronization</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidResourceHandle, ::cudaErrorUnknown note_null_stream notefnerr</p>
<p>sa ::cudaGraphicsMapResources </p>
<pre>
\brief Get an device pointer through which to access a mapped graphics resource.

Returns in \p *devPtr a pointer through which the mapped graphics resource
\p resource may be accessed.
Returns in \p *size the size of the memory in bytes which may be accessed from that pointer.
The value set in \p devPtr may change every time that \p resource is mapped.

If \p resource is not a buffer then it cannot be accessed via a pointer and
::cudaErrorUnknown is returned.
If \p resource is not mapped then ::cudaErrorUnknown is returned.
*
\param devPtr     - Returned pointer through which \p resource may be accessed
\param size       - Returned size of the buffer accessible starting at \p *devPtr
\param resource   - Mapped resource to access

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidResourceHandle,
::cudaErrorUnknown
\notefnerr

\sa
::cudaGraphicsMapResources,
::cudaGraphicsSubResourceGetMappedArray
</pre>
<pre>
\brief Get an array through which to access a subresource of a mapped graphics resource.

Returns in \p *array an array through which the subresource of the mapped
graphics resource \p resource which corresponds to array index \p arrayIndex
and mipmap level \p mipLevel may be accessed.  The value set in \p array may
change every time that \p resource is mapped.

If \p resource is not a texture then it cannot be accessed via an array and
::cudaErrorUnknown is returned.
If \p arrayIndex is not a valid array index for \p resource then
::cudaErrorInvalidValue is returned.
If \p mipLevel is not a valid mipmap level for \p resource then
::cudaErrorInvalidValue is returned.
If \p resource is not mapped then ::cudaErrorUnknown is returned.

\param array       - Returned array through which a subresource of \p resource may be accessed
\param resource    - Mapped resource to access
\param arrayIndex  - Array index for array textures or cubemap face
                     index as defined by ::cudaGraphicsCubeFace for
                     cubemap textures for the subresource to access
\param mipLevel    - Mipmap level for the subresource to access

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidResourceHandle,
::cudaErrorUnknown
\notefnerr

\sa ::cudaGraphicsResourceGetMappedPointer
</pre>
<pre>
\brief Get a mipmapped array through which to access a mapped graphics resource.

Returns in \p *mipmappedArray a mipmapped array through which the mapped
graphics resource \p resource may be accessed. The value set in \p mipmappedArray may
change every time that \p resource is mapped.

If \p resource is not a texture then it cannot be accessed via an array and
::cudaErrorUnknown is returned.
If \p resource is not mapped then ::cudaErrorUnknown is returned.

\param mipmappedArray - Returned mipmapped array through which \p resource may be accessed
\param resource       - Mapped resource to access

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidResourceHandle,
::cudaErrorUnknown
\notefnerr

\sa ::cudaGraphicsResourceGetMappedPointer
</pre>
<pre>@}
END CUDART_INTEROP

\defgroup CUDART_TEXTURE Texture Reference Management

___MANBRIEF___ texture reference management functions of the CUDA runtime
API (___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the low level texture reference management functions
of the CUDA runtime application programming interface.

Some functions have overloaded C++ API template versions documented separately in the
\ref CUDART_HIGHLEVEL &quot;C++ API Routines&quot; module.

@{


\brief Get the channel descriptor of an array

Returns in \p *desc the channel descriptor of the CUDA array \p array.

\param desc  - Channel format
\param array - Memory array on device

\return
::cudaSuccess,
::cudaErrorInvalidValue
\notefnerr

\sa \ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;,
::cudaGetTextureReference,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture (C API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;,
\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) &quot;cudaBindTextureToArray (C API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaUnbindTexture (C API)&quot;,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) &quot;cudaGetTextureAlignmentOffset (C API)&quot;
</pre>
<pre>
\brief Returns a channel descriptor using the specified format

Returns a channel descriptor with format \p f and number of bits of each
component \p x, \p y, \p z, and \p w.  The ::cudaChannelFormatDesc is
defined as:
\code
 struct cudaChannelFormatDesc {
   int x, y, z, w;
   enum cudaChannelFormatKind f;
 };
\endcode

where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,
::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.

\param x - X component
\param y - Y component
\param z - Z component
\param w - W component
\param f - Channel format

\return
Channel descriptor with format \p f

\sa \ref ::cudaCreateChannelDesc(void) &quot;cudaCreateChannelDesc (C++ API)&quot;,
::cudaGetChannelDesc, ::cudaGetTextureReference,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture (C API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;,
\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) &quot;cudaBindTextureToArray (C API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaUnbindTexture (C API)&quot;,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) &quot;cudaGetTextureAlignmentOffset (C API)&quot;
</pre>
<pre>
\brief Binds a memory area to a texture

Binds \p size bytes of the memory area pointed to by \p devPtr to the
texture reference \p texref. \p desc describes how the memory is interpreted
when fetching values from the texture. Any memory previously bound to
\p texref is unbound.

Since the hardware enforces an alignment requirement on texture base
addresses,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture()&quot;
returns in \p *offset a byte offset that
must be applied to texture fetches in order to read from the desired memory.
This offset must be divided by the texel size and passed to kernels that
read from the texture so they can be applied to the ::tex1Dfetch() function.
If the device memory pointer was returned from ::cudaMalloc(), the offset is
guaranteed to be 0 and NULL may be passed as the \p offset parameter.

The total number of elements (or texels) in the linear address range
cannot exceed ::cudaDeviceProp::maxTexture1DLinear[0].
The number of elements is computed as (\p size / elementSize),
where elementSize is determined from \p desc.

\param offset - Offset in bytes
\param texref - Texture to bind
\param devPtr - Memory area on device
\param desc   - Channel format
\param size   - Size of the memory area pointed to by devPtr

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidDevicePointer,
::cudaErrorInvalidTexture
\notefnerr

\sa \ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;,
::cudaGetChannelDesc, ::cudaGetTextureReference,
\ref ::cudaBindTexture(size_t*, const struct texture&lt; T, dim, readMode&gt;&amp;, const void*, const struct cudaChannelFormatDesc&amp;, size_t) &quot;cudaBindTexture (C++ API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;,
\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) &quot;cudaBindTextureToArray (C API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaUnbindTexture (C API)&quot;,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) &quot;cudaGetTextureAlignmentOffset (C API)&quot;
</pre>
<pre>
\brief Binds a 2D memory area to a texture

Binds the 2D memory area pointed to by \p devPtr to the
texture reference \p texref. The size of the area is constrained by
\p width in texel units, \p height in texel units, and \p pitch in byte
units. \p desc describes how the memory is interpreted when fetching values
from the texture. Any memory previously bound to \p texref is unbound.

Since the hardware enforces an alignment requirement on texture base
addresses, ::cudaBindTexture2D() returns in \p *offset a byte offset that
must be applied to texture fetches in order to read from the desired memory.
This offset must be divided by the texel size and passed to kernels that
read from the texture so they can be applied to the ::tex2D() function.
If the device memory pointer was returned from ::cudaMalloc(), the offset is
guaranteed to be 0 and NULL may be passed as the \p offset parameter.

\p width and \p height, which are specified in elements (or texels), cannot
exceed ::cudaDeviceProp::maxTexture2DLinear[0] and ::cudaDeviceProp::maxTexture2DLinear[1]
respectively. \p pitch, which is specified in bytes, cannot exceed
::cudaDeviceProp::maxTexture2DLinear[2].

The driver returns ::cudaErrorInvalidValue if \p pitch is not a multiple of
::cudaDeviceProp::texturePitchAlignment.

\param offset - Offset in bytes
\param texref - Texture reference to bind
\param devPtr - 2D memory area on device
\param desc   - Channel format
\param width  - Width in texel units
\param height - Height in texel units
\param pitch  - Pitch in bytes

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidDevicePointer,
::cudaErrorInvalidTexture
\notefnerr

\sa \ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;,
::cudaGetChannelDesc, ::cudaGetTextureReference,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture (C API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct texture&lt; T, dim, readMode&gt;&amp;, const void*, const struct cudaChannelFormatDesc&amp;, size_t, size_t, size_t) &quot;cudaBindTexture2D (C++ API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct texture&lt;T, dim, readMode&gt;&amp;, const void*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C++ API, inherited channel descriptor)&quot;,
\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) &quot;cudaBindTextureToArray (C API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaBindTextureToArray (C API)&quot;,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) &quot;cudaGetTextureAlignmentOffset (C API)&quot;
</pre>
<pre>
\brief Binds an array to a texture

Binds the CUDA array \p array to the texture reference \p texref.
\p desc describes how the memory is interpreted when fetching values from
the texture. Any CUDA array previously bound to \p texref is unbound.

\param texref - Texture to bind
\param array  - Memory array on device
\param desc   - Channel format

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidDevicePointer,
::cudaErrorInvalidTexture
\notefnerr

\sa \ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;,
::cudaGetChannelDesc, ::cudaGetTextureReference,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture (C API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;,
\ref ::cudaBindTextureToArray(const struct texture&lt; T, dim, readMode&gt;&amp;, cudaArray_const_t, const struct cudaChannelFormatDesc&amp;) &quot;cudaBindTextureToArray (C++ API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaUnbindTexture (C API)&quot;,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) &quot;cudaGetTextureAlignmentOffset (C API)&quot;
</pre>
<pre>
\brief Binds a mipmapped array to a texture

Binds the CUDA mipmapped array \p mipmappedArray to the texture reference \p texref.
\p desc describes how the memory is interpreted when fetching values from
the texture. Any CUDA mipmapped array previously bound to \p texref is unbound.

\param texref         - Texture to bind
\param mipmappedArray - Memory mipmapped array on device
\param desc           - Channel format

\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidDevicePointer,
::cudaErrorInvalidTexture
\notefnerr

\sa \ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;,
::cudaGetChannelDesc, ::cudaGetTextureReference,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture (C API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;,
\ref ::cudaBindTextureToArray(const struct texture&lt; T, dim, readMode&gt;&amp;, cudaArray_const_t, const struct cudaChannelFormatDesc&amp;) &quot;cudaBindTextureToArray (C++ API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaUnbindTexture (C API)&quot;,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) &quot;cudaGetTextureAlignmentOffset (C API)&quot;
</pre>
<p>brief Unbinds a texture</p>
<p>Unbinds the texture bound to p texref.</p>
<p>param texref - Texture to unbind</p>
<p>return ::cudaSuccess notefnerr</p>
<p>sa ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;, ::cudaGetChannelDesc, ::cudaGetTextureReference, ref ::cudaBindTexture(size_t<em>, const struct textureReference</em>, const void<em>, const struct cudaChannelFormatDesc</em>, size_t) &quot;cudaBindTexture (C API)&quot;, ref ::cudaBindTexture2D(size_t<em>, const struct textureReference</em>, const void<em>, const struct cudaChannelFormatDesc</em>, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;, ref ::cudaBindTextureToArray(const struct textureReference<em>, cudaArray_const_t, const struct cudaChannelFormatDesc</em>) &quot;cudaBindTextureToArray (C API)&quot;, ref ::cudaUnbindTexture(const struct texture&lt; T, dim, readMode&gt;&amp;) &quot;cudaUnbindTexture (C++ API)&quot;, ref ::cudaGetTextureAlignmentOffset(size_t<em>, const struct textureReference</em>) &quot;cudaGetTextureAlignmentOffset (C API)&quot; </p>
<pre>
\brief Get the alignment offset of a texture

Returns in \p *offset the offset that was returned when texture reference
\p texref was bound.

\param offset - Offset of texture reference in bytes
\param texref - Texture to get offset of

\return
::cudaSuccess,
::cudaErrorInvalidTexture,
::cudaErrorInvalidTextureBinding
\notefnerr

\sa \ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;,
::cudaGetChannelDesc, ::cudaGetTextureReference,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture (C API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;,
\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) &quot;cudaBindTextureToArray (C API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaUnbindTexture (C API)&quot;,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture&lt; T, dim, readMode&gt;&amp;) &quot;cudaGetTextureAlignmentOffset (C++ API)&quot;
</pre>
<pre>
\brief Get the texture reference associated with a symbol

Returns in \p *texref the structure associated to the texture reference
defined by symbol \p symbol.

\param texref - Texture reference associated with symbol
\param symbol - Texture to get reference for

\return
::cudaSuccess,
::cudaErrorInvalidTexture
\notefnerr
\note_string_api_deprecation_50

\sa \ref ::cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind) &quot;cudaCreateChannelDesc (C API)&quot;,
::cudaGetChannelDesc,
\ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) &quot;cudaGetTextureAlignmentOffset (C API)&quot;,
\ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) &quot;cudaBindTexture (C API)&quot;,
\ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) &quot;cudaBindTexture2D (C API)&quot;,
\ref ::cudaBindTextureToArray(const struct textureReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) &quot;cudaBindTextureToArray (C API)&quot;,
\ref ::cudaUnbindTexture(const struct textureReference*) &quot;cudaUnbindTexture (C API)&quot;
</pre>
<p>@} END CUDART_TEXTURE</p>
<p>defgroup CUDART_SURFACE Surface Reference Management</p>
<p>___MANBRIEF___ surface reference management functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the low level surface reference management functions of the CUDA runtime application programming interface.</p>
<p>Some functions have overloaded C++ API template versions documented separately in the ref CUDART_HIGHLEVEL &quot;C++ API Routines&quot; module.</p>
<p>@{</p>
<p>brief Binds an array to a surface</p>
<p>Binds the CUDA array p array to the surface reference p surfref. p desc describes how the memory is interpreted when fetching values from the surface. Any CUDA array previously bound to p surfref is unbound.</p>
<p>param surfref - Surface to bind param array  - Memory array on device param desc   - Channel format</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue, ::cudaErrorInvalidSurface notefnerr</p>
<p>sa ref ::cudaBindSurfaceToArray(const struct surface&lt; T, dim&gt;&amp;, cudaArray_const_t, const struct cudaChannelFormatDesc&amp;) &quot;cudaBindSurfaceToArray (C++ API)&quot;, ref ::cudaBindSurfaceToArray(const struct surface&lt; T, dim&gt;&amp;, cudaArray_const_t) &quot;cudaBindSurfaceToArray (C++ API, inherited channel descriptor)&quot;, ::cudaGetSurfaceReference </p>
<pre>
\brief Get the surface reference associated with a symbol

Returns in \p *surfref the structure associated to the surface reference
defined by symbol \p symbol.

\param surfref - Surface reference associated with symbol
\param symbol - Surface to get reference for

\return
::cudaSuccess,
::cudaErrorInvalidSurface
\notefnerr
\note_string_api_deprecation_50

\sa \ref ::cudaBindSurfaceToArray(const struct surfaceReference*, cudaArray_const_t, const struct cudaChannelFormatDesc*) &quot;cudaBindSurfaceToArray (C API)&quot;
</pre>
<p>@} END CUDART_SURFACE</p>
<p>defgroup CUDART_TEXTURE_OBJECT Texture Object Management</p>
<p>___MANBRIEF___ texture object management functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the low level texture object management functions of the CUDA runtime application programming interface. The texture object API is only supported on devices of compute capability 3.0 or higher.</p>
<p>@{</p>
<p>brief Creates a texture object</p>
<p>Creates a texture object and returns it in p pTexObject. p pResDesc describes the data to texture from. p pTexDesc describes how the data should be sampled. p pResViewDesc is an optional argument that specifies an alternate format for the data described by p pResDesc, and also describes the subresource region to restrict access to when texturing. p pResViewDesc can only be specified if the type of resource is a CUDA array or a CUDA mipmapped array.</p>
<p>Texture objects are only supported on devices of compute capability 3.0 or higher. Additionally, a texture object is an opaque value, and, as such, should only be accessed through CUDA API calls.</p>
<p>The ::cudaResourceDesc structure is defined as: code struct cudaResourceDesc { enum cudaResourceType resType;</p>
<pre>union {
        struct {
                cudaArray_t array;
        } array;</pre>
<pre>struct {
    cudaMipmappedArray_t mipmap;
} mipmap;
         struct {
                 void *devPtr;
                 struct cudaChannelFormatDesc desc;
                 size_t sizeInBytes;
         } linear;
         struct {
                 void *devPtr;
                 struct cudaChannelFormatDesc desc;
                 size_t width;
                 size_t height;
                 size_t pitchInBytes;
         } pitch2D;
 } res;</pre>
<pre>};</pre>
<p>endcode where:</p>
<ul class="simple"><li>::cudaResourceDesc::resType specifies the type of resource to texture from.</li>
</ul>
<p>CUresourceType is defined as: code enum cudaResourceType { cudaResourceTypeArray          = 0x00, cudaResourceTypeMipmappedArray = 0x01, cudaResourceTypeLinear         = 0x02, cudaResourceTypePitch2D        = 0x03 }; endcode</p>
<p>par If ::cudaResourceDesc::resType is set to ::cudaResourceTypeArray, ::cudaResourceDesc::res::array::array must be set to a valid CUDA array handle.</p>
<p>par If ::cudaResourceDesc::resType is set to ::cudaResourceTypeMipmappedArray, ::cudaResourceDesc::res::mipmap::mipmap must be set to a valid CUDA mipmapped array handle and ::cudaTextureDesc::normalizedCoords must be set to true.</p>
<p>par If ::cudaResourceDesc::resType is set to ::cudaResourceTypeLinear, ::cudaResourceDesc::res::linear::devPtr must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment. ::cudaResourceDesc::res::linear::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::linear::sizeInBytes specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed ::cudaDeviceProp::maxTexture1DLinear. The number of elements is computed as (sizeInBytes / sizeof(desc)).</p>
<p>par If ::cudaResourceDesc::resType is set to ::cudaResourceTypePitch2D, ::cudaResourceDesc::res::pitch2D::devPtr must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment. ::cudaResourceDesc::res::pitch2D::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::pitch2D::width and ::cudaResourceDesc::res::pitch2D::height specify the width and height of the array in elements, and cannot exceed ::cudaDeviceProp::maxTexture2DLinear<a class="reference internal" href="#0">0</a> and ::cudaDeviceProp::maxTexture2DLinear<a class="reference internal" href="#1">1</a> respectively. ::cudaResourceDesc::res::pitch2D::pitchInBytes specifies the pitch between two rows in bytes and has to be aligned to ::cudaDeviceProp::texturePitchAlignment. Pitch cannot exceed ::cudaDeviceProp::maxTexture2DLinear<a class="reference internal" href="#2">2</a>.</p>
<p>The ::cudaTextureDesc struct is defined as code struct cudaTextureDesc { enum cudaTextureAddressMode addressMode<a class="reference internal" href="#3">3</a>; enum cudaTextureFilterMode  filterMode; enum cudaTextureReadMode    readMode; int                         sRGB; float                       borderColor<a class="reference internal" href="#4">4</a>; int                         normalizedCoords; unsigned int                maxAnisotropy; enum cudaTextureFilterMode  mipmapFilterMode; float                       mipmapLevelBias; float                       minMipmapLevelClamp; float                       maxMipmapLevelClamp; }; endcode where</p>
<ul class="simple"><li>::cudaTextureDesc::addressMode specifies the addressing mode for each dimension of the texture data. ::cudaTextureAddressMode is defined as: code enum cudaTextureAddressMode { cudaAddressModeWrap   = 0, cudaAddressModeClamp  = 1, cudaAddressModeMirror = 2, cudaAddressModeBorder = 3 }; endcode This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear. Also, if ::cudaTextureDesc::normalizedCoords is set to zero, ::cudaAddressModeWrap and ::cudaAddressModeMirror won't be supported and will be switched to ::cudaAddressModeClamp.</li>
<li>::cudaTextureDesc::filterMode specifies the filtering mode to be used when fetching from the texture. ::cudaTextureFilterMode is defined as: code enum cudaTextureFilterMode { cudaFilterModePoint  = 0, cudaFilterModeLinear = 1 }; endcode This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear.</li>
<li>::cudaTextureDesc::readMode specifies whether integer data should be converted to floating point or not. ::cudaTextureReadMode is defined as: code enum cudaTextureReadMode { cudaReadModeElementType     = 0, cudaReadModeNormalizedFloat = 1 }; endcode Note that this applies only to 8-bit and 16-bit integer formats. 32-bit integer format would not be promoted, regardless of whether or not this ::cudaTextureDesc::readMode is set ::cudaReadModeNormalizedFloat is specified.</li>
<li>::cudaTextureDesc::sRGB specifies whether sRGB to linear conversion should be performed during texture fetch.</li>
<li>::cudaTextureDesc::borderColor specifies the float values of color. where: ::cudaTextureDesc::borderColor<a class="reference internal" href="#0">0</a> contains value of 'R', ::cudaTextureDesc::borderColor<a class="reference internal" href="#1">1</a> contains value of 'G', ::cudaTextureDesc::borderColor<a class="reference internal" href="#2">2</a> contains value of 'B', ::cudaTextureDesc::borderColor<a class="reference internal" href="#3">3</a> contains value of 'A' Note that application using integer border color values will need to &lt;reinterpret_cast&gt; these values to float. The values are set only when the addressing mode specified by ::cudaTextureDesc::addressMode is cudaAddressModeBorder.</li>
<li>::cudaTextureDesc::normalizedCoords specifies whether the texture coordinates will be normalized or not.</li>
<li>::cudaTextureDesc::maxAnisotropy specifies the maximum anistropy ratio to be used when doing anisotropic filtering. This value will be clamped to the range <a class="reference internal" href="#1,16">1,16</a>.</li>
<li>::cudaTextureDesc::mipmapFilterMode specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels.</li>
<li>::cudaTextureDesc::mipmapLevelBias specifies the offset to be applied to the calculated mipmap level.</li>
<li>::cudaTextureDesc::minMipmapLevelClamp specifies the lower end of the mipmap level range to clamp access to.</li>
<li>::cudaTextureDesc::maxMipmapLevelClamp specifies the upper end of the mipmap level range to clamp access to.</li>
</ul>
<p>The ::cudaResourceViewDesc struct is defined as code struct cudaResourceViewDesc { enum cudaResourceViewFormat format; size_t                      width; size_t                      height; size_t                      depth; unsigned int                firstMipmapLevel; unsigned int                lastMipmapLevel; unsigned int                firstLayer; unsigned int                lastLayer; }; endcode where:</p>
<ul class="simple"><li>::cudaResourceViewDesc::format specifies how the data contained in the CUDA array or CUDA mipmapped array should be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a 32-bit unsigned integer format with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have a 32-bit unsigned int with 2 channels. The other BC formats require the underlying resource to have the same 32-bit unsigned int format but with 4 channels.</li>
<li>::cudaResourceViewDesc::width specifies the new width of the texture data. If the resource view format is a block compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats, this value has to be equal to that of the original resource.</li>
<li>::cudaResourceViewDesc::height specifies the new height of the texture data. If the resource view format is a block compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats, this value has to be equal to that of the original resource.</li>
<li>::cudaResourceViewDesc::depth specifies the new depth of the texture data. This value has to be equal to that of the original resource.</li>
<li>::cudaResourceViewDesc::firstMipmapLevel specifies the most detailed mipmap level. This will be the new mipmap level zero. For non-mipmapped resources, this value has to be zero.::cudaTextureDesc::minMipmapLevelClamp and ::cudaTextureDesc::maxMipmapLevelClamp will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified, then the actual minimum mipmap level clamp will be 3.2.</li>
<li>::cudaResourceViewDesc::lastMipmapLevel specifies the least detailed mipmap level. For non-mipmapped resources, this value has to be zero.</li>
<li>::cudaResourceViewDesc::firstLayer specifies the first layer index for layered textures. This will be the new layer zero. For non-layered resources, this value has to be zero.</li>
<li>::cudaResourceViewDesc::lastLayer specifies the last layer index for layered textures. For non-layered resources, this value has to be zero.</li>
</ul>
<p>param pTexObject   - Texture object to create param pResDesc     - Resource descriptor param pTexDesc     - Texture descriptor param pResViewDesc - Resource view descriptor</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaDestroyTextureObject </p>
<p>brief Destroys a texture object</p>
<p>Destroys the texture object specified by p texObject.</p>
<p>param texObject - Texture object to destroy</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaCreateTextureObject </p>
<p>brief Returns a texture object's resource descriptor</p>
<p>Returns the resource descriptor for the texture object specified by p texObject.</p>
<p>param pResDesc  - Resource descriptor param texObject - Texture object</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaCreateTextureObject </p>
<p>brief Returns a texture object's texture descriptor</p>
<p>Returns the texture descriptor for the texture object specified by p texObject.</p>
<p>param pTexDesc  - Texture descriptor param texObject - Texture object</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaCreateTextureObject </p>
<p>brief Returns a texture object's resource view descriptor</p>
<p>Returns the resource view descriptor for the texture object specified by p texObject. If no resource view was specified, ::cudaErrorInvalidValue is returned.</p>
<p>param pResViewDesc - Resource view descriptor param texObject    - Texture object</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaCreateTextureObject </p>
<p>@} END CUDART_TEXTURE_OBJECT</p>
<p>defgroup CUDART_SURFACE_OBJECT Surface Object Management</p>
<p>___MANBRIEF___ surface object management functions of the CUDA runtime API (___CURRENT_FILE___) ___ENDMANBRIEF___</p>
<p>This section describes the low level texture object management functions of the CUDA runtime application programming interface. The surface object API is only supported on devices of compute capability 3.0 or higher.</p>
<p>@{</p>
<p>brief Creates a surface object</p>
<p>Creates a surface object and returns it in p pSurfObject. p pResDesc describes the data to perform surface load/stores on. ::cudaResourceDesc::resType must be ::cudaResourceTypeArray and  ::cudaResourceDesc::res::array::array must be set to a valid CUDA array handle.</p>
<p>Surface objects are only supported on devices of compute capability 3.0 or higher. Additionally, a surface object is an opaque value, and, as such, should only be accessed through CUDA API calls.</p>
<p>param pSurfObject - Surface object to create param pResDesc    - Resource descriptor</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaDestroySurfaceObject </p>
<p>brief Destroys a surface object</p>
<p>Destroys the surface object specified by p surfObject.</p>
<p>param surfObject - Surface object to destroy</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaCreateSurfaceObject </p>
<p>brief Returns a surface object's resource descriptor Returns the resource descriptor for the surface object specified by p surfObject.</p>
<p>param pResDesc   - Resource descriptor param surfObject - Surface object</p>
<p>return ::cudaSuccess, ::cudaErrorInvalidValue</p>
<p>sa ::cudaCreateSurfaceObject </p>
<pre>@}
END CUDART_SURFACE_OBJECT

\defgroup CUDART__VERSION Version Management

@{


\brief Returns the CUDA driver version

Returns in \p *driverVersion the version number of the installed CUDA
driver. If no driver is installed, then 0 is returned as the driver
version (via \p driverVersion). This function automatically returns
::cudaErrorInvalidValue if the \p driverVersion argument is NULL.

\param driverVersion - Returns the CUDA driver version.

\return
::cudaSuccess,
::cudaErrorInvalidValue
\notefnerr

\sa ::cudaRuntimeGetVersion
</pre>
<pre>
\brief Returns the CUDA Runtime version

Returns in \p *runtimeVersion the version number of the installed CUDA
Runtime. This function automatically returns ::cudaErrorInvalidValue if
the \p runtimeVersion argument is NULL.

\param runtimeVersion - Returns the CUDA Runtime version.

\return
::cudaSuccess,
::cudaErrorInvalidValue

\sa ::cudaDriverGetVersion
</pre>
@} END CUDART__VERSION cond impl_private<pre>\endcond impl_private

\defgroup CUDART_HIGHLEVEL C++ API Routines

___MANBRIEF___ C++ high level API functions of the CUDA runtime API
(___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the C++ high level API functions of the CUDA runtime
application programming interface. To use these functions, your
application needs to be compiled with the \p nvcc compiler.

\brief C++-style interface built on top of CUDA runtime API


\defgroup CUDART_DRIVER Interactions with the CUDA Driver API

___MANBRIEF___ interactions between CUDA Driver API and CUDA Runtime API
(___CURRENT_FILE___) ___ENDMANBRIEF___

This section describes the interactions between the CUDA Driver API and the CUDA Runtime API

@{

\section CUDART_CUDA_primary Primary Contexts

There exists a one to one relationship between CUDA devices in the CUDA Runtime
API and ::CUcontext s in the CUDA Driver API within a process.  The specific
context which the CUDA Runtime API uses for a device is called the device's
primary context.  From the perspective of the CUDA Runtime API, a device and
its primary context are synonymous.

\section CUDART_CUDA_init Initialization and Tear-Down

CUDA Runtime API calls operate on the CUDA Driver API ::CUcontext which is current to
to the calling host thread.

The function ::cudaSetDevice() makes the primary context for the
specified device current to the calling thread by calling ::cuCtxSetCurrent().

The CUDA Runtime API will automatically initialize the primary context for
a device at the first CUDA Runtime API call which requires an active context.
If no ::CUcontext is current to the calling thread when a CUDA Runtime API call
which requires an active context is made, then the primary context for a device
will be selected, made current to the calling thread, and initialized.

The context which the CUDA Runtime API initializes will be initialized using
the parameters specified by the CUDA Runtime API functions
::cudaSetDeviceFlags(),
::cudaD3D9SetDirect3DDevice(),
::cudaD3D10SetDirect3DDevice(),
::cudaD3D11SetDirect3DDevice(),
::cudaGLSetGLDevice(), and
::cudaVDPAUSetVDPAUDevice().
Note that these functions will fail with ::cudaErrorSetOnActiveProcess if they are
called when the primary context for the specified device has already been initialized.
(or if the current device has already been initialized, in the case of
::cudaSetDeviceFlags()).

Primary contexts will remain active until they are explicitly deinitialized
using ::cudaDeviceReset().  The function ::cudaDeviceReset() will deinitialize the
primary context for the calling thread's current device immediately.  The context
will remain current to all of the threads that it was current to.  The next CUDA
Runtime API call on any thread which requires an active context will trigger the
reinitialization of that device's primary context.

Note that there is no reference counting of the primary context's lifetime.  It is
recommended that the primary context not be deinitialized except just before exit
or to recover from an unspecified launch failure.

\section CUDART_CUDA_context Context Interoperability

Note that the use of multiple ::CUcontext s per device within a single process
will substantially degrade performance and is strongly discouraged.  Instead,
it is highly recommended that the implicit one-to-one device-to-context mapping
for the process provided by the CUDA Runtime API be used.

If a non-primary ::CUcontext created by the CUDA Driver API is current to a
thread then the CUDA Runtime API calls to that thread will operate on that
::CUcontext, with some exceptions listed below.  Interoperability between data
types is discussed in the following sections.

The function ::cudaPointerGetAttributes() will return the error
::cudaErrorIncompatibleDriverContext if the pointer being queried was allocated by a
non-primary context.  The function ::cudaDeviceEnablePeerAccess() and the rest of
the peer access API may not be called when a non-primary ::CUcontext is current.
To use the pointer query and peer access APIs with a context created using the
CUDA Driver API, it is necessary that the CUDA Driver API be used to access
these features.

All CUDA Runtime API state (e.g, global variables' addresses and values) travels
with its underlying ::CUcontext.  In particular, if a ::CUcontext is moved from one
thread to another then all CUDA Runtime API state will move to that thread as well.

Please note that attaching to legacy contexts (those with a version of 3010 as returned
by ::cuCtxGetApiVersion()) is not possible. The CUDA Runtime will return
::cudaErrorIncompatibleDriverContext in such cases.

\section CUDART_CUDA_stream Interactions between CUstream and cudaStream_t

The types ::CUstream and ::cudaStream_t are identical and may be used interchangeably.

\section CUDART_CUDA_event Interactions between CUevent and cudaEvent_t

The types ::CUevent and ::cudaEvent_t are identical and may be used interchangeably.

\section CUDART_CUDA_array Interactions between CUarray and cudaArray_t

The types ::CUarray and struct ::cudaArray * represent the same data type and may be used
interchangeably by casting the two types between each other.

In order to use a ::CUarray in a CUDA Runtime API function which takes a struct ::cudaArray *,
it is necessary to explicitly cast the ::CUarray to a struct ::cudaArray *.

In order to use a struct ::cudaArray * in a CUDA Driver API function which takes a ::CUarray,
it is necessary to explicitly cast the struct ::cudaArray * to a ::CUarray .

\section CUDART_CUDA_graphicsResource Interactions between CUgraphicsResource and cudaGraphicsResource_t

The types ::CUgraphicsResource and ::cudaGraphicsResource_t represent the same data type and may be used
interchangeably by casting the two types between each other.

In order to use a ::CUgraphicsResource in a CUDA Runtime API function which takes a
::cudaGraphicsResource_t, it is necessary to explicitly cast the ::CUgraphicsResource
to a ::cudaGraphicsResource_t.

In order to use a ::cudaGraphicsResource_t in a CUDA Driver API function which takes a
::CUgraphicsResource, it is necessary to explicitly cast the ::cudaGraphicsResource_t
to a ::CUgraphicsResource.

@}
</pre>
</p>
    <div class="section" id="6">
  <h1><a class="toc-backref" href="#6">Imports</a></h1>
  <dl class="item">
    <a class="reference external" href="vector_types.html">vector_types</a>, <a class="reference external" href="driver_types.html">driver_types</a>, <a class="reference external" href="surface_types.html">surface_types</a>, <a class="reference external" href="texture_types.html">texture_types</a>
  </dl>
</div>
<div class="section" id="7">
  <h1><a class="toc-backref" href="#7">Types</a></h1>
  <dl class="item">
    <div id="cudaStreamCallback_t">
  <dt><pre><a href="cuda_runtime_api.html#cudaStreamCallback_t"><span class="Identifier">cudaStreamCallback_t</span></a> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">status</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a><span class="Other">;</span>
                             <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> {.<span class="Identifier">cdecl</span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

  </dl>
</div>
<div class="section" id="10">
  <h1><a class="toc-backref" href="#10">Consts</a></h1>
  <dl class="item">
    <div id="CUDART_VERSION">
  <dt><pre><a href="cuda_runtime_api.html#CUDART_VERSION"><span class="Identifier">CUDART_VERSION</span></a> <span class="Other">=</span> <span class="DecNumber">8000</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

  </dl>
</div>
<div class="section" id="12">
  <h1><a class="toc-backref" href="#12">Procs</a></h1>
  <dl class="item">
    <div id="cudaArrayGetInfo-procs-all">
  <div id="cudaArrayGetInfo,ptr.cudaChannelFormatDesc,ptr.cudaExtent,ptr.cuint,cudaArray_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaArrayGetInfo%2Cptr.cudaChannelFormatDesc%2Cptr.cudaExtent%2Cptr.cuint%2CcudaArray_t"><span class="Identifier">cudaArrayGetInfo</span></a><span class="Other">(</span><span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">;</span> <span class="Identifier">extent</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaExtent"><span class="Identifier">cudaExtent</span></a><span class="Other">;</span>
                      <span class="Identifier">flags</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuint</span><span class="Other">;</span> <span class="Identifier">array</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaArrayGetInfo&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaBindSurfaceToArray-procs-all">
  <div id="cudaBindSurfaceToArray,ptr.surfaceReference,cudaArray_const_t,ptr.cudaChannelFormatDesc">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaBindSurfaceToArray%2Cptr.surfaceReference%2CcudaArray_const_t%2Cptr.cudaChannelFormatDesc"><span class="Identifier">cudaBindSurfaceToArray</span></a><span class="Other">(</span><span class="Identifier">surfref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">surfaceReference</span><span class="Other">;</span>
                            <span class="Identifier">array</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span>
                            <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaBindSurfaceToArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaBindTexture-procs-all">
  <div id="cudaBindTexture,ptr.csize_t,ptr.textureReference,pointer,ptr.cudaChannelFormatDesc,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaBindTexture%2Cptr.csize_t%2Cptr.textureReference%2Cpointer%2Cptr.cudaChannelFormatDesc%2Ccsize_t"><span class="Identifier">cudaBindTexture</span></a><span class="Other">(</span><span class="Identifier">offset</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">texref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">textureReference</span><span class="Other">;</span>
                     <span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">;</span>
                     <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaBindTexture&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaBindTexture2D-procs-all">
  <div id="cudaBindTexture2D,ptr.csize_t,ptr.textureReference,pointer,ptr.cudaChannelFormatDesc,csize_t,csize_t,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaBindTexture2D%2Cptr.csize_t%2Cptr.textureReference%2Cpointer%2Cptr.cudaChannelFormatDesc%2Ccsize_t%2Ccsize_t%2Ccsize_t"><span class="Identifier">cudaBindTexture2D</span></a><span class="Other">(</span><span class="Identifier">offset</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">texref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">textureReference</span><span class="Other">;</span>
                       <span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">;</span>
                       <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">pitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaBindTexture2D&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaBindTextureToArray-procs-all">
  <div id="cudaBindTextureToArray,ptr.textureReference,cudaArray_const_t,ptr.cudaChannelFormatDesc">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaBindTextureToArray%2Cptr.textureReference%2CcudaArray_const_t%2Cptr.cudaChannelFormatDesc"><span class="Identifier">cudaBindTextureToArray</span></a><span class="Other">(</span><span class="Identifier">texref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">textureReference</span><span class="Other">;</span>
                            <span class="Identifier">array</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span>
                            <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaBindTextureToArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaBindTextureToMipmappedArray-procs-all">
  <div id="cudaBindTextureToMipmappedArray,ptr.textureReference,cudaMipmappedArray_const_t,ptr.cudaChannelFormatDesc">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaBindTextureToMipmappedArray%2Cptr.textureReference%2CcudaMipmappedArray_const_t%2Cptr.cudaChannelFormatDesc"><span class="Identifier">cudaBindTextureToMipmappedArray</span></a><span class="Other">(</span><span class="Identifier">texref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">textureReference</span><span class="Other">;</span>
    <span class="Identifier">mipmappedArray</span><span class="Other">:</span> <a href="driver_types.html#cudaMipmappedArray_const_t"><span class="Identifier">cudaMipmappedArray_const_t</span></a><span class="Other">;</span> <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaBindTextureToMipmappedArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaChooseDevice-procs-all">
  <div id="cudaChooseDevice,ptr.cint,ptr.cudaDeviceProp">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaChooseDevice%2Cptr.cint%2Cptr.cudaDeviceProp"><span class="Identifier">cudaChooseDevice</span></a><span class="Other">(</span><span class="Identifier">device</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">prop</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaDeviceProp"><span class="Identifier">cudaDeviceProp</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaChooseDevice&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaConfigureCall-procs-all">
  <div id="cudaConfigureCall,dim3,dim3,csize_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaConfigureCall%2Cdim3%2Cdim3%2Ccsize_t%2CcudaStream_t"><span class="Identifier">cudaConfigureCall</span></a><span class="Other">(</span><span class="Identifier">gridDim</span><span class="Other">:</span> <a href="vector_types.html#dim3"><span class="Identifier">dim3</span></a><span class="Other">;</span> <span class="Identifier">blockDim</span><span class="Other">:</span> <a href="vector_types.html#dim3"><span class="Identifier">dim3</span></a><span class="Other">;</span> <span class="Identifier">sharedMem</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                       <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaConfigureCall&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaCreateChannelDesc-procs-all">
  <div id="cudaCreateChannelDesc,cint,cint,cint,cint,cudaChannelFormatKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaCreateChannelDesc%2Ccint%2Ccint%2Ccint%2Ccint%2CcudaChannelFormatKind"><span class="Identifier">cudaCreateChannelDesc</span></a><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">y</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">z</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">w</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                           <span class="Identifier">f</span><span class="Other">:</span> <a href="driver_types.html#cudaChannelFormatKind"><span class="Identifier">cudaChannelFormatKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaCreateChannelDesc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaCreateSurfaceObject-procs-all">
  <div id="cudaCreateSurfaceObject,ptr.cudaSurfaceObject_t,ptr.cudaResourceDesc">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaCreateSurfaceObject%2Cptr.cudaSurfaceObject_t%2Cptr.cudaResourceDesc"><span class="Identifier">cudaCreateSurfaceObject</span></a><span class="Other">(</span><span class="Identifier">pSurfObject</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="surface_types.html#cudaSurfaceObject_t"><span class="Identifier">cudaSurfaceObject_t</span></a><span class="Other">;</span>
                             <span class="Identifier">pResDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaResourceDesc"><span class="Identifier">cudaResourceDesc</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaCreateSurfaceObject&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaCreateTextureObject-procs-all">
  <div id="cudaCreateTextureObject,ptr.cudaTextureObject_t,ptr.cudaResourceDesc,ptr.cudaTextureDesc,ptr.cudaResourceViewDesc">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaCreateTextureObject%2Cptr.cudaTextureObject_t%2Cptr.cudaResourceDesc%2Cptr.cudaTextureDesc%2Cptr.cudaResourceViewDesc"><span class="Identifier">cudaCreateTextureObject</span></a><span class="Other">(</span><span class="Identifier">pTexObject</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="texture_types.html#cudaTextureObject_t"><span class="Identifier">cudaTextureObject_t</span></a><span class="Other">;</span>
                             <span class="Identifier">pResDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaResourceDesc"><span class="Identifier">cudaResourceDesc</span></a><span class="Other">;</span>
                             <span class="Identifier">pTexDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="texture_types.html#cudaTextureDesc"><span class="Identifier">cudaTextureDesc</span></a><span class="Other">;</span>
                             <span class="Identifier">pResViewDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaResourceViewDesc"><span class="Identifier">cudaResourceViewDesc</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaCreateTextureObject&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDestroySurfaceObject-procs-all">
  <div id="cudaDestroySurfaceObject,cudaSurfaceObject_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDestroySurfaceObject%2CcudaSurfaceObject_t"><span class="Identifier">cudaDestroySurfaceObject</span></a><span class="Other">(</span><span class="Identifier">surfObject</span><span class="Other">:</span> <a href="surface_types.html#cudaSurfaceObject_t"><span class="Identifier">cudaSurfaceObject_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDestroySurfaceObject&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDestroyTextureObject-procs-all">
  <div id="cudaDestroyTextureObject,cudaTextureObject_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDestroyTextureObject%2CcudaTextureObject_t"><span class="Identifier">cudaDestroyTextureObject</span></a><span class="Other">(</span><span class="Identifier">texObject</span><span class="Other">:</span> <a href="texture_types.html#cudaTextureObject_t"><span class="Identifier">cudaTextureObject_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDestroyTextureObject&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceCanAccessPeer-procs-all">
  <div id="cudaDeviceCanAccessPeer,ptr.cint,cint,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceCanAccessPeer%2Cptr.cint%2Ccint%2Ccint"><span class="Identifier">cudaDeviceCanAccessPeer</span></a><span class="Other">(</span><span class="Identifier">canAccessPeer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                             <span class="Identifier">peerDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceCanAccessPeer&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceDisablePeerAccess-procs-all">
  <div id="cudaDeviceDisablePeerAccess,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceDisablePeerAccess%2Ccint"><span class="Identifier">cudaDeviceDisablePeerAccess</span></a><span class="Other">(</span><span class="Identifier">peerDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceDisablePeerAccess&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceEnablePeerAccess-procs-all">
  <div id="cudaDeviceEnablePeerAccess,cint,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceEnablePeerAccess%2Ccint%2Ccuint"><span class="Identifier">cudaDeviceEnablePeerAccess</span></a><span class="Other">(</span><span class="Identifier">peerDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceEnablePeerAccess&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetAttribute-procs-all">
  <div id="cudaDeviceGetAttribute,ptr.cint,cudaDeviceAttr,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetAttribute%2Cptr.cint%2CcudaDeviceAttr%2Ccint"><span class="Identifier">cudaDeviceGetAttribute</span></a><span class="Other">(</span><span class="Identifier">value</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">attr</span><span class="Other">:</span> <a href="driver_types.html#cudaDeviceAttr"><span class="Identifier">cudaDeviceAttr</span></a><span class="Other">;</span> <span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetAttribute&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetByPCIBusId-procs-all">
  <div id="cudaDeviceGetByPCIBusId,ptr.cint,cstring">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetByPCIBusId%2Cptr.cint%2Ccstring"><span class="Identifier">cudaDeviceGetByPCIBusId</span></a><span class="Other">(</span><span class="Identifier">device</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">pciBusId</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetByPCIBusId&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetCacheConfig-procs-all">
  <div id="cudaDeviceGetCacheConfig,ptr.cudaFuncCache">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetCacheConfig%2Cptr.cudaFuncCache"><span class="Identifier">cudaDeviceGetCacheConfig</span></a><span class="Other">(</span><span class="Identifier">pCacheConfig</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaFuncCache"><span class="Identifier">cudaFuncCache</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetCacheConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetLimit-procs-all">
  <div id="cudaDeviceGetLimit,ptr.csize_t,cudaLimit">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetLimit%2Cptr.csize_t%2CcudaLimit"><span class="Identifier">cudaDeviceGetLimit</span></a><span class="Other">(</span><span class="Identifier">pValue</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">limit</span><span class="Other">:</span> <a href="driver_types.html#cudaLimit"><span class="Identifier">cudaLimit</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetLimit&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetP2PAttribute-procs-all">
  <div id="cudaDeviceGetP2PAttribute,ptr.cint,cudaDeviceP2PAttr,cint,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetP2PAttribute%2Cptr.cint%2CcudaDeviceP2PAttr%2Ccint%2Ccint"><span class="Identifier">cudaDeviceGetP2PAttribute</span></a><span class="Other">(</span><span class="Identifier">value</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">attr</span><span class="Other">:</span> <a href="driver_types.html#cudaDeviceP2PAttr"><span class="Identifier">cudaDeviceP2PAttr</span></a><span class="Other">;</span>
                               <span class="Identifier">srcDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">dstDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetP2PAttribute&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetPCIBusId-procs-all">
  <div id="cudaDeviceGetPCIBusId,cstring,cint,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetPCIBusId%2Ccstring%2Ccint%2Ccint"><span class="Identifier">cudaDeviceGetPCIBusId</span></a><span class="Other">(</span><span class="Identifier">pciBusId</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetPCIBusId&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetSharedMemConfig-procs-all">
  <div id="cudaDeviceGetSharedMemConfig,ptr.cudaSharedMemConfig">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetSharedMemConfig%2Cptr.cudaSharedMemConfig"><span class="Identifier">cudaDeviceGetSharedMemConfig</span></a><span class="Other">(</span><span class="Identifier">pConfig</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaSharedMemConfig"><span class="Identifier">cudaSharedMemConfig</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetSharedMemConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceGetStreamPriorityRange-procs-all">
  <div id="cudaDeviceGetStreamPriorityRange,ptr.cint,ptr.cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceGetStreamPriorityRange%2Cptr.cint%2Cptr.cint"><span class="Identifier">cudaDeviceGetStreamPriorityRange</span></a><span class="Other">(</span><span class="Identifier">leastPriority</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span>
                                      <span class="Identifier">greatestPriority</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceGetStreamPriorityRange&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceReset-procs-all">
  <div id="cudaDeviceReset">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceReset"><span class="Identifier">cudaDeviceReset</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceReset&quot;</span><span class="Other">,</span>
                                      <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
                                      <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceSetCacheConfig-procs-all">
  <div id="cudaDeviceSetCacheConfig,cudaFuncCache">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceSetCacheConfig%2CcudaFuncCache"><span class="Identifier">cudaDeviceSetCacheConfig</span></a><span class="Other">(</span><span class="Identifier">cacheConfig</span><span class="Other">:</span> <a href="driver_types.html#cudaFuncCache"><span class="Identifier">cudaFuncCache</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceSetCacheConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceSetLimit-procs-all">
  <div id="cudaDeviceSetLimit,cudaLimit,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceSetLimit%2CcudaLimit%2Ccsize_t"><span class="Identifier">cudaDeviceSetLimit</span></a><span class="Other">(</span><span class="Identifier">limit</span><span class="Other">:</span> <a href="driver_types.html#cudaLimit"><span class="Identifier">cudaLimit</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceSetLimit&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceSetSharedMemConfig-procs-all">
  <div id="cudaDeviceSetSharedMemConfig,cudaSharedMemConfig">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceSetSharedMemConfig%2CcudaSharedMemConfig"><span class="Identifier">cudaDeviceSetSharedMemConfig</span></a><span class="Other">(</span><span class="Identifier">config</span><span class="Other">:</span> <a href="driver_types.html#cudaSharedMemConfig"><span class="Identifier">cudaSharedMemConfig</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceSetSharedMemConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDeviceSynchronize-procs-all">
  <div id="cudaDeviceSynchronize">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDeviceSynchronize"><span class="Identifier">cudaDeviceSynchronize</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDeviceSynchronize&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaDriverGetVersion-procs-all">
  <div id="cudaDriverGetVersion,ptr.cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaDriverGetVersion%2Cptr.cint"><span class="Identifier">cudaDriverGetVersion</span></a><span class="Other">(</span><span class="Identifier">driverVersion</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaDriverGetVersion&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaEventCreate-procs-all">
  <div id="cudaEventCreate,ptr.cudaEvent_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaEventCreate%2Cptr.cudaEvent_t"><span class="Identifier">cudaEventCreate</span></a><span class="Other">(</span><span class="Identifier">event</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaEventCreate&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaEventCreateWithFlags-procs-all">
  <div id="cudaEventCreateWithFlags,ptr.cudaEvent_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaEventCreateWithFlags%2Cptr.cudaEvent_t%2Ccuint"><span class="Identifier">cudaEventCreateWithFlags</span></a><span class="Other">(</span><span class="Identifier">event</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaEventCreateWithFlags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaEventDestroy-procs-all">
  <div id="cudaEventDestroy,cudaEvent_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaEventDestroy%2CcudaEvent_t"><span class="Identifier">cudaEventDestroy</span></a><span class="Other">(</span><span class="Identifier">event</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaEventDestroy&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaEventElapsedTime-procs-all">
  <div id="cudaEventElapsedTime,ptr.cfloat,cudaEvent_t,cudaEvent_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaEventElapsedTime%2Cptr.cfloat%2CcudaEvent_t%2CcudaEvent_t"><span class="Identifier">cudaEventElapsedTime</span></a><span class="Other">(</span><span class="Identifier">ms</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cfloat</span><span class="Other">;</span> <span class="Identifier">start</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">;</span> <span class="Identifier">end</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaEventElapsedTime&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaEventQuery-procs-all">
  <div id="cudaEventQuery,cudaEvent_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaEventQuery%2CcudaEvent_t"><span class="Identifier">cudaEventQuery</span></a><span class="Other">(</span><span class="Identifier">event</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaEventQuery&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaEventRecord-procs-all">
  <div id="cudaEventRecord,cudaEvent_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaEventRecord%2CcudaEvent_t%2CcudaStream_t"><span class="Identifier">cudaEventRecord</span></a><span class="Other">(</span><span class="Identifier">event</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaEventRecord&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaEventSynchronize-procs-all">
  <div id="cudaEventSynchronize,cudaEvent_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaEventSynchronize%2CcudaEvent_t"><span class="Identifier">cudaEventSynchronize</span></a><span class="Other">(</span><span class="Identifier">event</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaEventSynchronize&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaFree-procs-all">
  <div id="cudaFree,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaFree%2Cpointer"><span class="Identifier">cudaFree</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaFree&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaFreeArray-procs-all">
  <div id="cudaFreeArray,cudaArray_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaFreeArray%2CcudaArray_t"><span class="Identifier">cudaFreeArray</span></a><span class="Other">(</span><span class="Identifier">array</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaFreeArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaFreeHost-procs-all">
  <div id="cudaFreeHost,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaFreeHost%2Cpointer"><span class="Identifier">cudaFreeHost</span></a><span class="Other">(</span><span class="Identifier">ptr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaFreeHost&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaFreeMipmappedArray-procs-all">
  <div id="cudaFreeMipmappedArray,cudaMipmappedArray_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaFreeMipmappedArray%2CcudaMipmappedArray_t"><span class="Identifier">cudaFreeMipmappedArray</span></a><span class="Other">(</span><span class="Identifier">mipmappedArray</span><span class="Other">:</span> <a href="driver_types.html#cudaMipmappedArray_t"><span class="Identifier">cudaMipmappedArray_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaFreeMipmappedArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaFuncGetAttributes-procs-all">
  <div id="cudaFuncGetAttributes,ptr.cudaFuncAttributes,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaFuncGetAttributes%2Cptr.cudaFuncAttributes%2Cpointer"><span class="Identifier">cudaFuncGetAttributes</span></a><span class="Other">(</span><span class="Identifier">attr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaFuncAttributes"><span class="Identifier">cudaFuncAttributes</span></a><span class="Other">;</span> <span class="Identifier">func</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaFuncGetAttributes&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaFuncSetCacheConfig-procs-all">
  <div id="cudaFuncSetCacheConfig,pointer,cudaFuncCache">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaFuncSetCacheConfig%2Cpointer%2CcudaFuncCache"><span class="Identifier">cudaFuncSetCacheConfig</span></a><span class="Other">(</span><span class="Identifier">func</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">cacheConfig</span><span class="Other">:</span> <a href="driver_types.html#cudaFuncCache"><span class="Identifier">cudaFuncCache</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaFuncSetCacheConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaFuncSetSharedMemConfig-procs-all">
  <div id="cudaFuncSetSharedMemConfig,pointer,cudaSharedMemConfig">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaFuncSetSharedMemConfig%2Cpointer%2CcudaSharedMemConfig"><span class="Identifier">cudaFuncSetSharedMemConfig</span></a><span class="Other">(</span><span class="Identifier">func</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">config</span><span class="Other">:</span> <a href="driver_types.html#cudaSharedMemConfig"><span class="Identifier">cudaSharedMemConfig</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaFuncSetSharedMemConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetChannelDesc-procs-all">
  <div id="cudaGetChannelDesc,ptr.cudaChannelFormatDesc,cudaArray_const_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetChannelDesc%2Cptr.cudaChannelFormatDesc%2CcudaArray_const_t"><span class="Identifier">cudaGetChannelDesc</span></a><span class="Other">(</span><span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">;</span>
                        <span class="Identifier">array</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetChannelDesc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetDevice-procs-all">
  <div id="cudaGetDevice,ptr.cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetDevice%2Cptr.cint"><span class="Identifier">cudaGetDevice</span></a><span class="Other">(</span><span class="Identifier">device</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetDevice&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetDeviceCount-procs-all">
  <div id="cudaGetDeviceCount,ptr.cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetDeviceCount%2Cptr.cint"><span class="Identifier">cudaGetDeviceCount</span></a><span class="Other">(</span><span class="Identifier">count</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetDeviceCount&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetDeviceFlags-procs-all">
  <div id="cudaGetDeviceFlags,ptr.cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetDeviceFlags%2Cptr.cuint"><span class="Identifier">cudaGetDeviceFlags</span></a><span class="Other">(</span><span class="Identifier">flags</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetDeviceFlags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetDeviceProperties-procs-all">
  <div id="cudaGetDeviceProperties,ptr.cudaDeviceProp,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetDeviceProperties%2Cptr.cudaDeviceProp%2Ccint"><span class="Identifier">cudaGetDeviceProperties</span></a><span class="Other">(</span><span class="Identifier">prop</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaDeviceProp"><span class="Identifier">cudaDeviceProp</span></a><span class="Other">;</span> <span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetDeviceProperties&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetErrorName-procs-all">
  <div id="cudaGetErrorName,cudaError">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetErrorName%2CcudaError"><span class="Identifier">cudaGetErrorName</span></a><span class="Other">(</span><span class="Identifier">error</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetErrorName&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetErrorString-procs-all">
  <div id="cudaGetErrorString,cudaError">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetErrorString%2CcudaError"><span class="Identifier">cudaGetErrorString</span></a><span class="Other">(</span><span class="Identifier">error</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetErrorString&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetExportTable-procs-all">
  <div id="cudaGetExportTable,ptr.pointer,ptr.cudaUUID_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetExportTable%2Cptr.pointer%2Cptr.cudaUUID_t"><span class="Identifier">cudaGetExportTable</span></a><span class="Other">(</span><span class="Identifier">ppExportTable</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                        <span class="Identifier">pExportTableId</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaUUID_t"><span class="Identifier">cudaUUID_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetExportTable&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetLastError-procs-all">
  <div id="cudaGetLastError">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetLastError"><span class="Identifier">cudaGetLastError</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetLastError&quot;</span><span class="Other">,</span>
                                       <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
                                       <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetMipmappedArrayLevel-procs-all">
  <div id="cudaGetMipmappedArrayLevel,ptr.cudaArray_t,cudaMipmappedArray_const_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetMipmappedArrayLevel%2Cptr.cudaArray_t%2CcudaMipmappedArray_const_t%2Ccuint"><span class="Identifier">cudaGetMipmappedArrayLevel</span></a><span class="Other">(</span><span class="Identifier">levelArray</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span>
                                <span class="Identifier">mipmappedArray</span><span class="Other">:</span> <a href="driver_types.html#cudaMipmappedArray_const_t"><span class="Identifier">cudaMipmappedArray_const_t</span></a><span class="Other">;</span>
                                <span class="Identifier">level</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetMipmappedArrayLevel&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetSurfaceObjectResourceDesc-procs-all">
  <div id="cudaGetSurfaceObjectResourceDesc,ptr.cudaResourceDesc,cudaSurfaceObject_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetSurfaceObjectResourceDesc%2Cptr.cudaResourceDesc%2CcudaSurfaceObject_t"><span class="Identifier">cudaGetSurfaceObjectResourceDesc</span></a><span class="Other">(</span><span class="Identifier">pResDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaResourceDesc"><span class="Identifier">cudaResourceDesc</span></a><span class="Other">;</span>
                                      <span class="Identifier">surfObject</span><span class="Other">:</span> <a href="surface_types.html#cudaSurfaceObject_t"><span class="Identifier">cudaSurfaceObject_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetSurfaceObjectResourceDesc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetSurfaceReference-procs-all">
  <div id="cudaGetSurfaceReference,ptr.ptr.surfaceReference,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetSurfaceReference%2Cptr.ptr.surfaceReference%2Cpointer"><span class="Identifier">cudaGetSurfaceReference</span></a><span class="Other">(</span><span class="Identifier">surfref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">surfaceReference</span><span class="Other">;</span> <span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetSurfaceReference&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetSymbolAddress-procs-all">
  <div id="cudaGetSymbolAddress,ptr.pointer,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetSymbolAddress%2Cptr.pointer%2Cpointer"><span class="Identifier">cudaGetSymbolAddress</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetSymbolAddress&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetSymbolSize-procs-all">
  <div id="cudaGetSymbolSize,ptr.csize_t,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetSymbolSize%2Cptr.csize_t%2Cpointer"><span class="Identifier">cudaGetSymbolSize</span></a><span class="Other">(</span><span class="Identifier">size</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetSymbolSize&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetTextureAlignmentOffset-procs-all">
  <div id="cudaGetTextureAlignmentOffset,ptr.csize_t,ptr.textureReference">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetTextureAlignmentOffset%2Cptr.csize_t%2Cptr.textureReference"><span class="Identifier">cudaGetTextureAlignmentOffset</span></a><span class="Other">(</span><span class="Identifier">offset</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                                   <span class="Identifier">texref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">textureReference</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetTextureAlignmentOffset&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetTextureObjectResourceDesc-procs-all">
  <div id="cudaGetTextureObjectResourceDesc,ptr.cudaResourceDesc,cudaTextureObject_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetTextureObjectResourceDesc%2Cptr.cudaResourceDesc%2CcudaTextureObject_t"><span class="Identifier">cudaGetTextureObjectResourceDesc</span></a><span class="Other">(</span><span class="Identifier">pResDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaResourceDesc"><span class="Identifier">cudaResourceDesc</span></a><span class="Other">;</span>
                                      <span class="Identifier">texObject</span><span class="Other">:</span> <a href="texture_types.html#cudaTextureObject_t"><span class="Identifier">cudaTextureObject_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetTextureObjectResourceDesc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetTextureObjectResourceViewDesc-procs-all">
  <div id="cudaGetTextureObjectResourceViewDesc,ptr.cudaResourceViewDesc,cudaTextureObject_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetTextureObjectResourceViewDesc%2Cptr.cudaResourceViewDesc%2CcudaTextureObject_t"><span class="Identifier">cudaGetTextureObjectResourceViewDesc</span></a><span class="Other">(</span>
    <span class="Identifier">pResViewDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaResourceViewDesc"><span class="Identifier">cudaResourceViewDesc</span></a><span class="Other">;</span> <span class="Identifier">texObject</span><span class="Other">:</span> <a href="texture_types.html#cudaTextureObject_t"><span class="Identifier">cudaTextureObject_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetTextureObjectResourceViewDesc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetTextureObjectTextureDesc-procs-all">
  <div id="cudaGetTextureObjectTextureDesc,ptr.cudaTextureDesc,cudaTextureObject_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetTextureObjectTextureDesc%2Cptr.cudaTextureDesc%2CcudaTextureObject_t"><span class="Identifier">cudaGetTextureObjectTextureDesc</span></a><span class="Other">(</span><span class="Identifier">pTexDesc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="texture_types.html#cudaTextureDesc"><span class="Identifier">cudaTextureDesc</span></a><span class="Other">;</span>
                                     <span class="Identifier">texObject</span><span class="Other">:</span> <a href="texture_types.html#cudaTextureObject_t"><span class="Identifier">cudaTextureObject_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetTextureObjectTextureDesc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGetTextureReference-procs-all">
  <div id="cudaGetTextureReference,ptr.ptr.textureReference,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGetTextureReference%2Cptr.ptr.textureReference%2Cpointer"><span class="Identifier">cudaGetTextureReference</span></a><span class="Other">(</span><span class="Identifier">texref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">textureReference</span><span class="Other">;</span> <span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGetTextureReference&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGraphicsMapResources-procs-all">
  <div id="cudaGraphicsMapResources,cint,ptr.cudaGraphicsResource_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGraphicsMapResources%2Ccint%2Cptr.cudaGraphicsResource_t%2CcudaStream_t"><span class="Identifier">cudaGraphicsMapResources</span></a><span class="Other">(</span><span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                              <span class="Identifier">resources</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResource_t</span></a><span class="Other">;</span>
                              <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGraphicsMapResources&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGraphicsResourceGetMappedMipmappedArray-procs-all">
  <div id="cudaGraphicsResourceGetMappedMipmappedArray,ptr.cudaMipmappedArray_t,cudaGraphicsResource_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGraphicsResourceGetMappedMipmappedArray%2Cptr.cudaMipmappedArray_t%2CcudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResourceGetMappedMipmappedArray</span></a><span class="Other">(</span>
    <span class="Identifier">mipmappedArray</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaMipmappedArray_t"><span class="Identifier">cudaMipmappedArray_t</span></a><span class="Other">;</span> <span class="Identifier">resource</span><span class="Other">:</span> <a href="driver_types.html#cudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResource_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGraphicsResourceGetMappedMipmappedArray&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGraphicsResourceGetMappedPointer-procs-all">
  <div id="cudaGraphicsResourceGetMappedPointer,ptr.pointer,ptr.csize_t,cudaGraphicsResource_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGraphicsResourceGetMappedPointer%2Cptr.pointer%2Cptr.csize_t%2CcudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResourceGetMappedPointer</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span>
    <span class="Identifier">size</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">resource</span><span class="Other">:</span> <a href="driver_types.html#cudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResource_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGraphicsResourceGetMappedPointer&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGraphicsResourceSetMapFlags-procs-all">
  <div id="cudaGraphicsResourceSetMapFlags,cudaGraphicsResource_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGraphicsResourceSetMapFlags%2CcudaGraphicsResource_t%2Ccuint"><span class="Identifier">cudaGraphicsResourceSetMapFlags</span></a><span class="Other">(</span><span class="Identifier">resource</span><span class="Other">:</span> <a href="driver_types.html#cudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResource_t</span></a><span class="Other">;</span>
                                     <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGraphicsResourceSetMapFlags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGraphicsSubResourceGetMappedArray-procs-all">
  <div id="cudaGraphicsSubResourceGetMappedArray,ptr.cudaArray_t,cudaGraphicsResource_t,cuint,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGraphicsSubResourceGetMappedArray%2Cptr.cudaArray_t%2CcudaGraphicsResource_t%2Ccuint%2Ccuint"><span class="Identifier">cudaGraphicsSubResourceGetMappedArray</span></a><span class="Other">(</span><span class="Identifier">array</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span>
    <span class="Identifier">resource</span><span class="Other">:</span> <a href="driver_types.html#cudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResource_t</span></a><span class="Other">;</span> <span class="Identifier">arrayIndex</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">;</span> <span class="Identifier">mipLevel</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGraphicsSubResourceGetMappedArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGraphicsUnmapResources-procs-all">
  <div id="cudaGraphicsUnmapResources,cint,ptr.cudaGraphicsResource_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGraphicsUnmapResources%2Ccint%2Cptr.cudaGraphicsResource_t%2CcudaStream_t"><span class="Identifier">cudaGraphicsUnmapResources</span></a><span class="Other">(</span><span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                                <span class="Identifier">resources</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResource_t</span></a><span class="Other">;</span>
                                <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGraphicsUnmapResources&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaGraphicsUnregisterResource-procs-all">
  <div id="cudaGraphicsUnregisterResource,cudaGraphicsResource_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaGraphicsUnregisterResource%2CcudaGraphicsResource_t"><span class="Identifier">cudaGraphicsUnregisterResource</span></a><span class="Other">(</span><span class="Identifier">resource</span><span class="Other">:</span> <a href="driver_types.html#cudaGraphicsResource_t"><span class="Identifier">cudaGraphicsResource_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaGraphicsUnregisterResource&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span>
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaHostAlloc-procs-all">
  <div id="cudaHostAlloc,ptr.pointer,csize_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaHostAlloc%2Cptr.pointer%2Ccsize_t%2Ccuint"><span class="Identifier">cudaHostAlloc</span></a><span class="Other">(</span><span class="Identifier">pHost</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaHostAlloc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaHostGetDevicePointer-procs-all">
  <div id="cudaHostGetDevicePointer,ptr.pointer,pointer,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaHostGetDevicePointer%2Cptr.pointer%2Cpointer%2Ccuint"><span class="Identifier">cudaHostGetDevicePointer</span></a><span class="Other">(</span><span class="Identifier">pDevice</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">pHost</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaHostGetDevicePointer&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaHostGetFlags-procs-all">
  <div id="cudaHostGetFlags,ptr.cuint,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaHostGetFlags%2Cptr.cuint%2Cpointer"><span class="Identifier">cudaHostGetFlags</span></a><span class="Other">(</span><span class="Identifier">pFlags</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuint</span><span class="Other">;</span> <span class="Identifier">pHost</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaHostGetFlags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaHostRegister-procs-all">
  <div id="cudaHostRegister,pointer,csize_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaHostRegister%2Cpointer%2Ccsize_t%2Ccuint"><span class="Identifier">cudaHostRegister</span></a><span class="Other">(</span><span class="Identifier">ptr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaHostRegister&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaHostUnregister-procs-all">
  <div id="cudaHostUnregister,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaHostUnregister%2Cpointer"><span class="Identifier">cudaHostUnregister</span></a><span class="Other">(</span><span class="Identifier">ptr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaHostUnregister&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaIpcCloseMemHandle-procs-all">
  <div id="cudaIpcCloseMemHandle,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaIpcCloseMemHandle%2Cpointer"><span class="Identifier">cudaIpcCloseMemHandle</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaIpcCloseMemHandle&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaIpcGetEventHandle-procs-all">
  <div id="cudaIpcGetEventHandle,ptr.cudaIpcEventHandle_t,cudaEvent_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaIpcGetEventHandle%2Cptr.cudaIpcEventHandle_t%2CcudaEvent_t"><span class="Identifier">cudaIpcGetEventHandle</span></a><span class="Other">(</span><span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaIpcEventHandle_t"><span class="Identifier">cudaIpcEventHandle_t</span></a><span class="Other">;</span> <span class="Identifier">event</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaIpcGetEventHandle&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaIpcGetMemHandle-procs-all">
  <div id="cudaIpcGetMemHandle,ptr.cudaIpcMemHandle_t,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaIpcGetMemHandle%2Cptr.cudaIpcMemHandle_t%2Cpointer"><span class="Identifier">cudaIpcGetMemHandle</span></a><span class="Other">(</span><span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaIpcMemHandle_t"><span class="Identifier">cudaIpcMemHandle_t</span></a><span class="Other">;</span> <span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaIpcGetMemHandle&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaIpcOpenEventHandle-procs-all">
  <div id="cudaIpcOpenEventHandle,ptr.cudaEvent_t,cudaIpcEventHandle_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaIpcOpenEventHandle%2Cptr.cudaEvent_t%2CcudaIpcEventHandle_t"><span class="Identifier">cudaIpcOpenEventHandle</span></a><span class="Other">(</span><span class="Identifier">event</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">;</span> <span class="Identifier">handle</span><span class="Other">:</span> <a href="driver_types.html#cudaIpcEventHandle_t"><span class="Identifier">cudaIpcEventHandle_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaIpcOpenEventHandle&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaIpcOpenMemHandle-procs-all">
  <div id="cudaIpcOpenMemHandle,ptr.pointer,cudaIpcMemHandle_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaIpcOpenMemHandle%2Cptr.pointer%2CcudaIpcMemHandle_t%2Ccuint"><span class="Identifier">cudaIpcOpenMemHandle</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">handle</span><span class="Other">:</span> <a href="driver_types.html#cudaIpcMemHandle_t"><span class="Identifier">cudaIpcMemHandle_t</span></a><span class="Other">;</span>
                          <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaIpcOpenMemHandle&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaLaunch-procs-all">
  <div id="cudaLaunch,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaLaunch%2Cpointer"><span class="Identifier">cudaLaunch</span></a><span class="Other">(</span><span class="Identifier">func</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaLaunch&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaLaunchKernel-procs-all">
  <div id="cudaLaunchKernel,pointer,dim3,dim3,ptr.pointer,csize_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaLaunchKernel%2Cpointer%2Cdim3%2Cdim3%2Cptr.pointer%2Ccsize_t%2CcudaStream_t"><span class="Identifier">cudaLaunchKernel</span></a><span class="Other">(</span><span class="Identifier">func</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">gridDim</span><span class="Other">:</span> <a href="vector_types.html#dim3"><span class="Identifier">dim3</span></a><span class="Other">;</span> <span class="Identifier">blockDim</span><span class="Other">:</span> <a href="vector_types.html#dim3"><span class="Identifier">dim3</span></a><span class="Other">;</span>
                      <span class="Identifier">args</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">sharedMem</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                      <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaLaunchKernel&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMalloc-procs-all">
  <div id="cudaMalloc,ptr.pointer,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMalloc%2Cptr.pointer%2Ccsize_t"><span class="Identifier">cudaMalloc</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMalloc&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMalloc3D-procs-all">
  <div id="cudaMalloc3D,ptr.cudaPitchedPtr,cudaExtent">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMalloc3D%2Cptr.cudaPitchedPtr%2CcudaExtent"><span class="Identifier">cudaMalloc3D</span></a><span class="Other">(</span><span class="Identifier">pitchedDevPtr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaPitchedPtr"><span class="Identifier">cudaPitchedPtr</span></a><span class="Other">;</span> <span class="Identifier">extent</span><span class="Other">:</span> <a href="driver_types.html#cudaExtent"><span class="Identifier">cudaExtent</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMalloc3D&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMalloc3DArray-procs-all">
  <div id="cudaMalloc3DArray,ptr.cudaArray_t,ptr.cudaChannelFormatDesc,cudaExtent,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMalloc3DArray%2Cptr.cudaArray_t%2Cptr.cudaChannelFormatDesc%2CcudaExtent%2Ccuint"><span class="Identifier">cudaMalloc3DArray</span></a><span class="Other">(</span><span class="Identifier">array</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">;</span>
                       <span class="Identifier">extent</span><span class="Other">:</span> <a href="driver_types.html#cudaExtent"><span class="Identifier">cudaExtent</span></a><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMalloc3DArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMallocArray-procs-all">
  <div id="cudaMallocArray,ptr.cudaArray_t,ptr.cudaChannelFormatDesc,csize_t,csize_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMallocArray%2Cptr.cudaArray_t%2Cptr.cudaChannelFormatDesc%2Ccsize_t%2Ccsize_t%2Ccuint"><span class="Identifier">cudaMallocArray</span></a><span class="Other">(</span><span class="Identifier">array</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">;</span>
                     <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMallocArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMallocHost-procs-all">
  <div id="cudaMallocHost,ptr.pointer,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMallocHost%2Cptr.pointer%2Ccsize_t"><span class="Identifier">cudaMallocHost</span></a><span class="Other">(</span><span class="Identifier">ptr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMallocHost&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMallocManaged-procs-all">
  <div id="cudaMallocManaged,ptr.pointer,csize_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMallocManaged%2Cptr.pointer%2Ccsize_t%2Ccuint"><span class="Identifier">cudaMallocManaged</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMallocManaged&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMallocMipmappedArray-procs-all">
  <div id="cudaMallocMipmappedArray,ptr.cudaMipmappedArray_t,ptr.cudaChannelFormatDesc,cudaExtent,cuint,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMallocMipmappedArray%2Cptr.cudaMipmappedArray_t%2Cptr.cudaChannelFormatDesc%2CcudaExtent%2Ccuint%2Ccuint"><span class="Identifier">cudaMallocMipmappedArray</span></a><span class="Other">(</span><span class="Identifier">mipmappedArray</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaMipmappedArray_t"><span class="Identifier">cudaMipmappedArray_t</span></a><span class="Other">;</span>
                              <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaChannelFormatDesc"><span class="Identifier">cudaChannelFormatDesc</span></a><span class="Other">;</span>
                              <span class="Identifier">extent</span><span class="Other">:</span> <a href="driver_types.html#cudaExtent"><span class="Identifier">cudaExtent</span></a><span class="Other">;</span> <span class="Identifier">numLevels</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMallocMipmappedArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMallocPitch-procs-all">
  <div id="cudaMallocPitch,ptr.pointer,ptr.csize_t,csize_t,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMallocPitch%2Cptr.pointer%2Cptr.csize_t%2Ccsize_t%2Ccsize_t"><span class="Identifier">cudaMallocPitch</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">pitch</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                     <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMallocPitch&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemAdvise-procs-all">
  <div id="cudaMemAdvise,pointer,csize_t,cudaMemoryAdvise,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemAdvise%2Cpointer%2Ccsize_t%2CcudaMemoryAdvise%2Ccint"><span class="Identifier">cudaMemAdvise</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">advice</span><span class="Other">:</span> <a href="driver_types.html#cudaMemoryAdvise"><span class="Identifier">cudaMemoryAdvise</span></a><span class="Other">;</span>
                   <span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemAdvise&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy-procs-all">
  <div id="cudaMemcpy,pointer,pointer,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy%2Cpointer%2Cpointer%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpy</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy2D-procs-all">
  <div id="cudaMemcpy2D,pointer,csize_t,pointer,csize_t,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy2D%2Cpointer%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpy2D</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dpitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">spitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                  <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy2D&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy2DArrayToArray-procs-all">
  <div id="cudaMemcpy2DArrayToArray,cudaArray_t,csize_t,csize_t,cudaArray_const_t,csize_t,csize_t,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy2DArrayToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpy2DArrayToArray</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">wOffsetDst</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">hOffsetDst</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span>
                              <span class="Identifier">wOffsetSrc</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">hOffsetSrc</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy2DArrayToArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy2DAsync-procs-all">
  <div id="cudaMemcpy2DAsync,pointer,csize_t,pointer,csize_t,csize_t,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy2DAsync%2Cpointer%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpy2DAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dpitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                       <span class="Identifier">spitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                       <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy2DAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy2DFromArray-procs-all">
  <div id="cudaMemcpy2DFromArray,pointer,csize_t,cudaArray_const_t,csize_t,csize_t,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy2DFromArray%2Cpointer%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpy2DFromArray</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dpitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                           <span class="Identifier">src</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span> <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                           <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                           <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy2DFromArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy2DFromArrayAsync-procs-all">
  <div id="cudaMemcpy2DFromArrayAsync,pointer,csize_t,cudaArray_const_t,csize_t,csize_t,csize_t,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy2DFromArrayAsync%2Cpointer%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpy2DFromArrayAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dpitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                                <span class="Identifier">src</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span> <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                                <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                                <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span>
                                <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy2DFromArrayAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy2DToArray-procs-all">
  <div id="cudaMemcpy2DToArray,cudaArray_t,csize_t,csize_t,pointer,csize_t,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy2DToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpy2DToArray</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                         <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">spitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                         <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy2DToArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy2DToArrayAsync-procs-all">
  <div id="cudaMemcpy2DToArrayAsync,cudaArray_t,csize_t,csize_t,pointer,csize_t,csize_t,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy2DToArrayAsync%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpy2DToArrayAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">spitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy2DToArrayAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy3D-procs-all">
  <div id="cudaMemcpy3D,ptr.cudaMemcpy3DParms">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy3D%2Cptr.cudaMemcpy3DParms"><span class="Identifier">cudaMemcpy3D</span></a><span class="Other">(</span><span class="Identifier">p</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaMemcpy3DParms"><span class="Identifier">cudaMemcpy3DParms</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy3D&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy3DAsync-procs-all">
  <div id="cudaMemcpy3DAsync,ptr.cudaMemcpy3DParms,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy3DAsync%2Cptr.cudaMemcpy3DParms%2CcudaStream_t"><span class="Identifier">cudaMemcpy3DAsync</span></a><span class="Other">(</span><span class="Identifier">p</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaMemcpy3DParms"><span class="Identifier">cudaMemcpy3DParms</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy3DAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy3DPeer-procs-all">
  <div id="cudaMemcpy3DPeer,ptr.cudaMemcpy3DPeerParms">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy3DPeer%2Cptr.cudaMemcpy3DPeerParms"><span class="Identifier">cudaMemcpy3DPeer</span></a><span class="Other">(</span><span class="Identifier">p</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaMemcpy3DPeerParms"><span class="Identifier">cudaMemcpy3DPeerParms</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy3DPeer&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpy3DPeerAsync-procs-all">
  <div id="cudaMemcpy3DPeerAsync,ptr.cudaMemcpy3DPeerParms,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpy3DPeerAsync%2Cptr.cudaMemcpy3DPeerParms%2CcudaStream_t"><span class="Identifier">cudaMemcpy3DPeerAsync</span></a><span class="Other">(</span><span class="Identifier">p</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaMemcpy3DPeerParms"><span class="Identifier">cudaMemcpy3DPeerParms</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpy3DPeerAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyArrayToArray-procs-all">
  <div id="cudaMemcpyArrayToArray,cudaArray_t,csize_t,csize_t,cudaArray_const_t,csize_t,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyArrayToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpyArrayToArray</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">wOffsetDst</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                            <span class="Identifier">hOffsetDst</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span>
                            <span class="Identifier">wOffsetSrc</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">hOffsetSrc</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                            <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyArrayToArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyAsync-procs-all">
  <div id="cudaMemcpyAsync,pointer,pointer,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyAsync%2Cpointer%2Cpointer%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpyAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                     <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyFromArray-procs-all">
  <div id="cudaMemcpyFromArray,pointer,cudaArray_const_t,csize_t,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyFromArray%2Cpointer%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpyFromArray</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span> <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                         <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyFromArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyFromArrayAsync-procs-all">
  <div id="cudaMemcpyFromArrayAsync,pointer,cudaArray_const_t,csize_t,csize_t,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyFromArrayAsync%2Cpointer%2CcudaArray_const_t%2Ccsize_t%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpyFromArrayAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_const_t"><span class="Identifier">cudaArray_const_t</span></a><span class="Other">;</span>
                              <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span>
                              <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyFromArrayAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyFromSymbol-procs-all">
  <div id="cudaMemcpyFromSymbol,pointer,pointer,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyFromSymbol%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpyFromSymbol</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                          <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyFromSymbol&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyFromSymbolAsync-procs-all">
  <div id="cudaMemcpyFromSymbolAsync,pointer,pointer,csize_t,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyFromSymbolAsync%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpyFromSymbolAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                               <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span>
                               <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyFromSymbolAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyPeer-procs-all">
  <div id="cudaMemcpyPeer,pointer,cint,pointer,cint,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyPeer%2Cpointer%2Ccint%2Cpointer%2Ccint%2Ccsize_t"><span class="Identifier">cudaMemcpyPeer</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dstDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                    <span class="Identifier">srcDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyPeer&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyPeerAsync-procs-all">
  <div id="cudaMemcpyPeerAsync,pointer,cint,pointer,cint,csize_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyPeerAsync%2Cpointer%2Ccint%2Cpointer%2Ccint%2Ccsize_t%2CcudaStream_t"><span class="Identifier">cudaMemcpyPeerAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dstDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                         <span class="Identifier">srcDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyPeerAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyToArray-procs-all">
  <div id="cudaMemcpyToArray,cudaArray_t,csize_t,csize_t,pointer,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyToArray%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpyToArray</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                       <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyToArray&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyToArrayAsync-procs-all">
  <div id="cudaMemcpyToArrayAsync,cudaArray_t,csize_t,csize_t,pointer,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyToArrayAsync%2CcudaArray_t%2Ccsize_t%2Ccsize_t%2Cpointer%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpyToArrayAsync</span></a><span class="Other">(</span><span class="Identifier">dst</span><span class="Other">:</span> <a href="driver_types.html#cudaArray_t"><span class="Identifier">cudaArray_t</span></a><span class="Other">;</span> <span class="Identifier">wOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                            <span class="Identifier">hOffset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                            <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyToArrayAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyToSymbol-procs-all">
  <div id="cudaMemcpyToSymbol,pointer,pointer,csize_t,csize_t,cudaMemcpyKind">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyToSymbol%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind"><span class="Identifier">cudaMemcpyToSymbol</span></a><span class="Other">(</span><span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                        <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyToSymbol&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemcpyToSymbolAsync-procs-all">
  <div id="cudaMemcpyToSymbolAsync,pointer,pointer,csize_t,csize_t,cudaMemcpyKind,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemcpyToSymbolAsync%2Cpointer%2Cpointer%2Ccsize_t%2Ccsize_t%2CcudaMemcpyKind%2CcudaStream_t"><span class="Identifier">cudaMemcpyToSymbolAsync</span></a><span class="Other">(</span><span class="Identifier">symbol</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                             <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <a href="driver_types.html#cudaMemcpyKind"><span class="Identifier">cudaMemcpyKind</span></a><span class="Other">;</span>
                             <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemcpyToSymbolAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemGetInfo-procs-all">
  <div id="cudaMemGetInfo,ptr.csize_t,ptr.csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemGetInfo%2Cptr.csize_t%2Cptr.csize_t"><span class="Identifier">cudaMemGetInfo</span></a><span class="Other">(</span><span class="Identifier">free</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">total</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemGetInfo&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemPrefetchAsync-procs-all">
  <div id="cudaMemPrefetchAsync,pointer,csize_t,cint,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemPrefetchAsync%2Cpointer%2Ccsize_t%2Ccint%2CcudaStream_t"><span class="Identifier">cudaMemPrefetchAsync</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">dstDevice</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                          <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemPrefetchAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemRangeGetAttribute-procs-all">
  <div id="cudaMemRangeGetAttribute,pointer,csize_t,cudaMemRangeAttribute,pointer,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemRangeGetAttribute%2Cpointer%2Ccsize_t%2CcudaMemRangeAttribute%2Cpointer%2Ccsize_t"><span class="Identifier">cudaMemRangeGetAttribute</span></a><span class="Other">(</span><span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dataSize</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                              <span class="Identifier">attribute</span><span class="Other">:</span> <a href="driver_types.html#cudaMemRangeAttribute"><span class="Identifier">cudaMemRangeAttribute</span></a><span class="Other">;</span> <span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                              <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemRangeGetAttribute&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemRangeGetAttributes-procs-all">
  <div id="cudaMemRangeGetAttributes,ptr.pointer,ptr.csize_t,ptr.cudaMemRangeAttribute,csize_t,pointer,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemRangeGetAttributes%2Cptr.pointer%2Cptr.csize_t%2Cptr.cudaMemRangeAttribute%2Ccsize_t%2Cpointer%2Ccsize_t"><span class="Identifier">cudaMemRangeGetAttributes</span></a><span class="Other">(</span><span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">dataSizes</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                               <span class="Identifier">attributes</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaMemRangeAttribute"><span class="Identifier">cudaMemRangeAttribute</span></a><span class="Other">;</span>
                               <span class="Identifier">numAttributes</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                               <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemRangeGetAttributes&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemset-procs-all">
  <div id="cudaMemset,pointer,cint,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemset%2Cpointer%2Ccint%2Ccsize_t"><span class="Identifier">cudaMemset</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemset&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemset2D-procs-all">
  <div id="cudaMemset2D,pointer,csize_t,cint,csize_t,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemset2D%2Cpointer%2Ccsize_t%2Ccint%2Ccsize_t%2Ccsize_t"><span class="Identifier">cudaMemset2D</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">pitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                  <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemset2D&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemset2DAsync-procs-all">
  <div id="cudaMemset2DAsync,pointer,csize_t,cint,csize_t,csize_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemset2DAsync%2Cpointer%2Ccsize_t%2Ccint%2Ccsize_t%2Ccsize_t%2CcudaStream_t"><span class="Identifier">cudaMemset2DAsync</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">pitch</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                       <span class="Identifier">width</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">height</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemset2DAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemset3D-procs-all">
  <div id="cudaMemset3D,cudaPitchedPtr,cint,cudaExtent">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemset3D%2CcudaPitchedPtr%2Ccint%2CcudaExtent"><span class="Identifier">cudaMemset3D</span></a><span class="Other">(</span><span class="Identifier">pitchedDevPtr</span><span class="Other">:</span> <a href="driver_types.html#cudaPitchedPtr"><span class="Identifier">cudaPitchedPtr</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">extent</span><span class="Other">:</span> <a href="driver_types.html#cudaExtent"><span class="Identifier">cudaExtent</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemset3D&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemset3DAsync-procs-all">
  <div id="cudaMemset3DAsync,cudaPitchedPtr,cint,cudaExtent,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemset3DAsync%2CcudaPitchedPtr%2Ccint%2CcudaExtent%2CcudaStream_t"><span class="Identifier">cudaMemset3DAsync</span></a><span class="Other">(</span><span class="Identifier">pitchedDevPtr</span><span class="Other">:</span> <a href="driver_types.html#cudaPitchedPtr"><span class="Identifier">cudaPitchedPtr</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                       <span class="Identifier">extent</span><span class="Other">:</span> <a href="driver_types.html#cudaExtent"><span class="Identifier">cudaExtent</span></a><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemset3DAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaMemsetAsync-procs-all">
  <div id="cudaMemsetAsync,pointer,cint,csize_t,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaMemsetAsync%2Cpointer%2Ccint%2Ccsize_t%2CcudaStream_t"><span class="Identifier">cudaMemsetAsync</span></a><span class="Other">(</span><span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">count</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span>
                     <span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaMemsetAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaOccupancyMaxActiveBlocksPerMultiprocessor-procs-all">
  <div id="cudaOccupancyMaxActiveBlocksPerMultiprocessor,ptr.cint,pointer,cint,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaOccupancyMaxActiveBlocksPerMultiprocessor%2Cptr.cint%2Cpointer%2Ccint%2Ccsize_t"><span class="Identifier">cudaOccupancyMaxActiveBlocksPerMultiprocessor</span></a><span class="Other">(</span><span class="Identifier">numBlocks</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span>
    <span class="Identifier">func</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">blockSize</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">dynamicSMemSize</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaOccupancyMaxActiveBlocksPerMultiprocessor&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags-procs-all">
  <div id="cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags,ptr.cint,pointer,cint,csize_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags%2Cptr.cint%2Cpointer%2Ccint%2Ccsize_t%2Ccuint"><span class="Identifier">cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags</span></a><span class="Other">(</span><span class="Identifier">numBlocks</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span>
    <span class="Identifier">func</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">blockSize</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">dynamicSMemSize</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaPeekAtLastError-procs-all">
  <div id="cudaPeekAtLastError">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaPeekAtLastError"><span class="Identifier">cudaPeekAtLastError</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaPeekAtLastError&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaPointerGetAttributes-procs-all">
  <div id="cudaPointerGetAttributes,ptr.cudaPointerAttributes,pointer">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaPointerGetAttributes%2Cptr.cudaPointerAttributes%2Cpointer"><span class="Identifier">cudaPointerGetAttributes</span></a><span class="Other">(</span><span class="Identifier">attributes</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaPointerAttributes"><span class="Identifier">cudaPointerAttributes</span></a><span class="Other">;</span>
                              <span class="Identifier">ptr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaPointerGetAttributes&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaRuntimeGetVersion-procs-all">
  <div id="cudaRuntimeGetVersion,ptr.cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaRuntimeGetVersion%2Cptr.cint"><span class="Identifier">cudaRuntimeGetVersion</span></a><span class="Other">(</span><span class="Identifier">runtimeVersion</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaRuntimeGetVersion&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaSetDevice-procs-all">
  <div id="cudaSetDevice,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaSetDevice%2Ccint"><span class="Identifier">cudaSetDevice</span></a><span class="Other">(</span><span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaSetDevice&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaSetDeviceFlags-procs-all">
  <div id="cudaSetDeviceFlags,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaSetDeviceFlags%2Ccuint"><span class="Identifier">cudaSetDeviceFlags</span></a><span class="Other">(</span><span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaSetDeviceFlags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaSetDoubleForDevice-procs-all">
  <div id="cudaSetDoubleForDevice,ptr.cdouble">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaSetDoubleForDevice%2Cptr.cdouble"><span class="Identifier">cudaSetDoubleForDevice</span></a><span class="Other">(</span><span class="Identifier">d</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cdouble</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaSetDoubleForDevice&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaSetDoubleForHost-procs-all">
  <div id="cudaSetDoubleForHost,ptr.cdouble">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaSetDoubleForHost%2Cptr.cdouble"><span class="Identifier">cudaSetDoubleForHost</span></a><span class="Other">(</span><span class="Identifier">d</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cdouble</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaSetDoubleForHost&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaSetupArgument-procs-all">
  <div id="cudaSetupArgument,pointer,csize_t,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaSetupArgument%2Cpointer%2Ccsize_t%2Ccsize_t"><span class="Identifier">cudaSetupArgument</span></a><span class="Other">(</span><span class="Identifier">arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaSetupArgument&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaSetValidDevices-procs-all">
  <div id="cudaSetValidDevices,ptr.cint,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaSetValidDevices%2Cptr.cint%2Ccint"><span class="Identifier">cudaSetValidDevices</span></a><span class="Other">(</span><span class="Identifier">device_arr</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaSetValidDevices&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamAddCallback-procs-all">
  <div id="cudaStreamAddCallback,cudaStream_t,cudaStreamCallback_t,pointer,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamAddCallback%2CcudaStream_t%2CcudaStreamCallback_t%2Cpointer%2Ccuint"><span class="Identifier">cudaStreamAddCallback</span></a><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">callback</span><span class="Other">:</span> <a href="cuda_runtime_api.html#cudaStreamCallback_t"><span class="Identifier">cudaStreamCallback_t</span></a><span class="Other">;</span>
                           <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamAddCallback&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamAttachMemAsync-procs-all">
  <div id="cudaStreamAttachMemAsync,cudaStream_t,pointer,csize_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamAttachMemAsync%2CcudaStream_t%2Cpointer%2Ccsize_t%2Ccuint"><span class="Identifier">cudaStreamAttachMemAsync</span></a><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">devPtr</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span>
                              <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamAttachMemAsync&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamCreate-procs-all">
  <div id="cudaStreamCreate,ptr.cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamCreate%2Cptr.cudaStream_t"><span class="Identifier">cudaStreamCreate</span></a><span class="Other">(</span><span class="Identifier">pStream</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamCreate&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamCreateWithFlags-procs-all">
  <div id="cudaStreamCreateWithFlags,ptr.cudaStream_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamCreateWithFlags%2Cptr.cudaStream_t%2Ccuint"><span class="Identifier">cudaStreamCreateWithFlags</span></a><span class="Other">(</span><span class="Identifier">pStream</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamCreateWithFlags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamCreateWithPriority-procs-all">
  <div id="cudaStreamCreateWithPriority,ptr.cudaStream_t,cuint,cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamCreateWithPriority%2Cptr.cudaStream_t%2Ccuint%2Ccint"><span class="Identifier">cudaStreamCreateWithPriority</span></a><span class="Other">(</span><span class="Identifier">pStream</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">;</span>
                                  <span class="Identifier">priority</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamCreateWithPriority&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamDestroy-procs-all">
  <div id="cudaStreamDestroy,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamDestroy%2CcudaStream_t"><span class="Identifier">cudaStreamDestroy</span></a><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamDestroy&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamGetFlags-procs-all">
  <div id="cudaStreamGetFlags,cudaStream_t,ptr.cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamGetFlags%2CcudaStream_t%2Cptr.cuint"><span class="Identifier">cudaStreamGetFlags</span></a><span class="Other">(</span><span class="Identifier">hStream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamGetFlags&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamGetPriority-procs-all">
  <div id="cudaStreamGetPriority,cudaStream_t,ptr.cint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamGetPriority%2CcudaStream_t%2Cptr.cint"><span class="Identifier">cudaStreamGetPriority</span></a><span class="Other">(</span><span class="Identifier">hStream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">priority</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamGetPriority&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamQuery-procs-all">
  <div id="cudaStreamQuery,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamQuery%2CcudaStream_t"><span class="Identifier">cudaStreamQuery</span></a><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamQuery&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamSynchronize-procs-all">
  <div id="cudaStreamSynchronize,cudaStream_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamSynchronize%2CcudaStream_t"><span class="Identifier">cudaStreamSynchronize</span></a><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamSynchronize&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaStreamWaitEvent-procs-all">
  <div id="cudaStreamWaitEvent,cudaStream_t,cudaEvent_t,cuint">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaStreamWaitEvent%2CcudaStream_t%2CcudaEvent_t%2Ccuint"><span class="Identifier">cudaStreamWaitEvent</span></a><span class="Other">(</span><span class="Identifier">stream</span><span class="Other">:</span> <a href="driver_types.html#cudaStream_t"><span class="Identifier">cudaStream_t</span></a><span class="Other">;</span> <span class="Identifier">event</span><span class="Other">:</span> <a href="driver_types.html#cudaEvent_t"><span class="Identifier">cudaEvent_t</span></a><span class="Other">;</span> <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaStreamWaitEvent&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaThreadExit-procs-all">
  <div id="cudaThreadExit">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaThreadExit"><span class="Identifier">cudaThreadExit</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaThreadExit&quot;</span><span class="Other">,</span>
                                     <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
                                     <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaThreadGetCacheConfig-procs-all">
  <div id="cudaThreadGetCacheConfig,ptr.cudaFuncCache">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaThreadGetCacheConfig%2Cptr.cudaFuncCache"><span class="Identifier">cudaThreadGetCacheConfig</span></a><span class="Other">(</span><span class="Identifier">pCacheConfig</span><span class="Other">:</span> <span class="Keyword">ptr</span> <a href="driver_types.html#cudaFuncCache"><span class="Identifier">cudaFuncCache</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaThreadGetCacheConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaThreadGetLimit-procs-all">
  <div id="cudaThreadGetLimit,ptr.csize_t,cudaLimit">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaThreadGetLimit%2Cptr.csize_t%2CcudaLimit"><span class="Identifier">cudaThreadGetLimit</span></a><span class="Other">(</span><span class="Identifier">pValue</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">csize_t</span><span class="Other">;</span> <span class="Identifier">limit</span><span class="Other">:</span> <a href="driver_types.html#cudaLimit"><span class="Identifier">cudaLimit</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaThreadGetLimit&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaThreadSetCacheConfig-procs-all">
  <div id="cudaThreadSetCacheConfig,cudaFuncCache">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaThreadSetCacheConfig%2CcudaFuncCache"><span class="Identifier">cudaThreadSetCacheConfig</span></a><span class="Other">(</span><span class="Identifier">cacheConfig</span><span class="Other">:</span> <a href="driver_types.html#cudaFuncCache"><span class="Identifier">cudaFuncCache</span></a><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaThreadSetCacheConfig&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaThreadSetLimit-procs-all">
  <div id="cudaThreadSetLimit,cudaLimit,csize_t">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaThreadSetLimit%2CcudaLimit%2Ccsize_t"><span class="Identifier">cudaThreadSetLimit</span></a><span class="Other">(</span><span class="Identifier">limit</span><span class="Other">:</span> <a href="driver_types.html#cudaLimit"><span class="Identifier">cudaLimit</span></a><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">csize_t</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaThreadSetLimit&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaThreadSynchronize-procs-all">
  <div id="cudaThreadSynchronize">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaThreadSynchronize"><span class="Identifier">cudaThreadSynchronize</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaThreadSynchronize&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="cudaUnbindTexture-procs-all">
  <div id="cudaUnbindTexture,ptr.textureReference">
  <dt><pre><span class="Keyword">proc</span> <a href="#cudaUnbindTexture%2Cptr.textureReference"><span class="Identifier">cudaUnbindTexture</span></a><span class="Other">(</span><span class="Identifier">texref</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">textureReference</span><span class="Other">)</span><span class="Other">:</span> <a href="driver_types.html#cudaError_t"><span class="Identifier">cudaError_t</span></a> {.<span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;cudaUnbindTexture&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">libName</span><span class="Other">,</span> <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>

  </dl>
</div>

  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2024-08-26 03:48:29 UTC</small>
      </div>
    </div>
  </div>
  
  <!-- Google fonts -->
  <link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
  <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>
</body>
</html>
